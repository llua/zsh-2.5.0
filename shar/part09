Path: news.csc.fi!news.eunet.fi!EU.net!uunet!sparky!not-for-mail
From: zsh-list@sterling.com (Bas de Bakker)
Newsgroups: comp.sources.misc
Subject: v43i098:  zsh - The Z shell, version 2.5.0, Part09/18
Followup-To: comp.sources.d
Date: 13 Jul 1994 23:05:18 -0500
Organization: Sterling Software
Lines: 3729
Sender: kent@sparky.sterling.com
Approved: kent@sparky.sterling.com
Message-ID: <302dhu$t56@sparky.sterling.com>
References: <csm-v43i089=zsh.230017@sparky.sterling.com>
NNTP-Posting-Host: sparky.sterling.com
X-Md4-Signature: 67d9fae94e7db48b5920232ae0f1ac86

Submitted-by: zsh-list@sterling.com (Bas de Bakker)
Posting-number: Volume 43, Issue 98
Archive-name: zsh/part09
Environment: UNIX
Supersedes: zsh: Volume 35, Issue 51-72

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  zsh-2.5.0/src/builtin.c.A zsh-2.5.0/src/cond.c
#   zsh-2.5.0/src/mem.c
# Wrapped by kent@sparky on Tue Jul 12 16:47:22 1994
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 9 (of 18)."'
if test -f 'zsh-2.5.0/src/builtin.c.A' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/src/builtin.c.A'\"
else
  echo shar: Extracting \"'zsh-2.5.0/src/builtin.c.A'\" \(56032 characters\)
  sed "s/^X//" >'zsh-2.5.0/src/builtin.c.A' <<'END_OF_FILE'
X/*
X *
X * builtin.c - builtin commands
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made.
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk.
X *
X */
X
X#include "zsh.h"
X#include <errno.h>
X
X#define makecond() allocnode(N_COND)
X
X/* builtin flags */
X
X#define BINF_PLUSOPTS	1	/* +xyz legal */
X#define BINF_R		2	/* this is r (fc -e -) */
X#define BINF_PRINTOPTS	4
X#define BINF_SETOPTS	8
X#define BINF_FCOPTS	16
X#define BINF_TYPEOPT	32
X#define BINF_TYPEOPTS	(BINF_TYPEOPT|BINF_PLUSOPTS)
X#define BINF_ECHOPTS	64
X
X/* builtin funcs */
X
X#define BIN_TYPESET 0
X#define BIN_BG 1
X#define BIN_FG 2
X#define BIN_JOBS 3
X#define BIN_WAIT 4
X#define BIN_DISOWN 5
X#define BIN_BREAK 6
X#define BIN_CONTINUE 7
X#define BIN_EXIT 8
X#define BIN_RETURN 9
X#define BIN_SHIFT 10
X#define BIN_CD 11
X#define BIN_POPD 12
X#define BIN_PUSHD 13
X#define BIN_PRINT 14
X#define BIN_EVAL 15
X#define BIN_SCHED 16
X#define BIN_FC 17
X#define BIN_PUSHLINE 18
X#define BIN_LOGOUT 19
X#define BIN_BUILTIN 20
X#define BIN_TEST 21
X#define BIN_BRACKET 22
X#define BIN_EXPORT 23
X#define BIN_TRUE 24
X#define BIN_FALSE 25
X#define BIN_ECHO 26
X
Xstruct bincmd {
X    char *name;
X    int (*handlerfunc) DCLPROTO((char *, char **, char *, int));
X    int minargs;		/* min # of args */
X    int maxargs;		/* max # of args, or -1 for no limit */
X    int flags;			/* BINF_flags (see above) */
X    int funcid;			/* xbins (see above) for overloaded handlerfuncs */
X    char *optstr;		/* string of legal options */
X    char *defopts;		/* options set by default for overloaded handlerfuncs */
X};
X
Xstatic char *auxdata;
Xstatic int auxlen;
Xstatic int showflag = 0, showflag2 = 0;
X
X#define NULLBINCMD ((int (*) DCLPROTO((char *,char **,char *,int))) 0)
X
Xstruct bincmd builtins[] =
X{
X    {"[", bin_test, 0, -1, 0, BIN_BRACKET, NULL, NULL},
X    {".", bin_dot, 1, -1, 0, 0, NULL, NULL},
X    {":", bin_colon, 0, -1, 0, BIN_TRUE, NULL, NULL},
X    {"alias", bin_alias, 0, -1, 0, 0, "gamr", NULL},
X    {"autoload", bin_typeset, 0, -1, BINF_TYPEOPTS, 0, "txv", "fu"},
X    {"bg", bin_fg, 0, -1, 0, BIN_BG, NULL, NULL},
X    {"bindkey", bin_bindkey, 0, -1, 0, 0, "asvemdr", NULL},
X    {"break", bin_break, 0, 1, 0, BIN_BREAK, NULL, NULL},
X    {"builtin", NULLBINCMD, 0, 0, 0, BIN_BUILTIN, NULL, NULL},
X    {"bye", bin_break, 0, 1, 0, BIN_EXIT, NULL, NULL},
X    {"cd", bin_cd, 0, 2, 0, BIN_CD, NULL, NULL},
X    {"chdir", bin_cd, 0, 2, 0, BIN_CD, NULL, NULL},
X    {"compctl", bin_compctl, 0, -1, 0, 0, NULL, NULL},
X    {"continue", bin_break, 0, 1, 0, BIN_CONTINUE, NULL, NULL},
X    {"declare", bin_typeset, 0, -1, BINF_TYPEOPTS, 0, "LRZfilrtux", NULL},
X    {"dirs", bin_dirs, 0, -1, 0, 0, "v", NULL},
X    {"disable", bin_disable, 0, -1, 0, 0, "-m", NULL},
X    {"disown", bin_fg, 1, -1, 0, BIN_DISOWN, NULL, NULL},
X    {"echo", bin_print, 0, -1, BINF_PRINTOPTS | BINF_ECHOPTS, BIN_ECHO, "n", "-"},
X    {"echotc", bin_echotc, 1, -1, 0, 0, NULL, NULL},
X    {"enable", bin_enable, 0, -1, 0, 0, "m", NULL},
X    {"eval", bin_eval, 0, -1, 0, BIN_EVAL, NULL, NULL},
X    {"exit", bin_break, 0, 1, 0, BIN_EXIT, NULL, NULL},
X    {"export", bin_typeset, 0, -1, BINF_TYPEOPTS, BIN_EXPORT, "LRZfilrtu", "x"},
X    {"false", bin_colon, 0, -1, 0, BIN_FALSE, NULL, NULL},
X    {"fc", bin_fc, 0, -1, BINF_FCOPTS, BIN_FC, "nlreIRWAdDfEm", NULL},
X    {"fg", bin_fg, 0, -1, 0, BIN_FG, NULL, NULL},
X    {"functions", bin_typeset, 0, -1, BINF_TYPEOPTS, 0, "tum", "f"},
X    {"getln", bin_read, 0, -1, 0, 0, "ecnAlE", "zr"},
X    {"getopts", bin_getopts, 2, -1, 0, 0, NULL, NULL},
X    {"hash", bin_hash, 2, 2, 0, 0, NULL, NULL},
X    {"history", bin_fc, 0, -1, 0, BIN_FC, "nrdDfEm", "l"},
X    {"integer", bin_typeset, 0, -1, BINF_TYPEOPTS, 0, "lrtux", "i"},
X    {"jobs", bin_fg, 0, -1, 0, BIN_JOBS, "lpZrs", NULL},
X    {"kill", bin_kill, 0, -1, 0, 0, NULL, NULL},
X    {"let", bin_let, 1, -1, 0, 0, NULL, NULL},
X    {"limit", bin_limit, 0, -1, 0, 0, "sh", NULL},
X    {"local", bin_typeset, 0, -1, BINF_TYPEOPTS, 0, "LRZilrtu", NULL},
X    {"log", bin_log, 0, 0, 0, 0, NULL, NULL},
X    {"logout", bin_break, 0, 1, 0, BIN_LOGOUT, NULL, NULL},
X
X#if defined(MEM_DEBUG) && defined(USE_ZSH_MALLOC)
X    {"mem", bin_mem, 0, 0, 0, 0, "v", NULL},
X#endif
X
X    {"popd", bin_cd, 0, 2, 0, BIN_POPD, NULL, NULL},
X    {"print", bin_print, 0, -1, BINF_PRINTOPTS, BIN_PRINT, "RDPnrslzNu0123456789pioOc-", NULL},
X    {"pushd", bin_cd, 0, 2, 0, BIN_PUSHD, NULL, NULL},
X    {"pushln", bin_print, 0, -1, BINF_PRINTOPTS, BIN_PRINT, NULL, "-nz"},
X    {"pwd", bin_pwd, 0, 0, 0, 0, NULL, NULL},
X    {"r", bin_fc, 0, -1, BINF_R, BIN_FC, "nrl", NULL},
X    {"read", bin_read, 0, -1, 0, 0, "rzu0123456789pkqecnAlE", NULL},
X    {"readonly", bin_typeset, 0, -1, BINF_TYPEOPTS, 0, "LRZfiltux", "r"},
X    {"rehash", bin_rehash, 0, 0, 0, 0, "f", NULL},
X    {"return", bin_break, 0, 1, 0, BIN_RETURN, NULL, NULL},
X    {"sched", bin_sched, 0, -1, 0, 0, NULL, NULL},
X    {"set", bin_set, 0, -1, BINF_SETOPTS | BINF_PLUSOPTS, 0, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZaefghjklmnosuvwxy", NULL},
X    {"setopt", bin_setopt, 0, -1, BINF_PLUSOPTS, 0, "0123456789BCDEFGHIJKLMNOPQRSTUVWXYZaefghjklmnosuvwxy", NULL},
X    {"shift", bin_break, 0, -1, 0, BIN_SHIFT, NULL, NULL},
X    {"source", bin_dot, 1, -1, 0, 0, NULL, NULL},
X    {"suspend", bin_suspend, 0, 0, 0, 0, "f", NULL},
X    {"test", bin_test, 0, -1, 0, BIN_TEST, NULL, NULL},
X    {"ttyctl", bin_ttyctl, 0, 0, 0, 0, "fu", NULL},
X    {"times", bin_times, 0, 0, 0, 0, NULL, NULL},
X    {"trap", bin_trap, 0, -1, 0, 0, NULL, NULL},
X    {"true", bin_colon, 0, -1, 0, BIN_TRUE, NULL, NULL},
X    {"type", bin_whence, 0, -1, 0, 0, "pfam", "v"},
X    {"typeset", bin_typeset, 0, -1, BINF_TYPEOPTS, 0, "LRZfilrtuxm", NULL},
X    {"ulimit", bin_ulimit, 0, 1, 0, 0, "Hacdflmnopstv", NULL},
X    {"umask", bin_umask, 0, 1, 0, 0, NULL, NULL},
X    {"unalias", bin_unalias, 1, -1, 0, 0, "m", NULL},
X    {"unfunction", bin_unhash, 1, -1, 0, 0, "m", NULL},
X    {"unhash", bin_unhash, 1, -1, 0, 0, "m", NULL},
X    {"unlimit", bin_unlimit, 0, -1, 0, 0, "h", NULL},
X    {"unset", bin_unset, 1, -1, 0, 0, "m", NULL},
X    {"unsetopt", bin_setopt, 0, -1, BINF_PLUSOPTS, 1, "0123456789BCDEFGHIJKLMNOPQRSTUWXYZabefghjklmnosuvwxy", NULL},
X    {"vared", bin_vared, 1, 6, 0, 0, NULL, NULL},
X    {"wait", bin_fg, 0, -1, 0, BIN_WAIT, NULL, NULL},
X    {"whence", bin_whence, 0, -1, 0, 0, "pvcfam", NULL},
X    {"which", bin_whence, 0, -1, 0, 0, "pam", "c"},
X    {NULL, NULLBINCMD, 0, 0, 0, 0, NULL, NULL}
X};
X
X/* print options */
X
XSPROTO(void prtopt, (int set));
X
Xstatic void prtopt(set)
Xint set;
X{
X    struct option *opp;
X
X    if (isset(KSHOPTIONPRINT)) {
X	printf("Current option settings\n");
X	for (opp = optns; opp->name; opp++)
X	    printf("%-20s%s\n", opp->name, isset(opp->id) ? "on" : "off");
X    } else
X	for (opp = optns; opp->name; opp++)
X	    if ((!set) == (!isset(opp->id)))
X		puts(opp->name);
X}
X
X/* add builtins to the command hash table */
X
Xvoid addbuiltins()
X{				/**/
X    struct cmdnam *c;
X    struct bincmd *b;
X    int t0;
X
X    for (t0 = 0, b = builtins; b->name; b++, t0++) {
X	c = (Cmdnam) zcalloc(sizeof *c);
X	c->flags = BUILTIN;
X	c->u.binnum = t0;
X	addhnode(ztrdup(b->name), c, cmdnamtab, freecmdnam);
X    }
X}
X
X/* enable */
X
Xint bin_enable(name, argv, ops, whocares)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint whocares;
X{
X    struct cmdnam *c;
X    struct bincmd *b;
X    int t0, ret = 0;
X    Comp com;
X
X    if (!*argv) {
X	listhtable(cmdnamtab, (HFunc) penabledcmd);
X	return 0;
X    }
X    for (; *argv; argv++) {
X	if (ops['m']) {
X	    tokenize(*argv);
X	    if (!(com = parsereg(*argv))) {
X		ret = 1;
X		untokenize(*argv);
X		zwarnnam(name, "bad pattern : %s", *argv, 0);
X		continue;
X	    }
X	    for (t0 = 0, b = builtins; b->name; b++, t0++)
X		if (domatch(b->name, com, 0)) {
X		    c = (Cmdnam) zcalloc(sizeof *c);
X		    c->flags = BUILTIN;
X		    c->u.binnum = t0;
X		    addhnode(ztrdup(b->name), c, cmdnamtab, freecmdnam);
X		}
X	} else {
X	    for (t0 = 0, b = builtins; b->name; b++, t0++)
X		if (!strcmp(*argv, b->name))
X		    break;
X	    if (!b->name) {
X		zerrnam(name, "no such builtin: %s", *argv, 0);
X		ret = 1;
X	    } else {
X		c = (Cmdnam) zcalloc(sizeof *c);
X		c->flags = BUILTIN;
X		c->u.binnum = t0;
X		addhnode(ztrdup(b->name), c, cmdnamtab, freecmdnam);
X	    }
X	}
X    }
X    return ret;
X}
X
X/* :, true, false */
X
Xint bin_colon(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    return (func == BIN_FALSE);
X}
X
X/* break, bye, continue, exit, logout, return, shift */
X
Xint bin_break(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    int num = lastval, nump = 0;
X
X    if (*argv && (**argv == '-' || idigit(**argv))) {
X	num = matheval(*argv++);
X	nump = 1;
X    }
X    if ((func == BIN_BREAK || func == BIN_CONTINUE) && !loops) {
X	if (func == BIN_CONTINUE)
X	    zerrnam(name, "not in loop", NULL, 0);
X	return 1;
X    }
X    switch (func) {
X    case BIN_CONTINUE:
X	contflag = 1;
X    case BIN_BREAK:
X	breaks = nump ? num : 1;
X	if (breaks > loops)
X	    breaks = loops;
X	break;
X    case BIN_RETURN:
X	if (isset(INTERACTIVE) || locallevel || sourcelevel) {
X	    retflag = 1;
X	    breaks = loops;
X	    lastval = num;
X	    if (trapreturn)
X		trapreturn = lastval;
X	    return lastval;
X	}			/* else fall through */
X    case BIN_LOGOUT:
X	if (func == BIN_LOGOUT && !islogin) {
X	    zerrnam(name, "not login shell", NULL, 0);
X	    return 1;
X	}
X    case BIN_EXIT:
X	zexit(num);
X	break;
X    case BIN_SHIFT:
X	{
X	    char **s;
X	    int l;
X
X	    if (!nump)
X		num = 1;
X	    if (num < 0) {
X		zerrnam(name, "bad number", NULL, 0);
X		return 1;
X	    }
X	    if (*argv) {
X		for (; *argv; argv++)
X		    if ((s = getaparam(*argv))) {
X			if (num < (l = arrlen(s)))
X			    l = num;
X			permalloc();
X			s = arrdup(s + l);
X			heapalloc();
X			setaparam(*argv, s);
X		    }
X	    } else {
X		if (num > arrlen(pparams))
X		    num = arrlen(pparams);
X		permalloc();
X		s = arrdup(pparams + num);
X		heapalloc();
X		freearray(pparams);
X		pparams = s;
X	    }
X	    break;
X	}
X    }
X    return 0;
X}
X
X/* bg, disown, fg, jobs, wait */
X
Xint bin_fg(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    int job, lng, firstjob = -1, retval = 0;
X
X    if (ops['Z']) {
X	if (*argv)
X	    strcpy(hackzero, *argv);
X	return 0;
X    }
X    lng = (ops['l']) ? 1 : (ops['p']) ? 2 : 0;
X    if ((func == BIN_FG || func == BIN_BG) && !jobbing) {
X	zwarnnam(name, "no job control in this shell.", NULL, 0);
X	return 1;
X    }
X    if (unset(NOTIFY))
X	scanjobs();
X    if (curjob != -1 && !(jobtab[curjob].stat & STAT_INUSE)) {
X	curjob = prevjob;
X	setprevjob();
X	if (curjob != -1 && !(jobtab[curjob].stat & STAT_INUSE))
X	    curjob = prevjob;
X	setprevjob();
X    }
X    if (func == BIN_JOBS)
X	stopmsg = 2;
X    if (!*argv)
X	if (func == BIN_FG || func == BIN_BG) {
X	    if (curjob == -1 || curjob == thisjob) {
X		zwarnnam(name, "no current job", NULL, 0);
X		return 1;
X	    }
X	    firstjob = curjob;
X	} else if (func == BIN_JOBS) {
X	    for (job = 0; job != MAXJOB; job++)
X		if (job != thisjob && jobtab[job].stat) {
X		    if ((!ops['r'] && !ops['s']) ||
X			(ops['r'] && ops['s']) ||
X			(ops['r'] && !(jobtab[job].stat & STAT_STOPPED)) ||
X			(ops['s'] && jobtab[job].stat & STAT_STOPPED))
X			printjob(job + jobtab, lng);
X		}
X	    return 0;
X	} else {
X	    for (job = 0; job != MAXJOB; job++)
X		if (job != thisjob && jobtab[job].stat)
X		    waitjob(job, SIGINT);
X	    return 0;
X	}
X    for (; (firstjob != -1) || *argv; (void)(*argv && argv++)) {
X	int stopped, ocj = thisjob;
X
X	if (func == BIN_WAIT && isanum(*argv)) {
X	    waitforpid((long)atoi(*argv));
X	    retval = lastval2;
X	    thisjob = ocj;
X	    continue;
X	}
X	job = (*argv) ? getjob(*argv, name) : firstjob;
X	firstjob = -1;
X	if (job == -1)
X	    break;
X	if (!(jobtab[job].stat & STAT_INUSE)) {
X	    zwarnnam(name, "no such job: %d", 0, job);
X	    return 1;
X	}
X	switch (func) {
X	case BIN_FG:
X	case BIN_BG:
X	case BIN_WAIT:
X	    if ((stopped = (jobtab[job].stat & STAT_STOPPED)))
X		makerunning(jobtab + job);
X	    else if (func == BIN_BG) {
X		zwarnnam(name, "job already in background", NULL, 0);
X		thisjob = ocj;
X		return 1;
X	    }
X	    if (curjob == job) {
X		curjob = prevjob;
X		prevjob = (func == BIN_BG) ? -1 : job;
X	    }
X	    if (prevjob == job)
X		prevjob = -1;
X	    if (prevjob == -1)
X		setprevjob();
X	    if (curjob == -1) {
X		curjob = prevjob;
X		setprevjob();
X	    }
X	    if (func != BIN_WAIT)
X		printjob(jobtab + job, (stopped) ? -1 : 0);
X	    if (func != BIN_BG) {
X		if (strcmp(jobtab[job].pwd, pwd)) {
X		    printf("(pwd : ");
X		    printdir(jobtab[job].pwd);
X		    printf(")\n");
X		}
X		fflush(stdout);
X		if (func != BIN_WAIT) {
X		    thisjob = job;
X		    attachtty(jobtab[job].gleader);
X		}
X	    }
X	    if (stopped) {
X		if (func != BIN_BG && jobtab[job].ty)
X		    settyinfo(jobtab[job].ty);
X		killpg(jobtab[job].gleader, SIGCONT);
X	    }
X	    if (func == BIN_WAIT)
X	        waitjob(job, SIGINT);
X	    if (func != BIN_BG) {
X		waitjobs();
X		retval = lastval2;
X	    }
X	    break;
X	case BIN_JOBS:
X	    printjob(job + jobtab, lng);
X	    break;
X	case BIN_DISOWN:
X	    {
X		static struct job zero;
X
X		jobtab[job] = zero;
X		break;
X	    }
X	}
X	thisjob = ocj;
X    }
X    return retval;
X}
X
X/* let */
X
Xint bin_let(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    long val = 0;
X
X    while (*argv)
X	val = matheval(*argv++);
X    return !val;
X}
X
X/* print the directory stack */
X
XSPROTO(void pdstack, (void));
X
Xstatic void pdstack()
X{
X    Lknode node;
X
X    printdir(pwd);
X    for (node = firstnode(dirstack); node; incnode(node)) {
X	putchar(' ');
X	printdir(getdata(node));
X    }
X    putchar('\n');
X}
X
X/* exit the shell */
X
Xvoid zexit(val)			/**/
Xint val;
X{
X    if (isset(MONITOR))
X	if (!stopmsg) {
X	    checkjobs();
X	    if (stopmsg) {
X		stopmsg = 2;
X		return;
X	    }
X	} else
X	    killrunjobs();
X    if (unset(NORCS) && interact) {
X	if (isset(APPENDHISTORY))
X	    savehistfile(getsparam("HISTFILE"), 1, 3);
X	else
X	    savehistfile(getsparam("HISTFILE"), 1, 0);
X	if (islogin && !subsh)
X	    sourcehome(".zlogout");
X    }
X    if (sigtrapped[SIGEXIT])
X	dotrap(SIGEXIT);
X    exit(val);
X}
X
X/* identify an option name */
X
Xint optlookup(s)		/**/
Xchar *s;
X{
X    char *t;
X    struct option *o;
X
X    t = s = dupstring(s);
X    while (*t)
X	if (*t == '_')
X	    chuck(t);
X	else {
X	    *t = tulower(*t);
X	    t++;
X	}
X    for (o = optns; o->name; o++)
X	if (!strcmp(o->name, s))
X	    return (int)o->id;
X    return -1;
X}
X
X/* setopt, unsetopt */
X
Xint bin_setopt(nam, args, ops, isun)	/**/
Xchar *nam;
Xchar **args;
Xchar *ops;
Xint isun;
X{
X    struct option *opp;
X    int c, match;
X
X    match = ops[(int)'m'];
X    ops['m'] = 0;
X    if (!ops['@'] && !*args) {
X	prtopt(!isun);
X	return 0;
X    }
X    for (opp = optns; opp->name; opp++)
X	if (ops[opp->id] == 1 + isun)
X	    opts[(int)opp->id] = OPT_SET;
X	else if (ops[(int)opp->id] == 2 - isun)
X	    opts[(int)opp->id] = OPT_UNSET;
X    if (!match)
X	while (*args) {
X	    c = optlookup(*args++);
X	    if (c != -1) {
X		if (c == INTERACTIVE)
X		    zwarnnam(nam, "can't change option: %s", args[-1], 0);
X		else
X		    opts[c] = (isun) ? OPT_UNSET : OPT_SET;
X	    } else {
X		zwarnnam(nam, "no such option: %s", args[-1], 0);
X		return 1;
X	    }
X    } else {
X	Comp com;
X	struct option *o;
X
X	while (*args) {
X	    tokenize(*args);
X	    if (!(com = parsereg(*args))) {
X		untokenize(*args);
X		zwarnnam(nam, "bad pattern : %s", *args, 0);
X		continue;
X	    }
X	    for (o = optns; o->name; o++)
X		if (o->id != INTERACTIVE && o->id != MONITOR &&
X		    domatch(o->name, com, 0))
X		    opts[(int)o->id] = (isun) ? OPT_UNSET : OPT_SET;
X	    args++;
X	}
X    }
X    return 0;
X}
X
X/* execute func on each member of the hash table ht */
X
Xstatic hnamcmp DCLPROTO((struct hashnode ** a, struct hashnode ** b));
Xstatic int hnamcmp(a, b)
Xstruct hashnode **a;
Xstruct hashnode **b;
X{
X    return forstrcmp(&((*a)->nam), &((*b)->nam));
X}
X
Xvoid listhtable(ht, func)	/**/
XHashtab ht;
XHFunc func;
X{
X    int t0;
X    struct hashnode *hn;
X
X#ifndef HASHORDER
X
X    int nhash;
X    struct hashnode **hnsorttab, **htp;
X
X    hnsorttab = (struct hashnode **)zalloc(ht->ct * sizeof(struct hashnode *));
X
X    for (htp = hnsorttab, t0 = ht->hsize - 1; t0 >= 0; t0--)
X	for (hn = ht->nodes[t0]; hn; hn = hn->next)
X	    *htp++ = hn;
X
X    qsort((vptr) & hnsorttab[0], ht->ct, sizeof(struct hashnode *),
X	           (int (*)DCLPROTO((const void *, const void *)))hnamcmp);
X
X    for (htp = hnsorttab, nhash = 0; nhash < ht->ct; nhash++, htp++)
X	func((*htp)->nam, (char *)(*htp));
X
X    free(hnsorttab);
X
X#else
X
X    for (t0 = ht->hsize - 1; t0 >= 0; t0--)
X	for (hn = ht->nodes[t0]; hn; hn = hn->next)
X	    func(hn->nam, (char *)hn);
X
X#endif
X}
X
X/* print a shell function (used with listhtable) */
X
Xvoid pshfunc(s, cc)		/**/
Xchar *s;
XCmdnam cc;
X{
X    char *t;
X
X    if (!(cc->flags & SHFUNC))
X	return;
X    if (showflag && (cc->flags & showflag2) != showflag2)
X	return;
X    if (cc->flags & PMFLAG_u)
X	printf("undefined ");
X    if (cc->flags & PMFLAG_t)
X	printf("traced ");
X    if (!cc->u.list || !showflag) {
X	printf("%s ()\n", s);
X	return;
X    }
X    t = getpermtext((vptr) dupstruct((vptr) cc->u.list));
X    printf("%s () {\n\t%s\n}\n", s, t);
X    zsfree(t);
X}
X
Xvoid penabledcmd(s, cc)		/**/
Xchar *s;
XCmdnam cc;
X{
X    if (cc->flags & BUILTIN)
X	printf("%s\n", s);
X}
X
Xvoid pdisabledcmd(s, cc)	/**/
Xchar *s;
XCmdnam cc;
X{
X    if (cc->flags & DISABLED)
X	printf("%s\n", s);
X}
X
Xvoid niceprintf(s, f)		/**/
Xchar *s;
XFILE *f;
X{
X    for (; *s; s++) {
X	if (isprint(*s))
X	    fputc(*s, f);
X	else if (*s == '\n') {
X	    putc('\\', f);
X	    putc('n', f);
X	} else {
X	    putc('^', f);
X	    fputc(*s | 0x40, f);
X	}
X    }
X}
X
Xint bin_umask(nam, args, ops, func)	/**/
Xchar *nam;
Xchar **args;
Xchar *ops;
Xint func;
X{
X    int um;
X    char *s = *args;
X
X    um = umask(0);
X    umask(um);
X    if (!s) {
X	printf("%03o\n", (unsigned)um);
X	return 0;
X    }
X    if (idigit(*s)) {
X	um = zstrtol(s, &s, 8);
X	if (*s) {
X	    zwarnnam(nam, "bad umask", NULL, 0);
X	    return 1;
X	}
X    } else {
X	int whomask, umaskop, mask;
X
X	for (;;) {
X	    whomask = 0;
X	    while (*s == 'u' || *s == 'g' || *s == 'o')
X		if (*s == 'u')
X		    s++, whomask |= 0100;
X		else if (*s == 'g')
X		    s++, whomask |= 0010;
X		else if (*s == 'o')
X		    s++, whomask |= 0001;
X	    if (!whomask)
X		whomask = 0111;
X	    umaskop = (int)*s;
X	    if (!(umaskop == '+' || umaskop == '-' || umaskop == '=')) {
X		zwarnnam(nam, "bad symbolic mode operator: %c", NULL, umaskop);
X		return 1;
X	    }
X	    mask = 0;
X	    while (*++s && *s != ',')
X		if (*s == 'r')
X		    mask |= 04 * whomask;
X		else if (*s == 'w')
X		    mask |= 02 * whomask;
X		else if (*s == 'x')
X		    mask |= whomask;
X		else {
X		    zwarnnam(nam, "bad symbolic mode permission: %c",
X			     NULL, *s);
X		    return 1;
X		}
X	    if (umaskop == '+')
X		um &= ~mask;
X	    else if (umaskop == '-')
X		um |= mask;
X	    else		/* umaskop == '=' */
X		um = (um | (whomask * 07)) & ~mask;
X	    if (*s == ',')
X		s++;
X	    else
X		break;
X	}
X	if (*s) {
X	    zwarnnam(nam, "bad character in symbolic mode: %c", NULL, *s);
X	    return 1;
X	}
X    }
X    umask(um);
X    return 0;
X}
X
X/* type, whence, which */
X
Xint bin_whence(nam, argv, ops, func)	/**/
Xchar *nam;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    struct cmdnam *chn;
X    struct alias *a;
X    int retval = 0;
X    int csh = ops[(int)'c'], all = ops[(int)'a'];
X    int v = ops['v'] || csh;
X    char *cnam;
X    int informed;
X
X    for (; *argv; argv++) {
X	if (ops['m']) {
X	    int i, n;
X	    Comp com;
X
X	    tokenize(*argv);
X	    if (!(com = parsereg(*argv))) {
X		retval = 1;
X		untokenize(*argv);
X		zwarnnam(nam, "bad pattern : %s", *argv, 0);
X		continue;
X	    }
X	    if (!ops['p']) {
X		n = aliastab->hsize;
X		for (i = 0; i < n; i++) {
X		    for (a = (struct alias *)aliastab->nodes[i]; a;
X			 a = (struct alias *)a->next) {
X			if (a->nam && domatch(a->nam, com, 0)) {
X			    if (a->cmd < 0)
X				printf((csh) ? "%s: shell reserved word\n" :
X				       (v) ? "%s is a reserved word\n" : "%s\n", a->nam);
X			    else if (!v)
X				puts(a->text);
X			    else if (a->cmd)
X				printf((csh) ? "%s: aliased to %s\n" :
X				       "%s is an alias for %s\n", a->nam, a->text);
X			    else
X				printf((csh) ? "%s: globally aliased to %s\n" :
X				       "%s is a global alias for %s\n", a->nam, a->text);
X			}
X		    }
X		}
X		n = cmdnamtab->hsize;
X		for (i = 0; i < n; i++) {
X		    for (chn = (struct cmdnam *)cmdnamtab->nodes[i]; chn;
X			 chn = (struct cmdnam *)chn->next) {
X			if (chn->nam &&
X			    (chn->flags & (SHFUNC | BUILTIN)) &&
X			    !(chn->flags & EXCMD) &&
X			    domatch(chn->nam, com, 0)) {
X			    if (chn->flags & SHFUNC) {
X				if (csh || ops['f']) {
X				    showflag = 1;
X				    showflag2 = 0;
X				    pshfunc(chn->nam, chn);
X				} else {
X				    printf((v) ? "%s is a function\n" : "%s\n", chn->nam);
X				}
X			    } else
X				printf((csh) ? "%s: shell built-in command\n" :
X				       (v) ? "%s is a shell builtin\n" : "%s\n", chn->nam);
X			}
X		    }
X		}
X	    }
X	    fullhash();
X	    n = cmdnamtab->hsize;
X	    for (i = 0; i < n; i++) {
X		for (chn = (struct cmdnam *)cmdnamtab->nodes[i]; chn;
X		     chn = (struct cmdnam *)chn->next) {
X		    if (chn->nam && (chn->flags & EXCMD) &&
X			domatch(chn->nam, com, 0)) {
X			if (chn->flags & BUILTIN)
X			    printf("%s is hashed to %s\n", chn->nam,
X				   chn->u.cmd);
X			else if (v && !csh)
X			    printf("%s is %s/%s\n", chn->nam,
X				   chn->u.name ? *(chn->u.name) : "",
X				   chn->nam);
X			else
X			    printf("%s/%s\n", chn->u.name ? *(chn->u.name) : "",
X				   chn->nam);
X		    }
X		}
X	    }
X
X	} else {
X	    informed = 0;
X	    if (!ops['p'] && (a = (Alias) gethnode(*argv, aliastab))) {
X		if (a->cmd < 0)
X		    printf((csh) ? "%s: shell reserved word\n" :
X			   (v) ? "%s is a reserved word\n" : "%s\n", *argv);
X		else if (!v)
X		    puts(a->text);
X		else if (a->cmd)
X		    printf((csh) ? "%s: aliased to %s\n" :
X			   "%s is an alias for %s\n", *argv, a->text);
X		else
X		    printf((csh) ? "%s: globally aliased to %s\n" :
X			   "%s is a global alias for %s\n", *argv, a->text);
X		if (!all)
X		    continue;
X		informed = 1;
X	    }
X	    if (!ops['p'] && (chn = (Cmdnam) gethnode(*argv, cmdnamtab)) &&
X		(chn->flags & (SHFUNC | BUILTIN))) {
X		if (chn->flags & EXCMD)
X		    printf("%s is hashed to %s\n", chn->nam, chn->u.cmd);
X		else if (chn->flags & SHFUNC) {
X		    if (csh || ops['f']) {
X			showflag = 1;
X			showflag2 = 0;
X			pshfunc(*argv, chn);
X		    } else {
X			printf((v) ? "%s is a function\n" : "%s\n", *argv);
X		    }
X		} else
X		    printf((csh) ? "%s: shell built-in command\n" :
X			   (v) ? "%s is a shell builtin\n" : "%s\n", *argv);
X		if (!all)
X		    continue;
X		informed = 1;
X	    }
X	    if (all) {
X		char **pp, buf[MAXPATHLEN], *z;
X
X		for (pp = path; *pp; pp++) {
X		    z = buf;
X		    strucpy(&z, *pp);
X		    *z++ = '/';
X		    strcpy(z, *argv);
X		    if (iscom(buf)) {
X			if (v && !csh)
X			    printf("%s is %s\n", *argv, buf);
X			else
X			    puts(buf);
X			informed = 1;
X		    }
X		}
X		if (!informed && v) {
X		    printf("%s not found\n", *argv);
X		    retval = 1;
X		}
X	    } else if (!(cnam = findcmd(*argv))) {
X		if (v)
X		    printf("%s not found\n", *argv);
X		retval = 1;
X	    } else {
X		if (v && !csh)
X		    printf("%s is %s\n", *argv, cnam);
X		else
X		    puts(cnam);
X		zsfree(cnam);
X	    }
X	}
X    }
X    return retval;
X}
X
X/* cd, chdir, pushd, popd */
X
Xint doprintdir = 0;		/* set in exec.c (for autocd) */
X
Xint bin_cd(nam, argv, ops, func)/**/
Xchar *nam;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    char *dest, *dir;
X    struct stat st1, st2;
X
X    doprintdir = (doprintdir == -1);
X
X    if (func == BIN_CD && isset(AUTOPUSHD))
X	func = BIN_PUSHD;
X    dir = dest = cd_get_dest(nam, argv, ops, func);
X    if (!dest)
X	return 1;
X    dest = cd_do_chdir(nam, dest);
X    if (dest != dir)
X	zsfree(dir);
X    if (!dest)
X	return 1;
X    cd_new_pwd(func, dest);
X    zsfree(dest);
X
X    if (stat(pwd, &st1) < 0) {
X	zsfree(pwd);
X	pwd = zgetwd();
X    } else if (stat(".", &st2) < 0)
X	chdir(pwd);
X    else if (st1.st_ino != st2.st_ino || st1.st_dev != st2.st_dev)
X	if (isset(CHASELINKS)) {
X	    zsfree(pwd);
X	    pwd = zgetwd();
X	} else {
X	    chdir(pwd);
X	}
X    return 0;
X}
X
Xchar *cd_get_dest(nam, argv, ops, func)	/**/
Xchar *nam;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    char *dest = NULL;
X
X    if (!argv[0])
X	if (func == BIN_CD || ((func == BIN_PUSHD && isset(PUSHDTOHOME))
X			       || empty(dirstack)))
X	    dest = ztrdup(home);
X	else
X	    dest = ztrdup(getnode(dirstack));
X    else if (!argv[1]) {
X	Lknode n;
X	int dd;
X	char *end;
X
X	doprintdir++;
X	if (argv[0][1] && argv[0][0] == (isset(PUSHDMINUS) ? '-' : '+')) {
X	    dd = zstrtol(argv[0] + 1, &end, 10) - 1;
X	    if (dd >= 0 && *end == '\0') {
X		for (n = firstnode(dirstack); n && dd; dd--, incnode(n));
X		if (!n) {
X		    zwarnnam(nam, "no such entry in dir stack", NULL, 0);
X		    return NULL;
X		}
X		dest = (char *)remnode(dirstack, n);
X	    }
X	} else if (argv[0][1] && argv[0][0] == (isset(PUSHDMINUS) ? '+' : '-')) {
X	    dd = zstrtol(argv[0] + 1, &end, 10);
X	    if (*end == '\0') {
X		for (n = lastnode(dirstack); n != (Lknode) dirstack && dd;
X		     dd--, n = prevnode(n));
X		if (n == (Lknode) dirstack) {
X		    zwarnnam(nam, "no such entry in dir stack", NULL, 0);
X		    return NULL;
X		}
X		dest = (char *)remnode(dirstack, n);
X	    }
X	}
X	if (!dest)
X	    dest = ztrdup(strcmp(argv[0], "-") ? (doprintdir--, argv[0]) :
X			  oldpwd);
X    } else {
X	char *u;
X	int len1, len2, len3;
X
X	if (!(u = ztrstr(pwd, argv[0]))) {
X	    zwarnnam(nam, "string not in pwd: %s", argv[0], 0);
X	    return NULL;
X	}
X	len1 = strlen(argv[0]);
X	len2 = strlen(argv[1]);
X	len3 = u - pwd;
X	dest = (char *)zalloc(len3 + len2 + strlen(u + len1) + 1);
X	strncpy(dest, pwd, len3);
X	strcpy(dest + len3, argv[1]);
X	strcat(dest, u + len1);
X	doprintdir++;
X    }
X    return dest;
X}
X
Xchar *cd_do_chdir(cnam, dest)	/**/
Xchar *cnam;
Xchar *dest;
X{
X    int hasdot = 0, eno = ENOENT;
X    int nocdpath = dest[0] == '.' &&
X    (dest[1] == '/' || !dest[1] || (dest[1] == '.' &&
X				    (dest[2] == '/' || !dest[1])));
X    char **pp, *ret;
X
X    if (*dest == '/') {
X	if ((ret = cd_try_chdir(NULL, dest)))
X	    return ret;
X	zwarnnam(cnam, "%e: %s", dest, errno);
X	return NULL;
X    }
X    if (!nocdpath)
X	for (pp = cdpath; *pp; pp++)
X	    if ((*pp)[0] == '.' && (*pp)[1] == '\0')
X		hasdot = 1;
X    if (!hasdot || nocdpath) {
X	if ((ret = cd_try_chdir(NULL, dest)))
X	    return ret;
X	if (errno != ENOENT)
X	    eno = errno;
X    }
X    if (!nocdpath)
X	for (pp = cdpath; *pp; pp++) {
X	    if ((ret = cd_try_chdir(*pp, dest))) {
X		if (strcmp(*pp, ".")) {
X		    doprintdir++;
X		}
X		return ret;
X	    }
X	    if (errno != ENOENT)
X		eno = errno;
X	}
X    if ((ret = cd_able_vars(dest))) {
X	if ((ret = cd_try_chdir(NULL, ret))) {
X	    doprintdir++;
X	    return ret;
X	}
X	if (errno != ENOENT)
X	    eno = errno;
X    }
X    zwarnnam(cnam, "%e: %s", dest, eno);
X    return NULL;
X}
X
Xchar *cd_able_vars(s)		/**/
Xchar *s;
X{
X    char *rest;
X
X    if (isset(CDABLEVARS)) {
X	for (rest = s; *rest && *rest != '/'; rest++);
X	s = getnamedir(s, rest - s);
X
X	if (s && *rest)
X	    s = dyncat(s, rest);
X
X	return s;
X    }
X    return NULL;
X}
X
Xchar *cd_try_chdir(pfix, dest)	/**/
Xchar *pfix;
Xchar *dest;
X{
X    char buf[MAXPATHLEN], buf2[MAXPATHLEN];
X    char *s;
X    int dotsct;
X
X    if (pfix)
X	sprintf(buf, "%s/%s", (!strcmp("/", pfix)) ? "" : pfix, dest);
X    else
X	strcpy(buf, dest);
X    dotsct = fixdir(buf2, buf);
X    if (buf2[0] == '/')
X	return (chdir(buf) == -1) ? NULL : ztrdup(buf2);
X    if (!dotsct) {
X	if (chdir(buf) == -1)
X	    return NULL;
X	if (*buf2)
X	    sprintf(buf, "%s/%s", (!strcmp("/", pwd)) ? "" : pwd, buf2);
X	else
X	    strcpy(buf, pwd);
X	return ztrdup(buf);
X    }
X    strcpy(buf, pwd);
X    s = buf + strlen(buf) - 1;
X    while (dotsct--)
X	while (s != buf)
X	    if (*--s == '/')
X		break;
X    if (s == buf || *buf2)
X	s++;
X    strcpy(s, buf2);
X    if (chdir(buf) != -1 || chdir(dest) != -1)
X	return ztrdup(buf);
X    return NULL;
X}
X
Xint fixdir(d, s)		/**/
Xchar *d;
Xchar *s;
X{
X    int ct = 0;
X    char *d0 = d;
X
X#ifdef HAS_RFS
X    while (*s == '/' && s[1] == '.' && s[2] == '.') {
X	*d++ = '/';
X	*d++ = '.';
X	*d++ = '.';
X	s += 3;
X    }
X#endif
X#ifdef apollo
X    if (*s == '/')
X	*d++ = *s++;		/*added RBC 18/05/92 */
X#endif
X    for (;;) {
X	if (*s == '/') {
X	    *d++ = *s++;
X	    while (*s == '/')
X		s++;
X	}
X	if (!*s) {
X	    while (d > d0 + 1 && d[-1] == '/')
X		d--;
X	    *d = '\0';
X	    return ct;
X	}
X	if (s[0] == '.' && s[1] == '.' && (s[2] == '\0' || s[2] == '/')) {
X	    if (d > d0 + 1) {
X		for (d--; d > d0 + 1 && d[-1] != '/'; d--);
X		if (d[-1] != '/')
X		    d--;
X	    } else
X		ct++;
X	    s++;
X	    while (*++s == '/');
X	} else if (s[0] == '.' && (s[1] == '/' || s[1] == '\0')) {
X	    while (*++s == '/');
X	} else {
X	    while (*s != '/' && *s != '\0')
X		*d++ = *s++;
X	}
X    }
X}
X
Xvoid cd_new_pwd(func, s)	/**/
Xint func;
Xchar *s;
X{
X    Param pm;
X    List l;
X    char *new_pwd;
X
X    if (isset(CHASELINKS))
X	new_pwd = findpwd(s);
X    else
X	new_pwd = ztrdup(s);
X    if (!strcmp(new_pwd, pwd) &&
X	(func != BIN_PUSHD || isset(PUSHDIGNOREDUPS))) {
X	zsfree(new_pwd);
X#ifdef ALWAYS_DO_CD_PROCESSING
X	if (unset(PUSHDSILENT) && func != BIN_CD && isset(INTERACTIVE))
X	    pdstack();
X	if (l = getshfunc("chpwd")) {
X	    fflush(stdout);
X	    fflush(stderr);
X	    doshfuncnoval(dupstruct(l), NULL, 0);
X	}
X#endif
X	return;
X    }
X    zsfree(oldpwd);
X    oldpwd = pwd;
X    pwd = new_pwd;
X    if ((pm = (Param) gethnode("PWD", paramtab)) &&
X	(pm->flags & PMFLAG_x) && pm->env)
X	pm->env = replenv(pm->env, pwd);
X    if ((pm = (Param) gethnode("OLDPWD", paramtab)) &&
X	(pm->flags & PMFLAG_x) && pm->env)
X	pm->env = replenv(pm->env, oldpwd);
X    if (func == BIN_PUSHD) {
X	permalloc();
X	if (isset(PUSHDIGNOREDUPS)) {
X	    Lknode n;
X	    char *nodedata;
X
X	    for (n = firstnode(dirstack); n; incnode(n)) {
X		nodedata = (char *)getdata(n);
X		if (!strcmp(oldpwd, nodedata) || !strcmp(pwd, nodedata)) {
X		    free(remnode(dirstack, n));
X		    break;
X		}
X	    }
X	}
X	pushnode(dirstack, ztrdup(oldpwd));
X	heapalloc();
X    }
X    if (unset(PUSHDSILENT) && func != BIN_CD && isset(INTERACTIVE))
X	pdstack();
X    else if (doprintdir)
X	printdircr(pwd);
X    if ((l = getshfunc("chpwd"))) {
X	fflush(stdout);
X	fflush(stderr);
X	doshfuncnoval(dupstruct(l), NULL, 0);
X    }
X    if (dirstacksize != -1 && countnodes(dirstack) >= dirstacksize) {
X	if (dirstacksize < 2)
X	    dirstacksize = 2;
X	else
X	    free(remnode(dirstack, lastnode(dirstack)));
X    }
X}
X
Xint bin_rehash(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    newcmdnamtab();
X    if (ops['f'])
X	fullhash();
X    return 0;
X}
X
Xint bin_hash(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    struct cmdnam *chn;
X
X    chn = (Cmdnam) zcalloc(sizeof *chn);
X    chn->flags = HASHCMD;
X    chn->u.cmd = ztrdup(argv[1]);
X    addhnode(ztrdup(argv[0]), chn, cmdnamtab, freecmdnam);
X    return 0;
X}
X
X/* convert %%, %1, %foo, %?bar? to a job number */
X
Xint getjob(s, prog)		/**/
Xchar *s;
Xchar *prog;
X{
X    int t0, retval;
X
X    if (*s != '%')
X	goto jump;
X    s++;
X    if (*s == '%' || *s == '+' || !*s) {
X	if (curjob == -1) {
X	    zwarnnam(prog, "no current job", NULL, 0);
X	    retval = -1;
X	    goto done;
X	}
X	retval = curjob;
X	goto done;
X    }
X    if (*s == '-') {
X	if (prevjob == -1) {
X	    zwarnnam(prog, "no previous job", NULL, 0);
X	    retval = -1;
X	    goto done;
X	}
X	retval = prevjob;
X	goto done;
X    }
X    if (idigit(*s)) {
X	t0 = atoi(s);
X	if (t0 && t0 < MAXJOB && jobtab[t0].stat && t0 != thisjob) {
X	    retval = t0;
X	    goto done;
X	}
X	zwarnnam(prog, "no such job", NULL, 0);
X	retval = -1;
X	goto done;
X    }
X    if (*s == '?') {
X	struct process *pn;
X
X	for (t0 = MAXJOB - 1; t0 >= 0; t0--)
X	    if (jobtab[t0].stat && t0 != thisjob)
X		for (pn = jobtab[t0].procs; pn; pn = pn->next)
X		    if (ztrstr(pn->text, s + 1)) {
X			retval = t0;
X			goto done;
X		    }
X	zwarnnam(prog, "job not found: %s", s, 0);
X	retval = -1;
X	goto done;
X    }
X  jump:
X    if ((t0 = findjobnam(s)) != -1) {
X	retval = t0;
X	goto done;
X    }
X    zwarnnam(prog, "job not found: %s", s, 0);
X    retval = -1;
X  done:
X    return retval;
X}
X
X/* find a job named s */
X
Xint findjobnam(s)		/**/
Xchar *s;
X{
X    int t0;
X
X    for (t0 = MAXJOB - 1; t0 >= 0; t0--)
X	if (jobtab[t0].stat && jobtab[t0].procs && t0 != thisjob &&
X	    jobtab[t0].procs->text && strpfx(s, jobtab[t0].procs->text))
X	    return t0;
X    return -1;
X}
X
Xint isanum(s)			/**/
Xchar *s;
X{
X    while (*s == '-' || idigit(*s))
X	s++;
X    return *s == '\0';
X}
X
Xint bin_kill(nam, argv, ops, func)	/**/
Xchar *nam;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    int sig = SIGTERM;
X    int retval = 0;
X
X    if (*argv && **argv == '-') {
X	if (idigit((*argv)[1]))
X	    sig = atoi(*argv + 1);
X	else {
X	    if ((*argv)[1] == 'l' && (*argv)[2] == '\0') {
X		printf("%s", sigs[1]);
X		for (sig = 2; sig <= SIGCOUNT; sig++)
X		    printf(" %s", sigs[sig]);
X		putchar('\n');
X		return 0;
X	    }
X	    for (sig = 1; sig <= SIGCOUNT; sig++)
X		if (!strcmp(sigs[sig], *argv + 1))
X		    break;
X	    if (sig > SIGCOUNT) {
X		zwarnnam(nam, "unknown signal: SIG%s", *argv + 1, 0);
X		zwarnnam(nam, "type kill -l for a List of signals", NULL, 0);
X		return 1;
X	    }
X	}
X	argv++;
X    }
X    for (; *argv; argv++) {
X	if (**argv == '%') {
X	    int p = getjob(*argv, "kill");
X
X	    if (p == -1) {
X		retval = 1;
X		continue;
X	    }
X	    if (killjb(jobtab + p, sig) == -1) {
X		zwarnnam("kill", "kill failed: %e", NULL, errno);
X		retval = 1;
X		continue;
X	    }
X	    if (jobtab[p].stat & STAT_STOPPED) {
X		if (sig == SIGCONT)
X		    jobtab[p].stat &= ~STAT_STOPPED;
X		if (sig != SIGKILL && sig != SIGCONT && sig != SIGTSTP
X		    && sig != SIGTTOU && sig != SIGTTIN && sig != SIGSTOP)
X		    killjb(jobtab + p, SIGCONT);
X	    }
X	} else if (!isanum(*argv)) {
X	    zwarnnam("kill", "illegal pid: %s", *argv, 0);
X	    retval = 1;
X	} else if (kill(atoi(*argv), sig) == -1) {
X	    zwarnnam("kill", "kill failed: %e", NULL, errno);
X	    retval = 1;
X	}
X    }
X    return retval;
X}
X
X#ifdef RLIM_INFINITY
Xstatic char *recs[] =
X{
X    "cputime", "filesize", "datasize", "stacksize", "coredumpsize",
X#ifdef RLIMIT_RSS
X#ifdef RLIMIT_MEMLOCK
X    "memoryuse",
X#else
X    "resident",
X#endif				/* RLIMIT_MEMLOCK */
X#endif				/* RLIMIT_RSS */
X#ifdef RLIMIT_MEMLOCK
X    "memorylocked",
X#endif
X#ifdef RLIMIT_NPROC
X    "maxproc",
X#endif
X#ifdef RLIMIT_OFILE
X    "openfiles",
X#endif
X#ifdef RLIMIT_NOFILE
X    "descriptors",
X#endif
X#ifdef RLIMIT_VMEM
X    "vmemorysize"
X#endif
X};
X#endif
X
Xint bin_limit(nam, argv, ops, func)	/**/
Xchar *nam;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X#ifndef RLIM_INFINITY
X    zwarnnam(nam, "not available on this system", NULL, 0);
X    return 1;
X#else
X    char *s;
X    int hard = ops['h'], t0, lim;
X    long val;
X
X    if (ops['s']) {
X	if (*argv)
X	    zwarnnam(nam, "arguments after -s ignored", NULL, 0);
X	for (t0 = 0; t0 != RLIM_NLIMITS; t0++)
X	    if (setrlimit(t0, limits + t0) < 0)
X		zwarnnam(nam, "setrlimit failed: %e", NULL, errno);
X	return 0;
X    }
X    if (!*argv) {
X	showlimits(hard, -1);
X	return 0;
X    }
X    while ((s = *argv++)) {
X	for (lim = -1, t0 = 0; t0 != RLIM_NLIMITS; t0++)
X	    if (!strncmp(recs[t0], s, strlen(s))) {
X		if (lim != -1)
X		    lim = -2;
X		else
X		    lim = t0;
X	    }
X	if (lim < 0) {
X	    zwarnnam("limit",
X		     (lim == -2) ? "ambiguous resource specification: %s"
X		     : "no such resource: %s", s, 0);
X	    return 1;
X	}
X	if (!(s = *argv++)) {
X	    showlimits(hard, lim);
X	    return 0;
X	}
X	if (!lim) {
X	    val = zstrtol(s, &s, 10);
X	    if (*s)
X		if ((*s == 'h' || *s == 'H') && !s[1])
X		    val *= 3600L;
X		else if ((*s == 'm' || *s == 'M') && !s[1])
X		    val *= 60L;
X		else if (*s == ':')
X		    val = val * 60 + zstrtol(s + 1, &s, 10);
X		else {
X		    zwarnnam("limit", "unknown scaling factor: %s", s, 0);
X		    return 1;
X		}
X	}
X#ifdef RLIMIT_NPROC
X	else if (lim == RLIMIT_NPROC)
X	    val = zstrtol(s, &s, 10);
X#endif
X#ifdef RLIMIT_OFILE
X	else if (lim == RLIMIT_OFILE)
X	    val = zstrtol(s, &s, 10);
X#endif
X#ifdef RLIMIT_NOFILE
X	else if (lim == RLIMIT_NOFILE)
X	    val = zstrtol(s, &s, 10);
X#endif
X	else {
X	    val = zstrtol(s, &s, 10);
X	    if (!*s || ((*s == 'k' || *s == 'K') && !s[1]))
X		val *= 1024L;
X	    else if ((*s == 'M' || *s == 'm') && !s[1])
X		val *= 1024L * 1024;
X	    else {
X		zwarnnam("limit", "unknown scaling factor: %s", s, 0);
X		return 1;
X	    }
X	}
X	if (hard)
X	    if (val > limits[lim].rlim_max && geteuid()) {
X		zwarnnam("limit", "can't raise hard limits", NULL, 0);
X		return 1;
X	    } else {
X		limits[lim].rlim_max = val;
X		if (limits[lim].rlim_max < limits[lim].rlim_cur)
X		    limits[lim].rlim_cur = limits[lim].rlim_max;
X	} else if (val > limits[lim].rlim_max) {
X	    zwarnnam("limit", "limit exceeds hard limit", NULL, 0);
X	    return 1;
X	} else
X	    limits[lim].rlim_cur = val;
X    }
X    return 0;
X#endif
X}
X
Xint bin_unlimit(nam, argv, ops, func)	/**/
Xchar *nam;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X#ifndef RLIM_INFINITY
X    zwarnnam(nam, "not available on this system", NULL, 0);
X    return 1;
X#else
X    int hard = ops['h'], t0, lim;
X
X    if (hard && geteuid()) {
X	zwarnnam(nam, "can't remove hard limits", NULL, 0);
X	return 1;
X    }
X    if (!*argv) {
X	for (t0 = 0; t0 != RLIM_NLIMITS; t0++) {
X	    if (hard)
X		limits[t0].rlim_max = RLIM_INFINITY;
X	    else
X		limits[t0].rlim_cur = limits[t0].rlim_max;
X	}
X	return 0;
X    }
X    for (; *argv; argv++) {
X	for (lim = -1, t0 = 0; t0 != RLIM_NLIMITS; t0++)
X	    if (!strncmp(recs[t0], *argv, strlen(*argv))) {
X		if (lim != -1)
X		    lim = -2;
X		else
X		    lim = t0;
X	    }
X	if (lim < 0) {
X	    zwarnnam(nam,
X		     (lim == -2) ? "ambiguous resource specification: %s"
X		     : "no such resource: %s", *argv, 0);
X	    return 1;
X	}
X	if (hard)
X	    limits[lim].rlim_max = RLIM_INFINITY;
X	else
X	    limits[lim].rlim_cur = limits[lim].rlim_max;
X    }
X    return 0;
X#endif
X}
X
X#ifdef RLIM_INFINITY
Xvoid showlimits(hard, lim)	/**/
Xint hard;
Xint lim;
X{
X    int t0;
X    RLIM_TYPE val;
X
X    for (t0 = 0; t0 != RLIM_NLIMITS; t0++)
X	if (t0 == lim || lim == -1) {
X	    printf("%-16s", recs[t0]);
X	    val = (hard) ? limits[t0].rlim_max : limits[t0].rlim_cur;
X	    if (val == RLIM_INFINITY)
X		printf("unlimited\n");
X	    else if (!t0)
X		printf("%d:%02d:%02d\n", (int)(val / 3600),
X		       (int)(val / 60) % 60, (int)(val % 60));
X#ifdef RLIMIT_NPROC
X	    else if (t0 == RLIMIT_NPROC)
X		printf("%d\n", (int)val);
X#endif
X#ifdef RLIMIT_OFILE
X	    else if (t0 == RLIMIT_OFILE)
X		printf("%d\n", (int)val);
X#endif
X#ifdef RLIMIT_NOFILE
X	    else if (t0 == RLIMIT_NOFILE)
X		printf("%d\n", (int)val);
X#endif
X	    else if (val >= 1024L * 1024L)
X		printf("%ldMb\n", val / (1024L * 1024L));
X	    else
X		printf("%ldKb\n", val / 1024L);
X	}
X}
X#endif
X
Xint bin_sched(nam, argv, ops, func)	/**/
Xchar *nam;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    char *s = *argv++;
X    time_t t;
X    long h, m;
X    struct tm *tm;
X    struct schedcmd *sch, *sch2, *schl;
X    int t0;
X
X    if (s && *s == '-') {
X	t0 = atoi(s + 1);
X
X	if (!t0) {
X	    zwarnnam("sched", "usage for delete: sched -<item#>.", NULL, 0);
X	    return 1;
X	}
X	for (schl = (struct schedcmd *)&schedcmds, sch = schedcmds, t0--;
X	     sch && t0; sch = (schl = sch)->next, t0--);
X	if (!sch) {
X	    zwarnnam("sched", "not that many entries", NULL, 0);
X	    return 1;
X	}
X	schl->next = sch->next;
X	zsfree(sch->cmd);
X	zfree(sch, sizeof(struct schedcmd));
X
X	return 0;
X    }
X    if (!s) {
X	char tbuf[40];
X
X	for (t0 = 1, sch = schedcmds; sch; sch = sch->next, t0++) {
X	    t = sch->time;
X	    tm = localtime(&t);
X	    ztrftime(tbuf, 20, "%a %b %e %k:%M:%S", tm);
X	    printf("%3d %s %s\n", t0, tbuf, sch->cmd);
X	}
X	return 0;
X    } else if (!*argv) {
X	zwarnnam("sched", "not enough arguments", NULL, 0);
X	return 1;
X    }
X    if (*s == '+') {
X	h = zstrtol(s + 1, &s, 10);
X	if (*s != ':') {
X	    zwarnnam("sched", "bad time specifier", NULL, 0);
X	    return 1;
X	}
X	m = zstrtol(s + 1, &s, 10);
X	if (*s) {
X	    zwarnnam("sched", "bad time specifier", NULL, 0);
X	    return 1;
X	}
X	t = time(NULL) + h * 3600 + m * 60;
X    } else {
X	h = zstrtol(s, &s, 10);
X	if (*s != ':') {
X	    zwarnnam("sched", "bad time specifier", NULL, 0);
X	    return 1;
X	}
X	m = zstrtol(s + 1, &s, 10);
X	if (*s && *s != 'a' && *s != 'p') {
X	    zwarnnam("sched", "bad time specifier", NULL, 0);
X	    return 1;
X	}
X	t = time(NULL);
X	tm = localtime(&t);
X	t -= tm->tm_sec + tm->tm_min * 60 + tm->tm_hour * 3600;
X	if (*s == 'p')
X	    h += 12;
X	t += h * 3600 + m * 60;
X	if (t < time(NULL))
X	    t += 3600 * 24;
X    }
X    sch = (struct schedcmd *)zcalloc(sizeof *sch);
X    sch->time = t;
X    sch->cmd = ztrdup(spacejoin(argv));
X    sch->next = NULL;
X    for (sch2 = (struct schedcmd *)&schedcmds; sch2->next; sch2 = sch2->next);
X    sch2->next = sch;
X    return 0;
X}
X
Xint bin_eval(nam, argv, ops, func)	/**/
Xchar *nam;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    char *s = ztrdup(spacejoin(argv));
X    List list;
X
X    hungets(s);
X    zsfree(s);
X    strinbeg();
X    if (!(list = parse_list())) {
X	hflush();
X	strinend();
X	return 1;
X    }
X    strinend();
X    runlist(list);
X    return lastval;
X}
X
X/* get the history event associated with s */
X
Xint fcgetcomm(s)		/**/
Xchar *s;
X{
X    int cmd;
X
X    if ((cmd = atoi(s))) {
X	if (cmd < 0)
X	    cmd = curhist + cmd;
X	if (cmd >= curhist) {
X	    zwarnnam("fc", "bad history number: %d", 0, cmd);
X	    return -1;
X	}
X	return cmd;
X    }
X    cmd = hcomsearch(s);
X    if (cmd == -1)
X	zwarnnam("fc", "event not found: %s", s, 0);
X    return cmd;
X}
X
X/* perform old=new substituion */
X
Xint fcsubs(sp, sub)		/**/
Xchar **sp;
Xstruct asgment *sub;
X{
X    char *s1, *s2, *s3, *s4, *s = *sp, *s5;
X    int subbed = 0;
X
X    while (sub) {
X	s1 = sub->name;
X	s2 = sub->value;
X	sub = sub->next;
X	s5 = s;
X	while ((s3 = (char *)ztrstr(s5, s1))) {
X	    s4 = (char *)
X		alloc(1 + (s3 - s) + strlen(s2) + strlen(s3 + strlen(s1)));
X	    ztrncpy(s4, s, s3 - s);
X	    strcat(s4, s2);
X	    s5 = s4 + strlen(s4);
X	    strcat(s4, s3 + strlen(s1));
X	    s = s4;
X	    subbed = 1;
X	}
X    }
X    *sp = s;
X    return subbed;
X}
X
X/* print a series of history events to a file */
X
Xint fclist(f, n, r, D, d, first, last, subs, com)	/**/
XFILE *f;
Xint n;
Xint r;
Xint D;
Xint d;
Xint first;
Xint last;
Xstruct asgment *subs;
XComp com;
X{
X    int fclistdone = 0;
X    char *s, *hs;
X    Histent ent;
X
X    if (r) {
X	r = last;
X	last = first;
X	first = r;
X    }
X    if (!subs)
X	fclistdone = 1;
X    for (;;) {
X	hs = quietgetevent(first);
X	if (!hs) {
X	    zwarnnam("fc", "no such event: %d", NULL, first);
X	    return 1;
X	}
X	s = makehstr(hs);
X	if (!com || domatch(s, com, 0)) {
X	    fclistdone |= fcsubs(&s, subs);
X	    if (n)
X		fprintf(f, "%5d  ", first);
X	    ent = NULL;
X	    if (d) {
X		struct tm *ltm;
X
X		if (!ent)
X		    ent = gethistent(first);
X		ltm = localtime(&ent->stim);
X		if (d >= 2) {
X		    if (d >= 4) {
X			fprintf(f, "%d.%d.%d ",
X				ltm->tm_mday, ltm->tm_mon + 1,
X				ltm->tm_year + 1900);
X		    } else {
X			fprintf(f, "%d/%d/%d ",
X				ltm->tm_mon + 1,
X				ltm->tm_mday,
X				ltm->tm_year + 1900);
X		    }
X		}
X		fprintf(f, "%02d:%02d  ", ltm->tm_hour, ltm->tm_min);
X	    }
X	    if (D) {
X		long diff;
X
X		if (!ent)
X		    ent = gethistent(first);
X		diff = (ent->ftim) ? ent->ftim - ent->stim : 0;
X		fprintf(f, "%ld:%02ld  ", diff / 60, diff % 60);
X	    }
X	    if (f == stdout) {
X		niceprintf(s, f);
X		putc('\n', f);
X	    } else
X		fprintf(f, "%s\n", s);
X	}
X	if (first == last)
X	    break;
X	else if (first > last)
X	    first--;
X	else
X	    first++;
X    }
X    if (f != stdout)
X	fclose(f);
X    if (!fclistdone) {
X	zwarnnam("fc", "no substitutions performed", NULL, 0);
X	return 1;
X    }
X    return 0;
X}
X
Xint fcedit(ename, fn)		/**/
Xchar *ename;
Xchar *fn;
X{
X    if (!strcmp(ename, "-"))
X	return 1;
X    return !zyztem(ename, fn);
X}
X
X/* fc, history, r */
X
Xint bin_fc(nam, argv, ops, func)/**/
Xchar *nam;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    int first = -1, last = -1, retval, delayrem, minflag = 0;
X    char *s;
X    struct asgment *asgf = NULL, *asgl = NULL;
X    Comp com = NULL;
X
X    if (!interact) {
X	zwarnnam(nam, "not interactive shell", NULL, 0);
X	return 1;
X    }
X    if (*argv && ops['m']) {
X	tokenize(*argv);
X	if (!(com = parsereg(*argv++))) {
X	    zwarnnam(nam, "invalid match pattern", NULL, 0);
X	    return 1;
X	}
X    }
X    delayrem = !strcmp(nam, "r");
X    if (!delayrem && !(ops['l'] && unset(HISTNOSTORE)) &&
X	(ops['R'] || ops['W'] || ops['A']))
X	remhist();
X    if (ops['R']) {
X	readhistfile(*argv ? *argv : getsparam("HISTFILE"), 1);
X	return 0;
X    }
X    if (ops['W']) {
X	savehistfile(*argv ? *argv : getsparam("HISTFILE"), 1,
X		     (ops['I'] ? 2 : 0));
X	return 0;
X    }
X    if (ops['A']) {
X	savehistfile(*argv ? *argv : getsparam("HISTFILE"), 1,
X		     (ops['I'] ? 3 : 1));
X	return 0;
X    }
X    while (*argv && equalsplit(*argv, &s)) {
X	struct asgment *a = (struct asgment *)alloc(sizeof *a);
X
X	if (!asgf)
X	    asgf = asgl = a;
X	else {
X	    asgl->next = a;
X	    asgl = a;
X	}
X	a->name = *argv;
X	a->value = s;
X	argv++;
X    }
X    if (*argv) {
X	minflag = **argv == '-';
X	first = fcgetcomm(*argv);
X	if (first == -1)
X	    return 1;
X	argv++;
X    }
X    if (*argv) {
X	last = fcgetcomm(*argv);
X	if (last == -1)
X	    return 1;
X	argv++;
X    }
X    if (*argv) {
X	zwarnnam("fc", "too many arguments", NULL, 0);
X	return 1;
X    }
X    if (first == -1)
X	first = (ops['l']) ? curhist - 16 : curhist - 1;
X    if (last == -1)
X	last = (ops['l']) ? curhist : first;
X    if (first < firsthist())
X	first = firsthist();
X    if (last == -1)
X	last = (minflag) ? curhist : first;
X    if (ops['l'])
X	retval = fclist(stdout, !ops['n'], ops['r'], ops['D'],
X			ops['d'] + ops['f'] * 2 + ops['E'] * 4,
X			first, last, asgf, com);
X    else {
X	FILE *out;
X	char *fil = gettemp();
X
X	retval = 1;
X	out = fopen(fil, "w");
X	if (!out)
X	    zwarnnam("fc", "can't open temp file: %e", NULL, errno);
X	else {
X	    if (!fclist(out, 0, ops['r'], 0, 0, first, last, asgf, com))
X		if (fcedit(auxdata ? auxdata : fceditparam, fil))
X		    if (stuff(fil))
X			zwarnnam("fc", "%e: %s", s, errno);
X		    else
X			retval = 0;
X	}
X	unlink(fil);
X    }
X    if (delayrem)
X	remhist();
X    return retval;
X}
X
Xint bin_suspend(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    if (islogin && !ops['f']) {
X	zerrnam(name, "can't suspend login shell", NULL, 0);
X	return 1;
X    }
X    if (jobbing) {
X	sig_default(SIGPIPE);
X	sig_default(SIGTTIN);
X	sig_default(SIGTSTP);
X	sig_default(SIGTTOU);
X    }
X    kill(0, SIGTSTP);
X    if (jobbing) {
X	while (gettygrp() != mypgrp) {
X	    sleep(1);
X	    if (gettygrp() != mypgrp)
X		kill(0, SIGTTIN);
X	}
X	sig_ignore(SIGTTOU);
X	sig_ignore(SIGTSTP);
X	sig_ignore(SIGTTIN);
X	sig_ignore(SIGPIPE);
X    }
X    return 0;
X}
X
Xint bin_alias(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    struct alias *an;
X    struct asgment *asg;
X    int incm = !(ops['a'] || ops['g']), ret = 0;
X
X    if (ops['r'])
X	showflag = 2;
X    else
X	showflag = !incm;
X    if (!*argv)
X	listhtable(aliastab, (HFunc) printalias);
X    else
X	while ((asg = getasg(*argv++))) {
X	    if (asg->value)
X		addhnode(ztrdup(asg->name), mkanode(ztrdup(asg->value), incm),
X			 aliastab, freeanode);
X	    else if (ops['m']) {
X		int n, i;
X		struct alias *a;
X		Comp com;
X
X		tokenize(argv[-1]);
X		if (!(com = parsereg(argv[-1]))) {
X		    ret = 1;
X		    untokenize(argv[-1]);
X		    zerrnam(name, "bad pattern : %s", argv[-1], 0);
X		    continue;
X		}
X		n = aliastab->hsize;
X		for (i = 0; i < n; i++) {
X		    for (a = (struct alias *)aliastab->nodes[i]; a;
X			 a = (struct alias *)a->next) {
X			if (a->nam && domatch(a->nam, com, 0))
X			    printalias(a->nam, a), ret = 0;
X		    }
X		}
X	    } else if ((an = (Alias) gethnode(asg->name, aliastab))) {
X		if ((!ops['r'] || an->cmd == 1) &&
X		    (!ops['g'] || !an->cmd))
X		    printalias(asg->name, an);
X	    } else
X		ret = 1;
X	}
X    return ret;
X}
X
X/* print an alias; used with listhtable */
X
Xvoid printalias(s, a)		/**/
Xchar *s;
Xstruct alias *a;
X{
X    char *ptr;
X    int special = 0;
X
X    if (a->cmd >= 0 && (!showflag ||
X			(showflag == 1 && !a->cmd) ||
X			(showflag == 2 && a->cmd)))
X	/*!(showflag && a->cmd))*/  {
X	for (ptr = a->text; *ptr; ptr++)
X	    if (ispecial(*ptr))
X		special++;
X	if (special) {
X	    printf("%s=\'", s);
X	    for (ptr = a->text; *ptr; ptr++)
X		if (*ptr == '\'')
X		    printf("\'\\\'\'");
X		else
X		    putchar(*ptr);
X	    printf("\'\n");
X	} else
X	    printf("%s=%s\n", s, a->text);
X	}
X}
X
X/* print a param; used with listhtable */
X
Xvoid printparam(s, p)		/**/
Xchar *s;
XParam p;
X{
X    if ((showflag > 0 && !(p->flags & showflag)) || (p->flags & PMFLAG_UNSET))
X	return;
X    if (!showflag) {
X	int fgs = p->flags;
X
X	if (fgs & PMFLAG_i)
X	    printf("integer ");
X	if (fgs & PMFLAG_A)
X	    printf("array ");
X	if (fgs & PMFLAG_L)
X	    printf("left justified %d ", p->ct);
X	if (fgs & PMFLAG_R)
X	    printf("right justified %d ", p->ct);
X	if (fgs & PMFLAG_Z)
X	    printf("zero filled %d ", p->ct);
X	if (fgs & PMFLAG_l)
X	    printf("lowercase ");
X	if (fgs & PMFLAG_u)
X	    printf("uppercase ");
X	if (fgs & PMFLAG_r)
X	    printf("readonly ");
X	if (fgs & PMFLAG_t)
X	    printf("tagged ");
X	if (fgs & PMFLAG_x)
X	    printf("exported ");
X    }
X    if (showflag2)
X	printf("%s\n", s);
X    else {
X	char *t, **u;
X
X	printf("%s=", s);
X	switch (p->flags & PMTYPE) {
X	case PMFLAG_s:
X	    if (p->gets.cfn && (t = p->gets.cfn(p)))
X		puts(t);
X	    else
X		putchar('\n');
X	    break;
X	case PMFLAG_i:
X	    printf("%ld\n", p->gets.ifn(p));
X	    break;
X	case PMFLAG_A:
X	    putchar('(');
X	    u = p->gets.afn(p);
X	    if (!*u)
X		printf(")\n");
X	    else {
X		while (u[1])
X		    printf("%s ", *u++);
X		printf("%s)\n", *u);
X	    }
X	    break;
X	}
X    }
X}
X
X/* autoload, declare, export, functions, integer, local, readonly, typeset */
X
Xint bin_typeset(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    int on = 0, off = 0, roff, bit = 1, retcode = 0, initon, initoff;
X    char *optstr = "LRZilurtx";
X    struct param *pm;
X    struct asgment *asg;
X
X    for (; *optstr; optstr++, bit <<= 1)
X	if (ops[*optstr] == 1)
X	    on |= bit;
X	else if (ops[*optstr] == 2)
X	    off |= bit;
X    roff = off;
X    if (ops['f']) {
X	on &= PMFLAG_t | PMFLAG_u;
X	off &= PMFLAG_t | PMFLAG_u;
X	showflag = (ops['f'] == 1);
X	if (ops['@'] && ((off & ~PMFLAG_t) || (on & ~(PMFLAG_u | PMFLAG_t)))) {
X	    zerrnam(name, "invalid option(s)", NULL, 0);
X	    return 1;
X	}
X	showflag2 = 0;
X	if (!*argv) {
X	    showflag2 = off | on;
X	    listhtable(cmdnamtab, (HFunc) pshfunc);
X	} else if (ops['m']) {
X	    Comp com;
X	    int i, n;
X	    struct cmdnam *chn;
X
X	    on &= ~512;
X	    for (; *argv; argv++) {
X		tokenize(*argv);
X		if (!(com = parsereg(*argv))) {
X		    retcode = 1;
X		    untokenize(*argv);
X		    zerrnam(name, "bad pattern : %s", *argv, 0);
X		    continue;
X		}
X		n = cmdnamtab->hsize;
X		for (i = 0; i < n; i++)
X		    for (chn = (struct cmdnam *)cmdnamtab->nodes[i]; chn;
X			 chn = (struct cmdnam *)chn->next)
X			if ((chn->flags & SHFUNC) &&
X			    domatch(chn->nam, com, 0)) {
X			    if (on | off)
X				chn->flags = (chn->flags | on) & (~off);
X			    else
X				pshfunc(chn->nam, chn);
X			}
X	    }
X	} else
X	    for (; *argv; argv++) {
X		Cmdnam cc;
X
X		if ((cc = (Cmdnam) gethnode(*argv, cmdnamtab)) &&
X		    (cc->flags & SHFUNC))
X		    if (on | off)
X			cc->flags = (cc->flags | on) & (~off);
X		    else
X			pshfunc(*argv, cc);
X		else if (on & PMFLAG_u) {
X		    cc = (Cmdnam) zcalloc(sizeof *cc);
X		    cc->flags = SHFUNC | on;
X		    addhnode(ztrdup(*argv), cc, cmdnamtab, freecmdnam);
X		} else
X		    retcode = 1;
X	    }
X	return retcode;
X    }
X    if ((on | off) & PMFLAG_x)
X	func = BIN_EXPORT;
X    if (on & PMFLAG_i)
X	off |= PMFLAG_R | PMFLAG_L | PMFLAG_Z | PMFLAG_u | PMFLAG_A;
X    if (on & PMFLAG_L)
X	off |= PMFLAG_R | PMFLAG_i;
X    if (on & PMFLAG_R)
X	off |= PMFLAG_L | PMFLAG_i;
X    if (on & PMFLAG_Z)
X	off |= PMFLAG_i;
X    if (on & PMFLAG_u)
X	off |= PMFLAG_l;
X    if (on & PMFLAG_l)
X	off |= PMFLAG_u;
X    on &= ~off;
X    showflag = showflag2 = 0;
X    initon = on;
X    initoff = off;
X    if (!*argv) {
X	showflag = on | roff;
X	showflag2 = roff || ops['+'];
X	listhtable(paramtab, (HFunc) printparam);
X    } else
X	while ((asg = getasg(*argv++))) {
X	    on = initon;
X	    off = initoff;
X	    if (ops['m']) {
X		Comp com;
X		int i, n;
X
X		on &= ~512;
X		tokenize(asg->name);
X		if (!(com = parsereg(asg->name))) {
X		    untokenize(asg->name);
X		    zerrnam(name, "bad pattern : %s", argv[-1], 0);
X		    continue;
X		}
X		n = paramtab->hsize;
X		for (i = 0; i < n; i++)
X		    for (pm = (struct param *)paramtab->nodes[i]; pm;
X			 pm = (struct param *)pm->next)
X			if (domatch(pm->nam, com, 0)) {
X			    if (!on && !roff && !asg->value) {
X				printparam(pm->nam, pm);
X				continue;
X			    }
X			    pm->flags = (pm->flags | on) & ~off;
X			    if ((on & (PMFLAG_L | PMFLAG_R | PMFLAG_Z | PMFLAG_i))
X				&& (pmtype(pm) != PMFLAG_A))
X				pm->ct = auxlen;
X			    if (pmtype(pm) != PMFLAG_A) {
X				if (pm->flags & PMFLAG_x) {
X				    if (!pm->env)
X					pm->env = addenv(pm->nam,
X							 (asg->value) ? asg->value : getsparam(pm->nam));
X				} else if (pm->env) {
X				    delenv(pm->env);
X				    zsfree(pm->env);
X				    pm->env = NULL;
X				}
X				if (asg->value)
X				    setsparam(pm->nam, ztrdup(asg->value));
X			    }
X			}
X	    } else {
X		if (!isident(asg->name)) {
X		    zerr("not an identifier: %s", asg->name, 0);
X		    continue;
X		}
X		pm = (Param) gethnode(asg->name, paramtab);
X		if (pm && (pm->flags & PMFLAG_SPECIAL)) {
X		    func = 0;
X		    on = (pmtype(pm) == PMFLAG_i) ?
X			(on &= ~(PMFLAG_L | PMFLAG_R | PMFLAG_Z | PMFLAG_u)) :
X			(on & ~PMFLAG_i);
X		    off &= ~PMFLAG_i;
X		}
X		if (pm && pm->level)
X		    on &= ~PMFLAG_x;
X		bit = 0;	/* flag for switching int<->not-int */
X		if (pm && !(pm->flags & PMFLAG_UNSET) &&
X		    ((((locallevel == pm->level) || func == BIN_EXPORT)
X		      && !(bit = ((off & pm->flags) | (on & ~pm->flags)) & PMFLAG_i)) ||
X		     (pm->flags & PMFLAG_SPECIAL))) {
X		    if (!on && !roff && !asg->value) {
X			printparam(asg->name, pm);
X			continue;
X		    }
X		    pm->flags = (pm->flags | on) & ~off;
X		    if (on & (PMFLAG_L | PMFLAG_R | PMFLAG_Z | PMFLAG_i))
X			pm->ct = auxlen;
X		    if (pmtype(pm) != PMFLAG_A) {
X			if (pm->flags & PMFLAG_x) {
X			    if (!pm->env)
X				pm->env = addenv(asg->name,
X						 (asg->value) ? asg->value : getsparam(asg->name));
X			} else if (pm->env) {
X			    delenv(pm->env);
X			    zsfree(pm->env);
X			    pm->env = NULL;
X			}
X			if (asg->value)
X			    setsparam(asg->name, ztrdup(asg->value));
X		    }
X		} else {
X		    int readonly = on & PMFLAG_r;
X
X		    if (bit) {
X			if (!asg->value)
X			    asg->value = dupstring(getsparam(asg->name));
X			unsetparam(asg->name);
X		    } else if (locallist && func != BIN_EXPORT) {
X			permalloc();
X			addnode(locallist, ztrdup(asg->name));
X			heapalloc();
X		    }
X		    pm = createparam(ztrdup(asg->name), on & ~PMFLAG_r);
X		    pm->ct = auxlen;
X		    if (func != BIN_EXPORT)
X			pm->level = locallevel;
X		    if (asg->value)
X			setsparam(asg->name, ztrdup(asg->value));
X		    pm->flags |= readonly;
X		}
X	    }
X	}
X    return 0;
X}
X
X/* Check whether a command is a bin_typeset. */
X
Xint istypeset(c, nam)		/**/
XCmdnam c;
Xchar *nam;
X{
X    struct bincmd *b;
X
X    if (c)
X	if ((c->flags & BUILTIN) && !(c->flags & EXCMD))
X	    return (builtins[c->u.binnum].handlerfunc == bin_typeset);
X	else
X	    nam = c->nam;
X    if (nam)
X	for (b = builtins; b->name; b++)
X	    if (!strcmp(nam, b->name) && b->handlerfunc == bin_typeset)
X		return 1;
X    return 0;
X}
X
X/* echo, print, pushln */
X
Xint bin_print(name, args, ops, func)	/**/
Xchar *name;
Xchar **args;
Xchar *ops;
Xint func;
X{
X    int nnl = 0, fd;
X    Histent ent;
X    FILE *fout = stdout;
X
X    if (ops['z']) {
X	permalloc();
X	pushnode(bufstack, ztrdup(spacejoin(args)));
X	heapalloc();
X	return 0;
X    }
X    if (ops['s']) {
X	permalloc();
X	ent = gethistent(++curhist);
X	zsfree(ent->lex);
X	zsfree(ent->lit);
X	ent->lex = ztrdup(join(args, HISTSPACE));
X	ent->lit = ztrdup(join(args, ' '));
X	ent->stim = ent->ftim = time(NULL);
X	ent->flags = 0;
X	heapalloc();
X	return 0;
X    }
X    if (ops['R'])
X	ops['r'] = 1;
X    if (ops['u'] || ops['p']) {
X	if (ops['u']) {
X	    for (fd = 0; fd < 10; fd++)
X		if (ops[fd + '0'])
X		    break;
END_OF_FILE
  if test 56032 -ne `wc -c <'zsh-2.5.0/src/builtin.c.A'`; then
    echo shar: \"'zsh-2.5.0/src/builtin.c.A'\" unpacked with wrong size!
  elif test -f 'zsh-2.5.0/src/builtin.c.B'; then
    echo shar: Combining  \"'zsh-2.5.0/src/builtin.c'\" \(106554 characters\)
    cat 'zsh-2.5.0/src/builtin.c.A' 'zsh-2.5.0/src/builtin.c.B' > 'zsh-2.5.0/src/builtin.c'
    if test 106554 -ne `wc -c <'zsh-2.5.0/src/builtin.c'`; then
      echo shar: \"'zsh-2.5.0/src/builtin.c'\" combined with wrong size!
    else
      rm zsh-2.5.0/src/builtin.c.A zsh-2.5.0/src/builtin.c.B
    fi
  fi
  # end of 'zsh-2.5.0/src/builtin.c.A'
fi
if test -f 'zsh-2.5.0/src/cond.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/src/cond.c'\"
else
  echo shar: Extracting \"'zsh-2.5.0/src/cond.c'\" \(4309 characters\)
  sed "s/^X//" >'zsh-2.5.0/src/cond.c' <<'END_OF_FILE'
X
X/*
X *
X * cond.c - evaluate conditional expressions
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made.
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk.
X *
X */
X
X#include "zsh.h"
X
Xint evalcond(c)			/**/
XCond c;
X{
X    struct stat *st;
X
X    switch (c->type) {
X    case COND_NOT:
X	return !evalcond(c->left);
X    case COND_AND:
X	return evalcond(c->left) && evalcond(c->right);
X    case COND_OR:
X	return evalcond(c->left) || evalcond(c->right);
X    }
X    singsub((char **)&c->left);
X    untokenize(c->left);
X    if (c->right) {
X	singsub((char **)&c->right);
X	if (c->type != COND_STREQ && c->type != COND_STRNEQ)
X	    untokenize(c->right);
X    }
X    switch (c->type) {
X    case COND_STREQ:
X	return matchpat(c->left, c->right);
X    case COND_STRNEQ:
X	return !matchpat(c->left, c->right);
X    case COND_STRLT:
X	return strcmp(c->left, c->right) < 0;
X    case COND_STRGTR:
X	return strcmp(c->left, c->right) > 0;
X    case 'e':
X    case 'a':
X	return (doaccess(c->left, F_OK));
X    case 'b':
X	return (S_ISBLK(dostat(c->left)));
X    case 'c':
X	return (S_ISCHR(dostat(c->left)));
X    case 'd':
X	return (S_ISDIR(dostat(c->left)));
X    case 'f':
X	return (S_ISREG(dostat(c->left)));
X    case 'g':
X	return (!!(dostat(c->left) & S_ISGID));
X    case 'k':
X	return (!!(dostat(c->left) & S_ISVTX));
X    case 'n':
X	return (!!strlen(c->left));
X    case 'o':
X	return (optison(c->left));
X    case 'p':
X	return (S_ISFIFO(dostat(c->left)));
X    case 'r':
X	return (doaccess(c->left, R_OK));
X    case 's':
X	return ((st = getstat(c->left)) && !!(st->st_size));
X    case 'S':
X	return (S_ISSOCK(dostat(c->left)));
X    case 'u':
X	return (!!(dostat(c->left) & S_ISUID));
X    case 'w':
X	return (doaccess(c->left, W_OK));
X    case 'x':
X	return (doaccess(c->left, X_OK));
X    case 'z':
X	return (!strlen(c->left));
X    case 'h':
X    case 'L':
X	return (S_ISLNK(dolstat(c->left)));
X    case 'O':
X	return ((st = getstat(c->left)) && st->st_uid == geteuid());
X    case 'G':
X	return ((st = getstat(c->left)) && st->st_gid == getegid());
X    case 't':
X	return isatty(matheval(c->left));
X    case COND_EQ:
X	return matheval(c->left) == matheval(c->right);
X    case COND_NE:
X	return matheval(c->left) != matheval(c->right);
X    case COND_LT:
X	return matheval(c->left) < matheval(c->right);
X    case COND_GT:
X	return matheval(c->left) > matheval(c->right);
X    case COND_LE:
X	return matheval(c->left) <= matheval(c->right);
X    case COND_GE:
X	return matheval(c->left) >= matheval(c->right);
X    case COND_NT:
X    case COND_OT:
X	{
X	    time_t a;
X
X	    if (!(st = getstat(c->left)))
X		return 0;
X	    a = st->st_mtime;
X	    if (!(st = getstat(c->right)))
X		return 0;
X	    return (c->type == COND_NT) ? a > st->st_mtime : a < st->st_mtime;
X	}
X    case COND_EF:
X	{
X	    dev_t d;
X	    ino_t i;
X
X	    if (!(st = getstat(c->left)))
X		return 0;
X	    d = st->st_dev;
X	    i = st->st_ino;
X	    if (!(st = getstat(c->right)))
X		return 0;
X	    return d == st->st_dev && i == st->st_ino;
X	}
X    default:
X	zerr("bad cond structure", NULL, 0);
X    }
X    return 0;
X}
X
Xint doaccess(s, c)		/**/
Xchar *s;
Xint c;
X{
X    return !access(s, c);
X}
X
Xstatic struct stat st;
X
Xstruct stat *getstat(s)		/**/
Xchar *s;
X{
X    if (!strncmp(s, "/dev/fd/", 8)) {
X	if (fstat(atoi(s + 8), &st))
X	    return NULL;
X    } else if (stat(s, &st))
X	return NULL;
X    return &st;
X}
X
Xunsigned short dostat(s)	/**/
Xchar *s;
X{
X    struct stat *statp;
X
X    if (!(statp = getstat(s)))
X	return 0;
X    return statp->st_mode;
X}
X
X/* pem@aaii.oz; needed since dostat now uses "stat" */
X
Xunsigned short dolstat(s)	/**/
Xchar *s;
X{
X    if (lstat(s, &st) < 0)
X	return 0;
X    return st.st_mode;
X}
X
Xint optison(s)			/**/
Xchar *s;
X{
X    int i;
X
X    if (strlen(s) == 1)
X	return opts[(int)*s];
X    if ((i = optlookup(s)) != -1)
X	return opts[i];
X    zerr("no such option: %s", s, 0);
X    return 0;
X}
END_OF_FILE
  if test 4309 -ne `wc -c <'zsh-2.5.0/src/cond.c'`; then
    echo shar: \"'zsh-2.5.0/src/cond.c'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/src/cond.c'
fi
if test -f 'zsh-2.5.0/src/mem.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/src/mem.c'\"
else
  echo shar: Extracting \"'zsh-2.5.0/src/mem.c'\" \(21990 characters\)
  sed "s/^X//" >'zsh-2.5.0/src/mem.c' <<'END_OF_FILE'
X/*
X *
X * mem.c - memory management
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made.
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk.
X *
X */
X
X#include "zsh.h"
X
Xvptr(*alloc) DCLPROTO((int));
Xvptr(*ncalloc) DCLPROTO((int));
X
X/*
X
X	There are two ways to allocate memory in zsh.  The first way is
X	to call zalloc/zcalloc, which call malloc/calloc directly.  It
X	is legal to call realloc() or free() on memory allocated this way.
X	The second way is to call halloc/hcalloc, which allocates memory
X	from one of the memory pools on the heap stack.  A pool can be
X	created by calling pushheap(), and destroyed by calling popheap().
X	To free the memory in the pool without destroying it, call
X	freeheap(); this is equivalent to { popheap(); pushheap(); }
X	Memory allocated in this way does not have to be freed explicitly;
X	it will all be freed when the pool is destroyed.  In fact,
X	attempting to free this memory may result in a core dump.
X	The pair of pointers ncalloc and alloc may point to either
X	zalloc & zcalloc or halloc & hcalloc; permalloc() sets them to the
X	former, and heapalloc() sets them to the latter. This can be useful.
X	For example, the dupstruct() routine duplicates a syntax tree,
X	allocating the new memory for the tree using alloc().  If you want
X	to duplicate a structure for a one-time use (i.e. to execute the list
X	in a for loop), call heapalloc(), then dupstruct().  If you want
X	to duplicate a structure in order to preserve it (i.e. a function
X	definition), call permalloc(), then dupstruct().
X
X	If we use zsh's own allocator we use a simple trick to avoid that
X	the (*real*) heap fills up with empty zsh-heaps: we allocate a
X	large block of memory before allocating a heap pool, this memory
X	is freed again immediatly after the pool is allocated. If there
X	are only small blocks on the free list this guarentees that the
X	memory for the pool is at the end of the memory which means that
X	we can give it back to the systems when the pool is freed.
X*/
X
X#if defined(MEM_DEBUG) && defined(USE_ZSH_MALLOC)
X
Xint h_m[1025], h_push, h_pop, h_free;
X
X#endif
X
X#define H_ISIZE  sizeof(long)
X
X#define HEAPSIZE (8192 - H_ISIZE)
X#define HEAPFREE (16384 - H_ISIZE)
X
X/* set default allocation to heap stack */
X
Xvoid heapalloc()
X{				/**/
X    alloc = hcalloc;
X    ncalloc = halloc;
X    useheap = 1;
X}
X
Xstatic vptr(*lastcalloc) DCLPROTO((int));
Xstatic vptr(*lastncalloc) DCLPROTO((int));
Xstatic int lastuseheap;
X
X/* set default allocation to malloc() */
X
Xvoid permalloc()
X{				/**/
X    lastcalloc = alloc;
X    lastncalloc = ncalloc;
X    lastuseheap = useheap;
X    alloc = zcalloc;
X    ncalloc = zalloc;
X    useheap = 0;
X}
X
X/* reset previous default allocation */
X
Xvoid lastalloc()
X{				/**/
X    alloc = lastcalloc;
X    ncalloc = lastncalloc;
X    useheap = lastuseheap;
X}
X
Xstruct heappos {
X    struct heappos *next;
X    char *ptr;
X    int free;
X};
X
Xstruct heap {
X    struct heap *next;
X    struct heappos pos;
X    char *arena;
X};
X
XHeap heaps;
X
X/* create a memory pool */
X
Xvoid pushheap()
X{				/**/
X    Heap h;
X    Heappos hp;
X
X#if defined(MEM_DEBUG) && defined(USE_ZSH_MALLOC)
X    h_push++;
X#endif
X
X    for (h = heaps; h; h = h->next) {
X	hp = (Heappos) zalloc(sizeof(*hp));
X	hp->next = h->pos.next;
X	h->pos.next = hp;
X	hp->free = h->pos.free;
X	hp->ptr = h->pos.ptr;
X    }
X}
X
X/* reset a memory pool */
X
Xvoid freeheap()
X{				/**/
X    Heap h;
X
X#if defined(MEM_DEBUG) && defined(USE_ZSH_MALLOC)
X    h_free++;
X#endif
X    for (h = heaps; h; h = h->next) {
X	if (h->pos.next) {
X	    h->pos.free = h->pos.next->free;
X	    h->pos.ptr = h->pos.next->ptr;
X	} else {
X	    h->pos.free += (int)(h->pos.ptr - h->arena);
X	    h->pos.ptr = h->arena;
X	}
X    }
X}
X
X/* destroy a memory pool */
X
Xvoid popheap()
X{				/**/
X    Heap h, hn, hl = NULL;
X    Heappos hp, hpn;
X
X#if defined(MEM_DEBUG) && defined(USE_ZSH_MALLOC)
X    h_pop++;
X#endif
X
X    for (h = heaps; h; h = hn) {
X	hn = h->next;
X	if ((hp = h->pos.next)) {
X	    h->pos.next = hp->next;
X	    h->pos.free = hp->free;
X	    h->pos.ptr = hp->ptr;
X	    zfree(hp, sizeof(struct heappos));
X
X	    hl = h;
X	} else {
X	    for (hp = h->pos.next; hp; hp = hpn) {
X		hpn = hp->next;
X		free(hp);
X	    }
X	    zfree(h->arena, HEAPSIZE);
X	    zfree(h, sizeof(struct heap));
X	}
X    }
X    if (hl)
X	hl->next = NULL;
X    else
X	heaps = NULL;
X}
X
X/* allocate memory from the current memory pool */
X
Xvptr halloc(size)		/**/
Xint size;
X{
X    Heap h, hp;
X    char *ret;
X
X    zigunsafe();
X
X    size = (size + H_ISIZE - 1) & ~(H_ISIZE - 1);
X
X#if defined(MEM_DEBUG) && defined(USE_ZSH_MALLOC)
X    h_m[size < 1024 ? (size / H_ISIZE) : 1024]++;
X#endif
X
X    for (h = heaps; h && h->pos.free < size; h = h->next);
X
X    if (h) {
X	ret = h->pos.ptr;
X	h->pos.ptr += size;
X	h->pos.free -= size;
X    } else {
X	int n = (size > HEAPSIZE) ? size : HEAPSIZE;
X
X#ifdef USE_ZSH_MALLOC
X	static int called = 0;
X	vptr foo;
X
X	if (called)
X	    foo = (vptr) malloc(HEAPFREE);
X#endif
X
X	for (hp = NULL, h = heaps; h; hp = h, h = h->next);
X
X	h = (Heap) zalloc(sizeof *h);
X	h->arena = (char *)zalloc(n);
X
X#ifdef USE_ZSH_MALLOC
X	if (called)
X	    zfree(foo, HEAPFREE);
X	called = 1;
X#endif
X
X	h->next = NULL;
X
X	if (hp)
X	    hp->next = h;
X	else
X	    heaps = h;
X
X	h->pos.next = NULL;
X	h->pos.ptr = h->arena + size;
X
X	h->pos.free = n - size;
X
X	ret = h->arena;
X    }
X
X    zigsafe();
X
X    return (vptr) ret;
X}
X
X/* allocate memory from the current memory pool and clear it */
X
Xvptr hcalloc(size)		/**/
Xint size;
X{
X    vptr ptr;
X
X    ptr = halloc(size);
X    memset(ptr, 0, size);
X    return ptr;
X}
X
Xvptr hrealloc(p, old, new)	/**/
Xchar *p;
Xint old;
Xint new;
X{
X    char *ptr;
X
X    ptr = (char *)halloc(new);
X    memcpy(ptr, p, old);
X    return (vptr) ptr;
X}
X
X/* allocate permanent memory */
X
Xvptr zalloc(l)			/**/
Xint l;
X{
X    vptr z;
X
X    zigunsafe();
X
X    if (!l)
X	l = 1;
X    if (!(z = (vptr) malloc(l))) {
X	zerr("fatal error: out of memory", NULL, 0);
X	exit(1);
X    }
X    zigsafe();
X
X    return z;
X}
X
Xvptr zcalloc(size)		/**/
Xint size;
X{
X    vptr ptr;
X
X    ptr = zalloc(size);
X    memset(ptr, 0, size);
X    return ptr;
X}
X
Xchar *dupstring(s)		/**/
Xconst char *s;
X{
X    char *t;
X
X    if (!s)
X	return NULL;
X    t = (char *)ncalloc(strlen((char *)s) + 1);
X    strcpy(t, s);
X    return t;
X}
X
Xchar *ztrdup(s)			/**/
Xconst char *s;
X{
X    char *t;
X
X    if (!s)
X	return NULL;
X    t = (char *)zalloc(strlen((char *)s) + 1);
X    strcpy(t, s);
X    return t;
X}
X
X#ifdef USE_ZSH_MALLOC
X
X/*
X   Below is a simple segment oriented memory allocator for systems on
X   which it is better than the system's one. Memory id given in blocks
X   aligned to an integer multiple of sizeof(long) (4 bytes on most machines,
X   but 8 bytes on e.g. a dec alpha). Each block is preceded by a header
X   which contains the length of the data part (in bytes). In allocated
X   blocks only this field of the structure m_hdr is senseful. In free
X   blocks the second field (next) is a pointer to the next free segment
X   on the free list.
X
X   On top of this simple allocator there is a second allocator for small
X   chunks of data. It should be both faster and less space-consuming than
X   using the normal segment mechanism for such blocks.
X   For the first M_NSMALL-1 possible sizes memory is allocated in arrays
X   that can hold M_SNUM blocks. Each array is stored in one segment of the
X   main allocator. In these segments the third field of the header structure
X   (free) contains a pointer to the first free block in the array. The
X   last field (used) gives the number of already used blocks in the array.
X
X   If the macro name MEM_DEBUG is defined, some information about the memory
X   usage is stored. This information can than be viewed by calling the
X   builtin `mem' (which is only available if MEM_DEBUG is set).
X
X   If MEM_WARNING is defined, error messages are printed in case of errors.
X
X   If SECURE_FREE is defined, free() checks if the given address is really
X   one that was returned by malloc(), it ignores it if it wasn't (printing
X   an error message if MEM_WARNING is also defined).
X*/
X#if !defined(__hpux) && !defined(DGUX)
X#if defined(_BSD) && !defined(SYSV)
X
Xextern int brk DCLPROTO((caddr_t));
Xextern caddr_t sbrk DCLPROTO((int));
X
X#else
X
Xextern int brk DCLPROTO((void *));
Xextern void *sbrk DCLPROTO((int));
X
X#endif
X#endif
X
X#if defined(_BSD) && !defined(HAS_STDLIB)
X
X#define FREE_RET_T int
X#define FREE_ARG_T char *
X#define FREE_DO_RET
X#define MALLOC_RET_T char *
X#define MALLOC_ARG_T size_t
X
X#else
X
X#define FREE_RET_T void
X#define FREE_ARG_T void *
X#define MALLOC_RET_T void *
X#define MALLOC_ARG_T size_t
X
X#endif
X
Xstruct m_shdr {
X    struct m_shdr *next;
X};
X
Xstruct m_hdr {
X    long len;
X    struct m_hdr *next;
X    struct m_shdr *free;
X    long used;
X};
X
X#define M_ALIGN (sizeof(long))
X
X#define M_HSIZE (sizeof(struct m_hdr))
X#define M_ISIZE (sizeof(long))
X#define M_MIN   (2 * M_ISIZE)
X
Xstruct m_hdr *m_lfree, *m_free;
Xlong m_pgsz = 0;
Xchar *m_high, *m_low;
X
X#define M_SIDX(S)  ((S) / M_ISIZE)
X#define M_SNUM     50
X#define M_SLEN(M)  ((M)->len / M_SNUM)
X#define M_SBLEN(S) ((S) * M_SNUM + sizeof(struct m_shdr *) +  \
X		    sizeof(long) + sizeof(struct m_hdr *))
X#define M_BSLEN(S) (((S) - sizeof(struct m_shdr *) -  \
X		     sizeof(long) - sizeof(struct m_hdr *)) / M_SNUM)
X#define M_NSMALL 8
X
Xstruct m_hdr *m_small[M_NSMALL];
X
X#ifdef MEM_DEBUG
X
Xint m_s = 0, m_b = 0;
Xint m_m[1025], m_f[1025];
X
Xstruct m_hdr *m_l;
X
X#endif
X
XMALLOC_RET_T malloc(size)
XMALLOC_ARG_T size;
X{
X    struct m_hdr *m, *mp, *mt;
X    long n, s, os;
X    struct heap *h, *hp, *hf = NULL, *hfp;
X
X    if (!size)
X	return (MALLOC_RET_T) m_high;
X
X    if (!m_pgsz) {
X#ifdef __hpux
X	extern long sysconf DCLPROTO((int));
X
X	m_pgsz = sysconf(_SC_PAGE_SIZE);
X#else
X#ifdef SYSV
X	extern long sysconf DCLPROTO((int));
X
X	m_pgsz = sysconf(_SC_PAGESIZE);
X#else
X	extern int getpagesize DCLPROTO((void));
X
X	m_pgsz = getpagesize();
X#endif
X#endif
X	m_free = m_lfree = NULL;
X    }
X    size = (size + M_ALIGN - 1) & ~(M_ALIGN - 1);
X
X    if ((s = M_SIDX(size)) && s < M_NSMALL) {
X	for (mp = NULL, m = m_small[s]; m && !m->free; mp = m, m = m->next);
X
X	if (m) {
X	    struct m_shdr *sh = m->free;
X
X	    m->free = sh->next;
X	    m->used++;
X
X	    if (m->used == M_SNUM && m->next) {
X		for (mt = m; mt->next; mt = mt->next);
X
X		mt->next = m;
X		if (mp)
X		    mp->next = m->next;
X		else
X		    m_small[s] = m->next;
X		m->next = NULL;
X	    }
X#ifdef MEM_DEBUG
X	    m_m[size / M_ISIZE]++;
X#endif
X
X	    return (MALLOC_RET_T) sh;
X	}
X	os = size;
X	size = M_SBLEN(size);
X    } else
X	s = 0;
X
X    for (mp = NULL, m = m_free; m && m->len < size; mp = m, m = m->next);
X
X /* If there is an empty zsh heap at a lower address we steel it and take
X       the memory from it, putting the rest on the free list. */
X
X    for (hp = NULL, h = heaps; h; hp = h, h = h->next)
X	if (h->pos.ptr == h->arena &&
X	    (!hf || h < hf) &&
X	    (!m || ((char *)m) > ((char *)h)))
X	    hf = h, hfp = hp;
X
X    if (hf) {
X	struct heappos *hpo, *hpn;
X
X	for (hpo = hf->pos.next; hpo; hpo = hpn) {
X	    hpn = hpo->next;
X	    zfree(hpo, sizeof(struct heappos));
X	}
X	if (hfp)
X	    hfp->next = hf->next;
X	else
X	    heaps = hf->next;
X	zfree(hf->arena, HEAPSIZE);
X	zfree(hf, sizeof(struct heap));
X
X	for (mp = NULL, m = m_free; m && m->len < size; mp = m, m = m->next);
X    }
X    if (!m) {
X	n = (size + M_HSIZE + m_pgsz - 1) & ~(m_pgsz - 1);
X
X	if (((char *)(m = (struct m_hdr *)sbrk(n))) == ((char *)-1)) {
X#ifdef MEM_WARNING
X	    zerr("allocation error at sbrk: %e", NULL, 0);
X#endif
X	    return NULL;
X	}
X	if (!m_low)
X	    m_low = (char *)m;
X
X#ifdef MEM_DEBUG
X	m_s += n;
X
X	if (!m_l)
X	    m_l = m;
X#endif
X
X	m_high = ((char *)m) + n;
X
X	m->len = n - M_ISIZE;
X	m->next = NULL;
X
X	if (mp = m_lfree)
X	    m_lfree->next = m;
X	m_lfree = m;
X    }
X    if ((n = m->len - size) > M_MIN) {
X	struct m_hdr *mtt = (struct m_hdr *)(((char *)m) + M_ISIZE + size);
X
X	mtt->len = n - M_ISIZE;
X	mtt->next = m->next;
X
X	m->len = size;
X
X	if (m_lfree == m)
X	    m_lfree = mtt;
X
X	if (mp)
X	    mp->next = mtt;
X	else
X	    m_free = mtt;
X    } else if (mp) {
X	if (m == m_lfree)
X	    m_lfree = mp;
X	mp->next = m->next;
X    } else {
X	m_free = m->next;
X	if (m == m_lfree)
X	    m_lfree = m_free;
X    }
X
X    if (s) {
X	struct m_shdr *sh, *shn;
X
X	m->free = sh = (struct m_shdr *)(((char *)m) +
X					 sizeof(struct m_hdr) + os);
X
X	m->used = 1;
X
X	for (n = M_SNUM - 2; n--; sh = shn)
X	    shn = sh->next = sh + s;
X	sh->next = NULL;
X
X	m->next = m_small[s];
X	m_small[s] = m;
X
X#ifdef MEM_DEBUG
X	m_m[os / M_ISIZE]++;
X#endif
X
X	return (MALLOC_RET_T) (((char *)m) + sizeof(struct m_hdr));
X    }
X#ifdef MEM_DEBUG
X    m_m[m->len < (1024 * M_ISIZE) ? (m->len / M_ISIZE) : 1024]++;
X#endif
X
X    return (MALLOC_RET_T) & m->next;
X}
X
Xvoid zfree(p, sz)		/**/
Xvptr p;
Xint sz;
X{
X    struct m_hdr *m = (struct m_hdr *)(((char *)p) - M_ISIZE), *mp, *mt;
X    int i;
X
X#ifdef SECURE_FREE
X    sz = 0;
X#else
X    sz = (sz + M_ALIGN - 1) & ~(M_ALIGN - 1);
X#endif
X
X    if (!p)
X	return;
X
X    if (((char *)p) < m_low || ((char *)p) > m_high ||
X	((long)p) & (M_ALIGN - 1)) {
X
X#ifdef MEM_WARNING
X	zerr("attempt to free storage at invalid address", NULL, 0);
X#endif
X
X	return;
X    }
X  fr_rec:
X
X    if ((i = sz / M_ISIZE) < M_NSMALL || !sz)
X	for (; i < M_NSMALL; i++) {
X	    for (mp = NULL, mt = m_small[i];
X		 mt && (((char *)mt) > ((char *)p) ||
X			(((char *)mt) + mt->len) < ((char *)p));
X		 mp = mt, mt = mt->next);
X
X	    if (mt) {
X		struct m_shdr *sh = (struct m_shdr *)p, *sh2;
X
X#ifdef SECURE_FREE
X		if ((((char *)p) - (((char *)mt) + sizeof(struct m_hdr))) %
X		    M_BSLEN(mt->len)) {
X
X#ifdef MEM_WARNING
X		    zerr("attempt to free storage at invalid address", NULL, 0);
X#endif
X		    return;
X		}
X		for (sh2 = mt->free; sh2; sh2 = sh2->next)
X		    if (((char *)p) == ((char *)sh2)) {
X
X#ifdef MEM_WARNING
X			zerr("attempt to free already free storage", NULL, 0);
X#endif
X			return;
X		    }
X#endif
X
X		sh->next = mt->free;
X		mt->free = sh;
X
X#ifdef MEM_DEBUG
X		m_f[M_BSLEN(mt->len) / M_ISIZE]++;
X#endif
X
X		if (--mt->used) {
X		    if (mp) {
X			mp->next = mt->next;
X			mt->next = m_small[i];
X			m_small[i] = mt;
X		    }
X		    return;
X		}
X		if (mp)
X		    mp->next = mt->next;
X		else
X		    m_small[i] = mt->next;
X
X		m = mt;
X		p = (vptr) & m->next;
X
X		break;
X	    } else if (sz) {
X		sz = 0;
X		goto fr_rec;
X	    }
X	}
X#ifdef MEM_DEBUG
X    if (!mt)
X	m_f[m->len < (1024 * M_ISIZE) ? (m->len / M_ISIZE) : 1024]++;
X#endif
X
X#ifdef SECURE_FREE
X    for (mt = (struct m_hdr *)m_low;
X	 ((char *)mt) < m_high;
X	 mt = (struct m_hdr *)(((char *)mt) + M_ISIZE + mt->len))
X	if (((char *)p) == ((char *)&mt->next))
X	    break;
X
X    if (((char *)mt) >= m_high) {
X
X#ifdef MEM_WARNING
X	zerr("attempt to free storage at invalid address", NULL, 0);
X#endif
X	return;
X    }
X#endif
X
X    for (mp = NULL, mt = m_free; mt && mt < m; mp = mt, mt = mt->next);
X
X    if (m == mt) {
X
X#ifdef MEM_WARNING
X	zerr("attempt to free already free storage", NULL, 0);
X#endif
X	return;
X    }
X    if (mt && ((char *)mt) == (((char *)m) + M_ISIZE + m->len)) {
X	m->len += mt->len + M_ISIZE;
X	m->next = mt->next;
X
X	if (mt == m_lfree)
X	    m_lfree = m;
X    } else
X	m->next = mt;
X
X    if (mp && ((char *)m) == (((char *)mp) + M_ISIZE + mp->len)) {
X	mp->len += m->len + M_ISIZE;
X	mp->next = m->next;
X
X	if (m == m_lfree)
X	    m_lfree = mp;
X    } else if (mp)
X	mp->next = m;
X    else
X	m_free = m;
X
X    if ((((char *)m_lfree) + M_ISIZE + m_lfree->len) == m_high &&
X	m_lfree->len >= m_pgsz + M_MIN) {
X	long n = (m_lfree->len - M_MIN) & ~(m_pgsz - 1);
X
X	m_lfree->len -= n;
X	if (brk(m_high -= n) == -1) {
X#ifdef MEM_WARNING
X	    zerr("allocation error at brk: %e", NULL, 0);
X#endif
X	}
X#ifdef MEM_DEBUG
X	m_b += n;
X#endif
X    }
X}
X
XFREE_RET_T free(p)
XFREE_ARG_T p;
X{
X    zfree(p, 0);
X
X#ifdef FREE_DO_RET
X    return 0;
X#endif
X}
X
Xvoid zsfree(p)			/**/
Xchar *p;
X{
X    if (p)
X	zfree(p, strlen(p) + 1);
X}
X
XMALLOC_RET_T realloc(p, size)
XMALLOC_RET_T p;
XMALLOC_ARG_T size;
X{
X    struct m_hdr *m = (struct m_hdr *)(((char *)p) - M_ISIZE), *mp, *mt;
X    char *r;
X    int i, l = 0;
X
X    if (!p && size)
X	return (MALLOC_RET_T) malloc(size);
X    if (!p || !size)
X	return (MALLOC_RET_T) p;
X
X    for (i = 0; i < M_NSMALL; i++) {
X	for (mp = NULL, mt = m_small[i];
X	     mt && (((char *)mt) > ((char *)p) ||
X		    (((char *)mt) + mt->len) < ((char *)p));
X	     mp = mt, mt = mt->next);
X
X	if (mt) {
X	    l = M_BSLEN(mt->len);
X	    break;
X	}
X    }
X    if (!l)
X	l = m->len;
X
X    r = malloc(size);
X    memcpy(r, (char *)p, (size > l) ? l : size);
X    free(p);
X
X    return (MALLOC_RET_T) r;
X}
X
XMALLOC_RET_T calloc(n, size)
XMALLOC_ARG_T n;
XMALLOC_ARG_T size;
X{
X    long l;
X    char *r;
X
X    if (!(l = n * size))
X	return (MALLOC_RET_T) m_high;
X
X    r = malloc(l);
X
X    memset(r, 0, l);
X
X    return (MALLOC_RET_T) r;
X}
X
XFREE_RET_T cfree(p)
XFREE_ARG_T p;
X{
X    free(p);
X
X#ifdef FREE_DO_RET
X    return 0;
X#endif
X}
X
X#ifdef MEM_DEBUG
X
Xint bin_mem(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    int i, ii, fi, ui, j;
X    struct m_hdr *m, *mf, *ms;
X    char *b, *c, buf[40];
X    long u = 0, f = 0;
X    Lknode nd;
X
X    if (ops['v']) {
X	printf("The lower and the upper addresses of the heap. Diff gives\n");
X	printf("the difference between them, i.e. the size of the heap.\n\n");
X    }
X    printf("low mem %ld\t high mem %ld\t diff %ld\n",
X	   (long)m_l, (long)m_high, (long)(m_high - ((char *)m_l)));
X
X    if (ops['v']) {
X	printf("\nThe number of bytes that were allocated using sbrk() and\n");
X	printf("the number of bytes that were given back to the system\n");
X	printf("via brk().\n");
X    }
X    printf("\nsbrk %d\tbrk %d\n", m_s, m_b);
X
X    if (ops['v']) {
X	printf("\nInformation about the sizes that were allocated or freed.\n");
X	printf("For each size that were used the number of mallocs and\n");
X	printf("frees is shown. Diff gives the difference between these\n");
X	printf("values, i.e. the number of blocks of that size that is\n");
X	printf("currently allocated. Total is the product of size and diff,\n");
X	printf("i.e. the number of bytes that are allocated for blocks of\n");
X	printf("this size.\n");
X    }
X    printf("\nsize\tmalloc\tfree\tdiff\ttotal\n");
X    for (i = 0; i < 1024; i++)
X	if (m_m[i] || m_f[i])
X	    printf("%d\t%d\t%d\t%d\t%d\n", i * M_ISIZE, m_m[i], m_f[i],
X		   m_m[i] - m_f[i], i * M_ISIZE * (m_m[i] - m_f[i]));
X
X    if (m_m[i] || m_f[i])
X	printf("big\t%d\t%d\t%d\n", m_m[i], m_f[i], m_m[i] - m_f[i]);
X
X    if (ops['v']) {
X	printf("\nThe list of memory blocks. For each block the following\n");
X	printf("information is shown:\n\n");
X	printf("num\tthe number of this block\n");
X	printf("tnum\tlike num but counted separatedly for used and free\n");
X	printf("\tblocks\n");
X	printf("addr\tthe address of this block\n");
X	printf("len\tthe length of the block\n");
X	printf("state\tthe state of this block, this can be:\n");
X	printf("\t  used\tthis block is used for one big block\n");
X	printf("\t  free\tthis block is free\n");
X	printf("\t  small\tthis block is used for an array of small blocks\n");
X	printf("cum\tthe accumulated sizes of the blocks, counted\n");
X	printf("\tseparatedly for used and free blocks\n");
X	printf("\nFor blocks holding small blocks the number of free\n");
X	printf("blocks, the number of used blocks and the size of the\n");
X	printf("blocks is shown. For otherwise used blocks the first few\n");
X	printf("bytes are shown as an ASCII dump.\n");
X    }
X    printf("\nblock list:\nnum\ttnum\taddr\tlen\tstate\tcum\n");
X    for (m = m_l, mf = m_free, ii = fi = ui = 1; ((char *)m) < m_high;
X	 m = (struct m_hdr *)(((char *)m) + M_ISIZE + m->len), ii++) {
X	for (j = 0, ms = NULL; j < M_NSMALL && !ms; j++)
X	    for (ms = m_small[j]; ms; ms = ms->next)
X		if (ms == m)
X		    break;
X
X	if (m == mf)
X	    buf[0] = '\0';
X	else if (m == ms)
X	    sprintf(buf, "%d %d %d", M_SNUM - ms->used, ms->used,
X		    (m->len - sizeof(struct m_hdr)) / M_SNUM + 1);
X
X	else {
X	    for (i = 0, b = buf, c = (char *)&m->next; i < 20 && i < m->len;
X		 i++, c++)
X		*b++ = (*c >= ' ' && *c < 127) ? *c : '.';
X	    *b = '\0';
X	}
X
X	printf("%d\t%d\t%ld\t%ld\t%s\t%ld\t%s\n", ii,
X	       (m == mf) ? fi++ : ui++,
X	       (long)m, m->len,
X	       (m == mf) ? "free" : ((m == ms) ? "small" : "used"),
X	       (m == mf) ? (f += m->len) : (u += m->len),
X	       buf);
X
X	if (m == mf)
X	    mf = mf->next;
X    }
X
X    if (ops['v']) {
X	printf("\nHere is some information about the small blocks used.\n");
X	printf("For each size the arrays with the number of free and the\n");
X	printf("number of used blocks are shown.\n");
X    }
X    printf("\nsmall blocks:\nsize\tblocks (free/used)\n");
X
X    for (i = 0; i < M_NSMALL; i++)
X	if (m_small[i]) {
X	    printf("%d\t", i * M_ISIZE);
X
X	    for (ii = 0, m = m_small[i]; m; m = m->next) {
X		printf("(%d/%d) ", M_SNUM - m->used, m->used);
X		if (!((++ii) & 7))
X		    printf("\n\t");
X	    }
X	    putchar('\n');
X	}
X    if (ops['v']) {
X	printf("\n\nBelow is some information about the allocation\n");
X	printf("behaviour of the zsh heaps. First the number of times\n");
X	printf("pushheap(), popheap(), and freeheap() were called.\n");
X    }
X    printf("\nzsh heaps:\n\n");
X
X    printf("push %d\tpop %d\tfree %d\n\n", h_push, h_pop, h_free);
X
X    if (ops['v']) {
X	printf("\nThe next list shows for several sizes the number of times\n");
X	printf("memory of this size were taken from heaps.\n\n");
X    }
X    printf("size\tmalloc\ttotal\n");
X    for (i = 0; i < 1024; i++)
X	if (h_m[i])
X	    printf("%d\t%d\t%d\n", i * H_ISIZE, h_m[i], i * H_ISIZE * h_m[i]);
X    if (h_m[1024])
X	printf("big\t%d\n", h_m[1024]);
X
X    return 0;
X}
X
X#endif
X
X#else				/* not USE_ZSH_MALLOC */
X
Xvoid zfree(p, sz)		/**/
Xvptr p;
Xint sz;
X{
X    if (p)
X	free(p);
X}
X
Xvoid zsfree(p)			/**/
Xchar *p;
X{
X    if (p)
X	free(p);
X}
X
X#endif
END_OF_FILE
  if test 21990 -ne `wc -c <'zsh-2.5.0/src/mem.c'`; then
    echo shar: \"'zsh-2.5.0/src/mem.c'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/src/mem.c'
fi
echo shar: End of archive 9 \(of 18\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
