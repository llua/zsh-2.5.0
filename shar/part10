Path: news.csc.fi!news.eunet.fi!EU.net!uunet!sparky!not-for-mail
From: zsh-list@sterling.com (Bas de Bakker)
Newsgroups: comp.sources.misc
Subject: v43i099:  zsh - The Z shell, version 2.5.0, Part10/18
Followup-To: comp.sources.d
Date: 13 Jul 1994 23:05:33 -0500
Organization: Sterling Software
Lines: 4083
Sender: kent@sparky.sterling.com
Approved: kent@sparky.sterling.com
Message-ID: <302did$t64@sparky.sterling.com>
References: <csm-v43i089=zsh.230017@sparky.sterling.com>
NNTP-Posting-Host: sparky.sterling.com
X-Md4-Signature: ca7385b312344adf1f0e3c740dac08e3

Submitted-by: zsh-list@sterling.com (Bas de Bakker)
Posting-number: Volume 43, Issue 99
Archive-name: zsh/part10
Environment: UNIX
Supersedes: zsh: Volume 35, Issue 51-72

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  zsh-2.5.0/src/builtin.c.B zsh-2.5.0/src/subst.c
#   zsh-2.5.0/src/ztype.h
# Wrapped by kent@sparky on Tue Jul 12 16:47:22 1994
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 10 (of 18)."'
if test -f 'zsh-2.5.0/src/builtin.c.B' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/src/builtin.c.B'\"
else
  echo shar: Extracting \"'zsh-2.5.0/src/builtin.c.B'\" \(50522 characters\)
  sed "s/^X//" >'zsh-2.5.0/src/builtin.c.B' <<'END_OF_FILE'
X	    if (fd == 10)
X		fd = 0;
X	} else
X	    fd = coprocout;
X	if ((fd = dup(fd)) < 0) {
X	    zwarnnam(name, "bad file number", NULL, 0);
X	    return 1;
X	}
X	if ((fout = fdopen(fd, "w")) == 0) {
X	    zwarnnam(name, "bad mode on fd", NULL, 0);
X	    return 1;
X	}
X    }
X    if (ops['o']) {
X	if (ops['i'])
X	    qsort(args, arrlen(args), sizeof(char *), cstrpcmp);
X
X	else
X	    qsort(args, arrlen(args), sizeof(char *), strpcmp);
X    } else if (ops['O']) {
X	if (ops['i'])
X	    qsort(args, arrlen(args), sizeof(char *), invcstrpcmp);
X
X	else
X	    qsort(args, arrlen(args), sizeof(char *), invstrpcmp);
X    }
X    if (ops['c']) {
X	int l, nc, nr, sc, n, t, i;
X	char **ap;
X
X	for (n = l = 0, ap = args; *ap; ap++, n++)
X	    if (l < (t = strlen(*ap)))
X		l = t;
X
X	nc = (columns - 1) / (l + 2);
X	sc = 0;
X	if (nc)
X	    sc = (columns - 1) / nc;
X	else
X	    nc = 1;
X	nr = (n + nc - 1) / nc;
X
X	for (i = 0; i < nr; i++) {
X	    ap = args + i;
X	    do {
X		l = strlen(*ap);
X		fprintf(fout, "%s", *ap);
X		for (; l < sc; l++)
X		    fputc(' ', fout);
X		for (t = nr; t && *ap; t--, ap++);
X	    }
X	    while (*ap);
X	    fputc(ops['N'] ? '\0' : '\n', fout);
X	}
X	if (fout != stdout)
X	    fclose(fout);
X	return 0;
X    }
X    for (; *args; args++) {
X	char *arg = *args;
X	int len = -1;
X
X	if (!ops['r'])
X	    arg = getkeystring(arg, &len, func != BIN_ECHO, &nnl);
X	if (ops['D'])
X	    fprintdir(arg, fout);
X	else {
X	    if (ops['P'])
X		arg = putprompt(arg, &len, -1);
X	    fwrite(arg, 1, len == -1 ? strlen(arg) : len, fout);
X	}
X
X	if (args[1])
X	    fputc(ops['l'] ? '\n' : ops['0'] ? '\0' : ' ', fout);
X    }
X    if (!(ops['n'] || nnl))
X	fputc(ops['N'] ? '\0' : '\n', fout);
X    if (fout != stdout)
X	fclose(fout);
X    return 0;
X}
X
Xint bin_dirs(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    Lklist l;
X
X    if (ops['v']) {
X	Lknode node;
X	int t0 = 1;
X
X	printf("0\t");
X	printdir(pwd);
X	for (node = firstnode(dirstack); node; incnode(node)) {
X	    printf("\n%d\t", t0++);
X	    printdir(getdata(node));
X	}
X	putchar('\n');
X	return 0;
X    }
X    if (!*argv) {
X	pdstack();
X	return 0;
X    }
X    permalloc();
X    l = newlist();
X    if (!*argv) {
X	heapalloc();
X	return 0;
X    }
X    while (*argv)
X	addnode(l, ztrdup(*argv++));
X    freetable(dirstack, freestr);
X    dirstack = l;
X    heapalloc();
X    return 0;
X}
X
Xint bin_unalias(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    int ret = 0;
X    Alias dat;
X
X    while (*argv)
X	if (ops['m']) {
X	    int n, i, match = 0;
X	    Alias a;
X	    Comp com;
X
X	    tokenize(*argv++);
X	    if (!(com = parsereg(argv[-1]))) {
X		ret = 1;
X		untokenize(argv[-1]);
X		zwarnnam(name, "bad pattern : %s", argv[-1], 0);
X		continue;
X	    }
X	    n = aliastab->hsize;
X	    for (i = 0; i < n; i++) {
X		for (a = (Alias) aliastab->nodes[i]; a; a = dat) {
X		    dat = (Alias) a->next;
X		    if (a->nam && a->cmd >= 0 && domatch(a->nam, com, 0))
X			freeanode(remhnode(a->nam, aliastab)), match++;
X		}
X	    }
X	    if (!ret)
X		ret = !match;
X	} else {
X	    if ((dat = (Alias) gethnode(*argv++, aliastab)) && dat->cmd >= 0)
X		freeanode(remhnode(dat->nam, aliastab));
X	    else
X		ret = 1;
X	}
X    return ret;
X}
X
Xint bin_disable(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    Cmdnam chn, chn2, nchn;
X    Comp com;
X
X    if (!*argv) {
X	listhtable(cmdnamtab, (HFunc) pdisabledcmd);
X	return 0;
X    }
X    if (ops['m']) {
X	for (; *argv; argv++) {
X	    tokenize(*argv);
X	    if (!(com = parsereg(*argv))) {
X		untokenize(*argv);
X		zwarnnam(name, "bad pattern : %s", *argv, 0);
X		continue;
X	    }
X	    if (!strncmp(*argv, "TRAP", 4)) {
X		char trapname[20];
X		int t;
X
X		strncpy(trapname, "TRAP", sizeof(trapname));
X		for (t = 0; t < VSIGCOUNT; t++) {
X		    strncpy(trapname + 4, sigs[t], sizeof(trapname) - 5);
X		    if (domatch(trapname, com, 0)) {
X			unsettrap(t);
X			chn = (Cmdnam) zcalloc(sizeof *chn);
X			chn->flags |= DISABLED;
X			addhnode(ztrdup(trapname), chn, cmdnamtab, freecmdnam);
X		    }
X		}
X	    } else {
X		int t, n;
X
X		n = cmdnamtab->hsize;
X		for (t = 0; t < n; t++)
X		    for (chn = (Cmdnam) cmdnamtab->nodes[t]; chn; chn = nchn) {
X			nchn = (Cmdnam) chn->next;
X			if (domatch(chn->nam, com, 0)) {
X			    chn2 = (Cmdnam) zcalloc(sizeof *chn2);
X			    chn2->flags |= DISABLED;
X			    addhnode(ztrdup(chn->nam), chn2, cmdnamtab,
X				     freecmdnam);
X			}
X		    }
X	    }
X	}
X    } else {
X	char **p, buf[MAXPATHLEN];
X
X	while (*argv) {
X	    if (!strncmp(*argv, "TRAP", 4))
X		unsettrap(getsignum(*argv + 4));
X	    chn = (Cmdnam) zcalloc(sizeof *chn);
X	    for (p = path; *p; p++) {
X		strcpy(buf, *path);
X		strcat(buf, "/");
X		strcat(buf, *argv);
X		if (iscom(buf)) {
X		    chn->u.name = path;
X		    break;
X		}
X	    }
X	    chn->flags |= *p ? EXCMD : DISABLED;
X	    addhnode(ztrdup(*argv++), chn, cmdnamtab, freecmdnam);
X	}
X    }
X    return 0;
X}
X
Xint bin_unhash(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    vptr dat;
X    Comp com;
X
X    if (ops['m']) {
X	for (; *argv; argv++) {
X	    tokenize(*argv);
X	    if (!(com = parsereg(*argv))) {
X		untokenize(*argv);
X		zwarnnam(name, "bad pattern : %s", *argv, 0);
X		continue;
X	    }
X	    if (!strncmp(*argv, "TRAP", 4)) {
X		char trapname[20];
X		int t;
X
X		strncpy(trapname, "TRAP", sizeof(trapname));
X		for (t = 0; t < VSIGCOUNT; t++) {
X		    strncpy(trapname + 4, sigs[t], sizeof(trapname) - 5);
X		    if (domatch(trapname, com, 0))
X			unsettrap(t);
X		}
X	    } else {
X		Cmdnam chn, nchn;
X		int t, n;
X
X		n = cmdnamtab->hsize;
X		for (t = 0; t < n; t++)
X		    for (chn = (Cmdnam) cmdnamtab->nodes[t]; chn; chn = nchn) {
X			nchn = (Cmdnam) chn->next;
X			if (domatch(chn->nam, com, 0))
X			    freecmdnam(remhnode(chn->nam, cmdnamtab));
X		    }
X	    }
X	}
X    } else {
X	while (*argv) {
X	    if (!strncmp(*argv, "TRAP", 4))
X		unsettrap(getsignum(*argv + 4));
X	    if ((dat = remhnode(*argv++, cmdnamtab)))
X		freecmdnam(dat);
X	}
X    }
X    return 0;
X}
X
Xint bin_unset(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    int retval = 0;
X    char *s;
X
X    while ((s = *argv++))
X	if (ops['m']) {
X	    int i, n;
X	    Comp com;
X	    struct param *par, *next;
X
X	    tokenize(s);
X	    if (!(com = parsereg(s))) {
X		retval = 1;
X		untokenize(s);
X		zwarnnam(name, "bad pattern : %s", s, 0);
X		continue;
X	    }
X	    n = paramtab->hsize;
X	    for (i = 0; i < n; i++)
X		for (par = (struct param *)paramtab->nodes[i]; par;
X		     par = next) {
X		    next = (struct param *)par->next;
X		    if (domatch(par->nam, com, 0))
X			unsetparam(par->nam);
X		}
X	} else {
X	    if (gethnode(s, paramtab))
X		unsetparam(s);
X	    else
X		retval = 1;
X	}
X    return retval;
X}
X
Xstatic char *zbuf;
Xstatic int readfd;
X
Xint zread()
X{				/**/
X    char cc;
X
X    if (zbuf)
X	return (*zbuf) ? *zbuf++ : EOF;
X    if (read(readfd, &cc, 1) != 1)
X	return EOF;
X    return (int)cc;
X}
X
Xextern int cs;
X
Xint bin_read(name, args, ops, func)	/**/
Xchar *name;
Xchar **args;
Xchar *ops;
Xint func;
X{
X    char *reply = "REPLY", *readpmpt;
X    int bsiz, c = 0, gotnl = 0, al = 0;
X    char *buf, *bptr, *firstarg = *args, *zbuforig;
X    Lklist readll = newlist();
X
X    if (ops['k']) {
X	int nchars, val;
X	char cc, d;
X	int haso = 0, isem = !strcmp(term, "emacs");
X
X	if (SHTTY == -1) {
X	    SHTTY = open("/dev/tty", O_RDWR);
X	    haso = 1;
X	}
X	if (SHTTY == -1) {
X	    fprintf(stderr, "not interactive and can't open terminal\n");
X	    fflush(stderr);
X	    return 1;
X	}
X	if (*args && idigit(**args)) {
X	    if (!(nchars = atoi(*args)))
X		nchars = 1;
X	    args++;
X	} else
X	    nchars = 1;
X
X	if (*args && **args == '/') {
X	    fprintf(stderr, "%s", putprompt(*args + 1, &c, 0));
X	    fflush(stderr);
X	    args++;
X	}
X	if (*args)
X	    reply = *args++;
X
X	bptr = buf = (char *)zalloc(nchars + 1);
X	buf[nchars] = '\0';
X
X	attachtty(mypgrp);
X	if (!isem)
X	    setcbreak();
X
X	for (bptr = buf; nchars;) {
X#ifdef FIONREAD
X	    ioctl(SHTTY, FIONREAD, (char *)&val);
X	    if (val) {
X		if (!isem)
X		    settyinfo(&shttyinfo);
X		if (ops['e'] || ops['E']) {
X		    printf("%s\n", buf);
X		    if (ops['e'])
X			zsfree(buf);
X		}
X		if (!ops['e'])
X		    setsparam(reply, buf);
X
X		if (haso) {
X		    close(SHTTY);
X		    SHTTY = -1;
X		}
X		return 1;
X	    }
X#endif
X	    if (read(SHTTY, &cc, 1) == 1)
X		nchars--, *bptr++ = cc;
X	}
X	if (isem)
X	    while (read(SHTTY, &d, 1) == 1 && d != '\n');
X	else
X	    settyinfo(&shttyinfo);
X
X	if (haso) {
X	    close(SHTTY);
X	    SHTTY = -1;
X	}
X	if (ops['e'] || ops['E']) {
X	    printf("%s\n", buf);
X	    if (ops['e'])
X		zsfree(buf);
X	}
X	if (!ops['e'])
X	    setsparam(reply, buf);
X	return 0;
X    }
X    if (ops['l']) {
X	if (!inzlefunc) {
X	    zwarnnam(name, "option valid only in functions called from zle",
X		     NULL, 0);
X	    errflag = 0;
X	    return 1;
X	}
X	if (ops['n']) {
X	    char nbuf[14];
X
X	    if (ops['e'] || ops['E'])
X		printf("%d\n", cs + 1);
X	    if (!ops['e']) {
X		sprintf(nbuf, "%d", cs + 1);
X		setsparam(*args ? *args : "REPLY", ztrdup(nbuf));
X	    }
X	    return 0;
X	}
X	if (ops['e'] || ops['E'])
X	    printf("%s\n", (char *)line);
X	if (!ops['e'])
X	    setsparam(*args ? *args : "REPLY", ztrdup((char *)line));
X	return 0;
X    }
X    if (ops['c']) {
X	if (!inzlefunc) {
X	    zwarnnam(name, "option valid only in functions called from zle",
X		     NULL, 0);
X	    errflag = 0;
X	    return 1;
X	}
X	if (ops['n']) {
X	    char nbuf[14];
X
X	    if (ops['e'] || ops['E'])
X		printf("%d\n", clwpos + 1);
X	    if (!ops['e']) {
X		sprintf(nbuf, "%d", clwpos + 1);
X		setsparam(*args ? *args : "REPLY", ztrdup(nbuf));
X	    }
X	    return 0;
X	}
X	if (ops['A'] && !ops['e']) {
X	    char **p, **b = (char **)zcalloc((clwnum + 1) * sizeof(char *));
X	    int i;
X
X	    for (i = 0, p = b; i < clwnum; p++, i++)
X		*p = ztrdup(clwords[i]);
X
X	    setaparam(*args ? *args : "reply", b);
X	    return 0;
X	}
X	if (ops['e'] || ops['E']) {
X	    int i;
X
X	    for (i = 0; i < clwnum; i++)
X		printf("%s\n", clwords[i]);
X
X	    if (ops['e'])
X		return 0;
X	}
X	if (*args) {
X	    int i = 0;
X
X	    for (; i < clwnum && *args; args++, i++)
X		setsparam(*args, ztrdup(clwords[i]));
X	} else
X	    setsparam("REPLY", ztrdup(clwords[clwpos]));
X
X	return 0;
X    }
X    if (ops['q']) {
X	char *readbuf;
X	int haso = 0;
X
X	if (SHTTY == -1)
X	    SHTTY = open("/dev/tty", O_RDWR), haso = 1;
X
X	if (SHTTY == -1) {
X	    fprintf(stderr, "not interactive and can't open terminal\n");
X	    fflush(stderr);
X	    return 1;
X	}
X	readbuf = (char *)zalloc(2);
X	readbuf[1] = '\0';
X
X	if (*args && **args == '/') {
X	    fprintf(stderr, "%s", putprompt(*args + 1, &c, 0));
X	    fflush(stderr);
X	    args++;
X	}
X	reply = (*args) ? *args++ : "REPLY";
X
X	readbuf[0] = ((char)getquery()) == 'y' ? 'y' : 'n';
X
X	if (haso) {
X	    close(SHTTY);
X	    SHTTY = -1;
X	}
X	if (ops['e'] || ops['E']) {
X	    printf("%s\n", readbuf);
X	    if (ops['e'])
X		free(readbuf);
X	}
X	if (!ops['e'])
X	    setsparam(reply, readbuf);
X
X	return readbuf[0] == 'n';
X    }
X    if (*args && **args == '?')
X	args++;
X    reply = *args ? *args++ : ops['A'] ? "reply" : "REPLY";
X    if (ops['A'] && *args) {
X	zwarnnam(name, "only one array argument allowed", NULL, 0);
X	return 1;
X    }
X    if (ops['u'] && !ops['p']) {
X	for (readfd = 0; readfd < 10; ++readfd)
X	    if (ops[readfd + '0'])
X		break;
X	if (readfd == 10)
X	    readfd = 0;
X    } else if (ops['p'])
X	readfd = coprocin;
X    else {
X	attachtty((jobtab[thisjob].gleader) ? jobtab[thisjob].gleader : mypgrp);
X	readfd = 0;
X	if (firstarg) {
X	    for (readpmpt = firstarg;
X		 *readpmpt && *readpmpt != '?'; readpmpt++);
X	    if (*readpmpt++) {
X		if (isatty(0))
X		    write(2, readpmpt, strlen(readpmpt));
X		readpmpt[-1] = '\0';
X	    }
X	}
X#if 0
X	else if (isset(SHINSTDIN) && unset(INTERACTIVE)) {
X	    if (isatty(1))
X		readfd = 1;
X	    else if (isatty(2))
X		readfd = 2;
X	}
X#endif
X    }
X
X    zbuforig = zbuf = (!ops['z']) ? NULL :
X	(full(bufstack)) ? (char *)getnode(bufstack) : ztrdup("");
X    while (*args || (ops['A'] && !gotnl)) {
X	buf = bptr = (char *)zalloc(bsiz = 64);
X	for (;;) {
X	    if (gotnl)
X		break;
X	    c = zread();
X	    if (!ops['r'] && c == '\n' && bptr != buf && bptr[-1] == '\\') {
X		bptr--;
X		continue;
X	    }
X	    if (c == EOF || (isep(c) && bptr != buf) || c == '\n')
X		break;
X	    if (isep(c))
X		continue;
X	    *bptr++ = c;
X	    if (bptr == buf + bsiz) {
X		buf = realloc(buf, bsiz *= 2);
X		bptr = buf + (bsiz / 2);
X	    }
X	}
X	if (c == EOF) {
X	    if (readfd == coprocin) {
X		close(coprocin);
X		close(coprocout);
X		coprocin = coprocout = -1;
X	    }
X	    return 1;
X	}
X	if (c == '\n')
X	    gotnl = 1;
X	*bptr = '\0';
X	if (ops['e'] || ops['E']) {
X	    printf("%s\n", buf);
X	    if (ops['e'])
X		free(buf);
X	}
X	if (!ops['e']) {
X	    if (ops['A']) {
X		addnode(readll, buf);
X		al++;
X	    } else
X		setsparam(reply, buf);
X	}
X	if (!ops['A'])
X	    reply = *args++;
X    }
X    if (ops['A']) {
X	char **pp, **p = NULL;
X	Lknode n;
X
X	p = (ops['e'] ? (char **)NULL
X	     : (char **)zcalloc((al + 1) * sizeof(char *)));
X
X	for (pp = p, n = firstnode(readll); n; incnode(n)) {
X	    if (ops['e'] || ops['E']) {
X		printf("%s\n", (char *)getdata(n));
X		if (p)
X		    zsfree(getdata(n));
X	    } else
X		*pp++ = (char *)getdata(n);
X	}
X	if (p)
X	    setaparam(reply, p);
X	return 0;
X    }
X    buf = bptr = (char *)zalloc(bsiz = 64);
X    if (!gotnl)
X	for (;;) {
X	    c = zread();
X	    if (!ops['r'] && c == '\n' && bptr != buf && bptr[-1] == '\\') {
X		bptr--;
X		continue;
X	    }
X	    if (c == EOF || (c == '\n' && !zbuf))
X		break;
X	    if (isep(c) && bptr == buf)
X		continue;
X	    *bptr++ = c;
X	    if (bptr == buf + bsiz) {
X		buf = realloc(buf, bsiz *= 2);
X		bptr = buf + (bsiz / 2);
X	    }
X	}
X    while (bptr > buf && isep(bptr[-1]))
X	bptr--;
X    *bptr = '\0';
X    if (ops['e'] || ops['E']) {
X	printf("%s\n", buf);
X	if (ops['e'])
X	    zsfree(buf);
X    }
X    if (!ops['e'])
X	setsparam(reply, buf);
X    if (zbuforig) {
X	char first = *zbuforig;
X
X	zsfree(zbuforig);
X	if (!first)
X	    return 1;
X    } else if (c == EOF) {
X	if (readfd == coprocin) {
X	    close(coprocin);
X	    close(coprocout);
X	    coprocin = coprocout = -1;
X	}
X	return 1;
X    }
X    return 0;
X}
X
Xint bin_vared(name, args, ops, func)	/**/
Xchar *name;
Xchar **args;
Xchar *ops;
Xint func;
X{
X    char *s;
X    char *t;
X    struct param *pm;
X    int create = 0, pl1, pl2;
X    char *p1 = NULL, *p2 = NULL;
X
X    while (*args && **args == '-') {
X	while (*++(*args))
X	    switch (**args) {
X	    case 'c':
X		create = 1;
X		break;
X	    case 'p':
X		if ((*args)[1])
X		    p1 = *args + 1, *args = "" - 1;
X		else if (args[1])
X		    p1 = *(++args), *args = "" - 1;
X		else {
X		    zwarnnam(name, "prompt string expected after -p", NULL, 0);
X		    return 1;
X		}
X		break;
X	    case 'r':
X		if ((*args)[1])
X		    p2 = *args + 1, *args = "" - 1;
X		else if (args[1])
X		    p2 = *(++args), *args = "" - 1;
X		else {
X		    zwarnnam(name, "prompt string expected after -r", NULL, 0);
X		    return 1;
X		}
X		break;
X	    default:
X		zwarnnam(name, "unknown option: %s", *args, 0);
X		return 1;
X	    }
X	args++;
X    }
X
X    if (!*args) {
X	zwarnnam(name, "missing variable", NULL, 0);
X	return 1;
X    }
X    if (!(s = getsparam(args[0]))) {
X	if (create)
X	    createparam(args[0], PMFLAG_s);
X	else {
X	    zwarnnam(name, "no such variable: %s", args[0], 0);
X	    return 1;
X	}
X    }
X    permalloc();
X    pushnode(bufstack, ztrdup(s));
X    heapalloc();
X    if (p1)
X	p1 = putprompt(p1, &pl1, 0);
X    else
X	pl1 = 0;
X    if (p2)
X	p2 = putprompt(p2, &pl2, 0);
X    else
X	pl2 = 0;
X    t = (char *)zleread((unsigned char *)p1, (unsigned char *)p2, pl1, pl2);
X    if (!t || errflag)
X	return 1;
X    if (t[strlen(t) - 1] == '\n')
X	t[strlen(t) - 1] = '\0';
X    pm = (struct param *)gethnode(args[0], paramtab);
X    if (pmtype(pm) == PMFLAG_A)
X	setaparam(args[0], spacesplit(t));
X    else
X	setsparam(args[0], t);
X    return 0;
X}
X
X#define fset(X) (flags & X)
X
X/* execute a builtin handler function after parsing the arguments */
X
Xint execbin(args, cnode)	/**/
XLklist args;
XCmdnam cnode;
X{
X    struct bincmd *b;
X    char ops[128], *arg, *pp, *name, **argv, **oargv, *optstr;
X    int t0, flags, sense, argc = 0, execop;
X    Lknode n;
X    char *oxarg, *xarg = NULL;
X
X    auxdata = NULL;
X    auxlen = 0;
X    for (t0 = 0; t0 != 128; t0++)
X	ops[t0] = 0;
X    name = (char *)ugetnode(args);
X    b = builtins + cnode->u.binnum;
X
X/* the 'builtin' builtin is handled specially */
X
X    if (b->funcid == BIN_BUILTIN) {
X	Cmdnam cname;
X
X	if (!(name = (char *)ugetnode(args))) {
X	    zerrnam("builtin", "command name expected", NULL, 0);
X	    return 1;
X	}
X	if ((cname = (Cmdnam) gethnode(name, cmdnamtab)) &&
X	    (cname->flags & BUILTIN) &&
X	    !(cname->flags & EXCMD))
X	    b = builtins + cname->u.binnum;
X	else
X	    for (b = builtins; b->name; b++)
X		if (!strcmp(name, b->name))
X		    break;
X	if (!b->name) {
X	    zerrnam("builtin", "no such builtin: %s", name, 0);
X	    return 1;
X	}
X    }
X    flags = b->flags;
X    arg = (char *)ugetnode(args);
X    optstr = b->optstr;
X    if (flags & BINF_ECHOPTS && arg && strcmp(arg, "-n"))
X	optstr = NULL;
X    if (optstr)
X	while (arg &&
X	       ((sense = *arg == '-') || (fset(BINF_PLUSOPTS) && *arg == '+')) &&
X	       (fset(BINF_PLUSOPTS) || !atoi(arg))) {
X	    if (xarg) {
X		oxarg = tricat(xarg, " ", arg);
X		zsfree(xarg);
X		xarg = oxarg;
X	    } else
X		xarg = ztrdup(arg);
X	    if (arg[1] == '-')
X		arg++;
X	    if (!arg[1]) {
X		ops['-'] = 1;
X		if (!sense)
X		    ops['+'] = 1;
X	    } else
X		ops['@'] = 1;
X	    execop = -1;
X	    while (*++arg)
X		if (strchr(b->optstr, execop = (int)*arg))
X		    ops[(int)*arg] = (sense) ? 1 : 2;
X		else
X		    break;
X	    if (*arg) {
X		zerr("bad option: %c", NULL, *arg);
X		zsfree(xarg);
X		return 1;
X	    }
X	    arg = (char *)ugetnode(args);
X	    if (fset(BINF_SETOPTS) && execop == 'o') {
X		int c;
X
X		if (!arg)
X		    prtopt(sense);
X		else {
X		    c = optlookup(arg);
X		    if (c == -1) {
X			zerr("bad option: %s", arg, 0);
X			zsfree(xarg);
X			return 1;
X		    } else {
X			if (c == INTERACTIVE)
X			    zerr("can't change option: %s", arg, 0);
X			else
X			    ops[c] = ops['o'];
X			arg = (char *)ugetnode(args);
X		    }
X		}
X	    }
X	    if ((fset(BINF_PRINTOPTS) && ops['R']) || ops['-'])
X		break;
X	    if (fset(BINF_SETOPTS) && ops['A']) {
X		auxdata = arg;
X		arg = (char *)ugetnode(args);
X		break;
X	    }
X	    if (fset(BINF_FCOPTS) && execop == 'e') {
X		auxdata = arg;
X		arg = (char *)ugetnode(args);
X	    }
X	    if (fset(BINF_TYPEOPT) && (execop == 'L' || execop == 'R' ||
X				       execop == 'Z' || execop == 'i') && arg && idigit(*arg)) {
X		auxlen = atoi(arg);
X		arg = (char *)ugetnode(args);
X	    }
X	}
X    if (fset(BINF_R))
X	auxdata = "-";
X    if ((pp = b->defopts))
X	while (*pp)
X	    ops[(int)*pp++] = 1;
X    if (arg) {
X	argc = 1;
X	n = firstnode(args);
X	while (n)
X	    argc++, incnode(n);
X    }
X    oargv = argv = (char **)ncalloc(sizeof(char **) * (argc + 1));
X
X    if ((*argv++ = arg))
X	while ((*argv++ = (char *)ugetnode(args)));
X    argv = oargv;
X    if (errflag) {
X	zsfree(xarg);
X	return 1;
X    }
X    if (argc < b->minargs || (argc > b->maxargs && b->maxargs != -1)) {
X	zerrnam(name, (argc < b->minargs)
X		? "not enough arguments" : "too many arguments", NULL, 0);
X	zsfree(xarg);
X	return 1;
X    }
X    if (isset(XTRACE)) {
X	char **execpp = argv;
X
X	fprintf(stderr, "%s%s", (prompt4) ? prompt4 : "", name);
X	if (xarg)
X	    fprintf(stderr, " %s", xarg);
X	while (*execpp)
X	    fprintf(stderr, " %s", *execpp++);
X	fputc('\n', stderr);
X	fflush(stderr);
X    }
X    zsfree(xarg);
X    return (*(b->handlerfunc)) (name, argv, ops, b->funcid);
X}
X
Xstruct asgment *getasg(s)	/**/
Xchar *s;
X{
X    static struct asgment asg;
X
X    if (!s)
X	return NULL;
X    if (*s == '=') {
X	zerr("bad assignment", NULL, 0);
X	return NULL;
X    }
X    asg.name = s;
X    for (; *s && *s != '='; s++);
X    if (*s) {
X	*s = '\0';
X	asg.value = s + 1;
X    } else
X	asg.value = NULL;
X    return &asg;
X}
X
X/* ., source */
X
Xint bin_dot(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    char **old, *old0;
X    int ret, diddot = 0, dotdot = 0;
X    char buf[MAXPATHLEN];
X    char *s, **t, *enam;
X
X    if (!*argv)
X	return 0;
X    old = pparams;
X    old0 = argzero;
X    if (argv[1]) {
X	permalloc();
X	pparams = arrdup(argv + 1);
X	heapalloc();
X    }
X    enam = argzero = ztrdup(*argv);
X    errno = ENOENT;
X    ret = 1;
X    if (*name != '.' && access(argzero, F_OK) == 0) {
X	diddot = 1;
X	ret = source(enam = argzero);
X    }
X    if (ret) {
X	for (s = argzero; *s; s++)
X	    if (*s == '/') {
X		if (*argzero == '.') {
X		    if (argzero + 1 == s)
X			++diddot;
X		    else if (argzero[1] == '.' && argzero + 2 == s)
X			++dotdot;
X		}
X		ret = source(argzero);
X		break;
X	    }
X	if (!*s || (ret && isset(PATHDIRS) && diddot < 2 && dotdot == 0)) {
X	    for (t = path; *t; t++) {
X		if ((*t)[0] == '.' && !(*t)[1]) {
X		    if (diddot)
X			continue;
X		    diddot = 1;
X		    strcpy(buf, argzero);
X		} else
X		    sprintf(buf, "%s/%s", *t, argzero);
X		if (access(buf, F_OK) == 0) {
X		    ret = source(enam = buf);
X		    break;
X		}
X	    }
X	}
X    }
X    if (argv[1]) {
X	freearray(pparams);
X	pparams = old;
X    }
X    if (ret)
X	zerrnam(name, "%e: %s", enam, errno);
X    zsfree(argzero);
X    argzero = old0;
X    return ret ? ret : lastval;
X}
X
Xint bin_set(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    struct option *opp;
X    char **x;
X
X    if (((ops['+'] && ops['-']) || !ops['-']) && !ops['@'] && !*argv) {
X	showflag = ~0;
X	showflag2 = ops[(int)'+'];
X	listhtable(paramtab, (HFunc) printparam);
X    }
X    for (opp = optns; opp->name; opp++)
X	if (ops[(int)opp->id] == 1)
X	    opts[(int)opp->id] = OPT_SET;
X	else if (ops[(int)opp->id] == 2)
X	    opts[(int)opp->id] = OPT_UNSET;
X    if (ops['A'] && !auxdata) {
X	showflag = PMFLAG_A;
X	showflag2 = ops[(int)'+'];
X	listhtable(paramtab, (HFunc) printparam);
X    }
X    if (!*argv && !ops['-'])
X	return 0;
X    permalloc();
X    x = arrdup(argv);
X    heapalloc();
X    if (ops['A'])
X	setaparam(auxdata, x);
X    else {
X	freearray(pparams);
X	pparams = x;
X    }
X    return 0;
X}
X
X#define pttime(X) printf("%ldm%lds",((long) (X))/3600,((long) (X))/60%60)
X
Xint bin_times(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    struct tms buf;
X
X    if (times(&buf) == -1)
X	return 1;
X    pttime(buf.tms_utime);
X    putchar(' ');
X    pttime(buf.tms_stime);
X    putchar('\n');
X    pttime(buf.tms_cutime);
X    putchar(' ');
X    pttime(buf.tms_cstime);
X    putchar('\n');
X    return 0;
X}
X
Xint bin_getopts(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    char *optstr = *argv++, *var = *argv++;
X    char **args = (*argv) ? argv : pparams;
X    static int optcind = 1, quiet;
X    char *str, optbuf[3], *opch = optbuf + 1;
X    int oldzoptind = zoptind;
X
X    if (zoptind < 1)
X	zoptind = 1;
X    if (zoptind == 1)
X	quiet = 0;
X    optbuf[0] = '+';
X    optbuf[1] = optbuf[2] = '\0';
X    zsfree(zoptarg);
X    zoptarg = ztrdup("");
X    setsparam(var, ztrdup(""));
X    if (*optstr == ':') {
X	quiet = 1;
X	optstr++;
X    }
X    if (zoptind > arrlen(args))
X	return 1;
X    str = args[zoptind - 1];
X    if ((*str != '+' && *str != '-') || optcind >= (int)strlen(str) ||
X	!strcmp("--", str)) {
X	if (*str == '+' || *str == '-')
X	    zoptind++;
X	optcind = 0;
X	return 1;
X    }
X    if (!optcind)
X	optcind = 1;
X    *opch = str[optcind++];
X    if (!args[zoptind - 1][optcind]) {
X	zoptind++;
X	optcind = 0;
X    }
X    for (; *optstr; optstr++)
X	if (*opch == *optstr)
X	    break;
X    if (!*optstr) {
X	setsparam(var, ztrdup("?"));
X	zoptind = oldzoptind;
X	if (quiet) {
X	    zsfree(zoptarg);
X	    zoptarg = ztrdup(opch);
X	    return 0;
X	}
X	zerr("bad option: %c", NULL, *opch);
X	errflag = 0;
X	return 0;
X    }
X    setsparam(var, ztrdup(opch - (*str == '+')));
X    if (optstr[1] == ':') {
X	if (!args[zoptind - 1]) {
X	    if (quiet) {
X		zsfree(zoptarg);
X		zoptarg = ztrdup(opch);
X		setsparam(var, ztrdup(":"));
X		return 0;
X	    }
X	    setsparam(var, ztrdup("?"));
X	    zerr("argument expected after %c option", NULL, *opch);
X	    errflag = 0;
X	    return 0;
X	}
X	zsfree(zoptarg);
X	zoptarg = ztrdup(args[zoptind - 1] + optcind);
X	zoptind++;
X	optcind = 0;
X    }
X    return 0;
X}
X
X/* get a signal number from a string */
X
Xint getsignum(s)		/**/
Xchar *s;
X{
X    int x = atoi(s), t0;
X
X    if (idigit(*s) && x >= 0 && x < VSIGCOUNT)
X	return x;
X    for (t0 = 0; t0 != VSIGCOUNT; t0++)
X	if (!strcmp(s, sigs[t0]))
X	    return t0;
X    return -1;
X}
X
Xint bin_trap(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    List l;
X    char *arg;
X
X    if (!*argv) {
X	int t0;
X
X	for (t0 = 0; t0 != VSIGCOUNT; t0++)
X	    if (sigtrapped[t0])
X		if (!sigfuncs[t0])
X		    printf("TRAP%s () {}\n", sigs[t0]);
X		else {
X		    char *s =
X		    getpermtext((vptr) dupstruct((vptr) sigfuncs[t0]));
X
X		    printf("TRAP%s () {\n\t%s\n}\n", sigs[t0], s);
X		    zsfree(s);
X		}
X	return 0;
X    }
X    if ((getsignum(*argv) != -1) || (!strcmp(*argv, "-") && argv++)) {
X	int t0;
X
X	if (!*argv)
X	    for (t0 = 0; t0 != VSIGCOUNT; t0++)
X		unsettrap(t0);
X	else
X	    while (*argv)
X		unsettrap(getsignum(*argv++));
X	return 0;
X    }
X    arg = *argv++;
X    if (!*arg)
X	l = NULL;
X    else if (!(l = parselstring(arg))) {
X	zerrnam(name, "couldn't parse trap command", NULL, 0);
X	return 1;
X    }
X    for (; *argv; argv++) {
X	int sg = getsignum(*argv);
X
X	if (sg == -1) {
X	    zerrnam(name, "undefined signal: %s", *argv, 0);
X	    break;
X	}
X	settrap(sg, l);
X    }
X    if (l)
X	popheap();
X    return errflag;
X}
X
X#ifdef RLIM_INFINITY
Xvoid printulimit(lim, hard)	/**/
Xint lim;
Xint hard;
X{
X    RLIM_TYPE t0;
X
X    t0 = (hard) ? limits[lim].rlim_max : limits[lim].rlim_cur;
X    switch (lim) {
X    case RLIMIT_CPU:
X	printf("cpu time (seconds)         ");
X	break;
X    case RLIMIT_FSIZE:
X	printf("file size (blocks)         ");
X	t0 /= 512;
X	break;
X    case RLIMIT_DATA:
X	printf("data seg size (kbytes)     ");
X	t0 /= 1024;
X	break;
X    case RLIMIT_STACK:
X	printf("stack size (kbytes)        ");
X	t0 /= 1024;
X	break;
X    case RLIMIT_CORE:
X	printf("core file size (blocks)    ");
X	t0 /= 512;
X	break;
X#ifdef RLIMIT_RSS
X    case RLIMIT_RSS:
X	printf("resident set size (kbytes) ");
X	t0 /= 1024;
X	break;
X#endif
X#ifdef RLIMIT_MEMLOCK
X    case RLIMIT_MEMLOCK:
X	printf("locked-in-memory size (kb) ");
X	t0 /= 1024;
X	break;
X#endif
X#ifdef RLIMIT_NPROC
X    case RLIMIT_NPROC:
X	printf("processes                  ");
X	break;
X#endif
X#ifdef RLIMIT_OFILE
X    case RLIMIT_OFILE:
X	printf("open files                 ");
X	break;
X#endif
X#ifdef RLIMIT_NOFILE
X    case RLIMIT_NOFILE:
X	printf("file descriptors           ");
X	break;
X#endif
X#ifdef RLIMIT_VMEM
X    case RLIMIT_VMEM:
X	printf("virtual memory size (kb)   ");
X	t0 /= 1024;
X	break;
X#endif
X    }
X    if (t0 == RLIM_INFINITY)
X	printf("unlimited\n");
X    else
X	printf("%ld\n", (long)t0);
X}
X#endif
X
Xint bin_ulimit(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X#ifndef RLIM_INFINITY
X    zwarnnam(name, "not available on this system", NULL, 0);
X    return 1;
X#else
X    int res, hard;
X
X    hard = ops['H'];
X    if (ops['a'] || !ops['@'])
X	res = -1;
X    else if (ops['t'])
X	res = RLIMIT_CPU;
X    else if (ops['f'])
X	res = RLIMIT_FSIZE;
X    else if (ops['d'])
X	res = RLIMIT_DATA;
X    else if (ops['s'])
X	res = RLIMIT_STACK;
X    else if (ops['c'])
X	res = RLIMIT_CORE;
X#ifdef RLIMIT_MEMLOCK
X    else if (ops['l'])
X	res = RLIMIT_MEMLOCK;
X#endif
X#ifdef RLIMIT_RSS
X    else if (ops['m'])
X	res = RLIMIT_RSS;
X#endif
X#ifdef RLIMIT_NOFILE
X    else if (ops['n'])
X	res = RLIMIT_NOFILE;
X#endif
X#ifdef RLIMIT_OFILE
X    else if (ops['o'])
X	res = RLIMIT_OFILE;
X#endif
X#ifdef RLIMIT_NPROC
X    else if (ops['p'])
X	res = RLIMIT_NPROC;
X#endif
X#ifdef RLIMIT_VMEM
X    else if (ops['v'])
X	res = RLIMIT_VMEM;
X#endif
X    else {
X	zwarnnam(name, "no such limit", NULL, 0);
X	return 1;
X    }
X    if (res == -1)
X	if (*argv) {
X	    zwarnnam(name, "no arguments required after -a", NULL, 0);
X	    return 1;
X	} else {
X	    int t0;
X
X	    for (t0 = 0; t0 != RLIM_NLIMITS; t0++)
X		printulimit(t0, hard);
X	    return 0;
X	}
X    if (!*argv)
X	printulimit(res, hard);
X    else if (strcmp(*argv, "unlimited")) {
X	RLIM_TYPE t0;
X
X	t0 = (RLIM_TYPE) atol(*argv);
X	switch (res) {
X	case RLIMIT_FSIZE:
X	case RLIMIT_CORE:
X	    t0 *= 512;
X	    break;
X	case RLIMIT_DATA:
X	case RLIMIT_STACK:
X#ifdef RLIMIT_RSS
X	case RLIMIT_RSS:
X#endif
X#ifdef RLIMIT_MEMLOCK
X	case RLIMIT_MEMLOCK:
X#endif
X#ifdef RLIMIT_VMEM
X	case RLIMIT_VMEM:
X#endif
X	    t0 *= 1024;
X	    break;
X	}
X	if (hard) {
X	    if (t0 > limits[res].rlim_max && geteuid()) {
X		zwarnnam(name, "can't raise hard limits", NULL, 0);
X		return 1;
X	    }
X	    limits[res].rlim_max = t0;
X	} else {
X	    if (t0 > limits[res].rlim_max) {
X		if (geteuid()) {
X		    zwarnnam(name, "value exceeds hard limit", NULL, 0);
X		    return 1;
X		}
X		limits[res].rlim_max = limits[res].rlim_cur = t0;
X	    } else
X		limits[res].rlim_cur = t0;
X	}
X    } else {
X	if (hard) {
X	    if (geteuid()) {
X		zwarnnam(name, "can't remove hard limits", NULL, 0);
X		return 1;
X	    }
X	    limits[res].rlim_max = RLIM_INFINITY;
X	} else
X	    limits[res].rlim_cur = limits[res].rlim_max;
X    }
X    return 0;
X#endif
X}
X
Xint putraw(c)			/**/
Xint c;
X{
X    putchar(c);
X    return 0;
X}
X
Xint bin_echotc(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    char *s, buf[2048], *t, *u;
X    int num, argct, t0;
X
X    s = *argv++;
X    if (!termok)
X	return 1;
X    if ((num = tgetnum(s)) != -1) {
X	printf("%d\n", num);
X	return 0;
X    }
X    if (tgetflag(s)) {
X	puts("yes");
X	return (0);
X    }
X    u = buf;
X    t = tgetstr(s, &u);
X    if (!t || !*t) {
X	zwarnnam(name, "no such capability: %s", s, 0);
X	return 1;
X    }
X    for (argct = 0, u = t; *u; u++)
X	if (*u == '%') {
X	    if (u++, (*u == 'd' || *u == '2' || *u == '3' || *u == '.' ||
X		      *u == '+'))
X		argct++;
X	}
X    if (arrlen(argv) != argct) {
X	zwarnnam(name, (arrlen(argv) < argct) ? "not enough arguments" :
X		 "too many arguments", NULL, 0);
X	return 1;
X    }
X    if (!argct)
X	tputs(t, 1, putraw);
X    else {
X	t0 = (argv[1]) ? atoi(argv[1]) : atoi(*argv);
X	tputs(tgoto(t, atoi(*argv), t0), t0, putraw);
X    }
X    return 0;
X}
X
Xint bin_pwd(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    printf("%s\n", pwd);
X    return 0;
X}
X
X#define TEST_END 0
X#define TEST_INPAR 1
X#define TEST_OUTPAR 2
X#define TEST_STR 3
X#define TEST_AND 4
X#define TEST_OR 5
X#define TEST_NOT 6
X
Xstatic char **tsp;
Xstatic int *tip;
X
Xint bin_test(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    char **s;
X    int cnt, *arr, *ap, last_expr = 0;
X    Cond c;
X
X    if (func == BIN_BRACKET) {
X	for (s = argv; *s; s++);
X	if (s == argv || strcmp(s[-1], "]")) {
X	    zerrnam(name, "']' expected", NULL, 0);
X	    return 1;
X	}
X	s[-1] = NULL;
X    }
X    if (!*argv)
X	return 1;
X    for (s = argv, cnt = 0; *s; s++, cnt++);
X    ap = arr = (int *)alloc((cnt + 1) * sizeof *arr);
X    for (s = argv; *s; s++, ap++)
X	if (!strcmp(*s, "(")) {
X	    *ap = TEST_INPAR;
X	    last_expr = 0;
X	} else if (!strcmp(*s, ")")) {
X	    *ap = TEST_OUTPAR;
X	    last_expr = 1;
X	} else if (!strcmp(*s, "=") || !strcmp(*s, "!=")) {
X	    zerrnam(name, "argument expected", NULL, 0);
X	    return 1;
X	} else if (s[1] && (!strcmp(s[1], "=") || !strcmp(s[1], "!=")
X			    || (s[1][0] == '-' &&
X				get_cond_num(s[1] + 1) > -1))) {
X	    if (!s[2] || (!strcmp(s[2], "(") || !strcmp(s[2], ")"))) {
X		zerrnam(name, "argument expected", NULL, 0);
X		return 1;
X	    }
X	    ap[0] = ap[1] = ap[2] = TEST_STR;
X	    ap += 2;
X	    s += 2;
X	    last_expr = 1;
X	} else if (!strcmp(*s, "-a") && last_expr) {
X	    *ap = TEST_AND;
X	    last_expr = 0;
X	} else if (!strcmp(*s, "-o") && last_expr) {
X	    *ap = TEST_OR;
X	    last_expr = 0;
X	} else if (!strcmp(*s, "!") && !last_expr) {
X	    *ap = TEST_NOT;
X	    last_expr = 0;
X	} else {
X	    *ap = TEST_STR;
X	    last_expr = 1;
X	    if (s[1] && strcmp(s[1], "(") && strcmp(s[1], ")") &&
X		**s == '-') {
X		*++ap = TEST_STR;
X		++s;
X	    }
X	}
X    *ap = TEST_END;
X    tsp = argv;
X    tip = arr;
X    c = partest(0);
X    if (*tip != TEST_END || errflag) {
X	zerrnam(name, "parse error", NULL, 0);
X	return 1;
X    }
X    return (c) ? !evalcond(c) : 1;
X}
X
XCond partest(level)		/**/
Xint level;
X{
X    Cond a, b;
X
X    switch (level) {
X    case 0:
X	a = partest(1);
X	if (*tip == TEST_OR) {
X	    tip++, tsp++;
X	    b = (Cond) makecond();
X	    b->left = (vptr) a;
X	    b->right = (vptr) partest(0);
X	    b->type = COND_OR;
X	    return b;
X	}
X	return a;
X    case 1:
X	a = partest(2);
X	if (*tip == TEST_AND) {
X	    tip++, tsp++;
X	    b = (Cond) makecond();
X	    b->left = (vptr) a;
X	    b->right = (vptr) partest(1);
X	    b->type = COND_AND;
X	    return b;
X	}
X	return a;
X    case 2:
X	if (*tip == TEST_NOT) {
X	    tip++, tsp++;
X	    b = (Cond) makecond();
X	    b->left = (vptr) partest(2);
X	    b->type = COND_NOT;
X	    return b;
X	}
X    case 3:
X	if (*tip == TEST_INPAR) {
X	    tip++, tsp++;
X	    b = partest(0);
X	    if (*tip != TEST_OUTPAR) {
X		zerrnam("test", "parse error", NULL, 0);
X		return NULL;
X	    }
X	    tip++, tsp++;
X	    return b;
X	}
X	if (tip[0] != TEST_STR) {
X	    zerrnam("test", "parse error", NULL, 0);
X	    return NULL;
X	} else if (tip[1] != TEST_STR) {
X	    b = (Cond) makecond();
X	    if (!strcmp(*tsp, "-t")) {
X		b->left = (vptr) dupstring("1");
X		b->type = 't';
X	    } else {
X		b->left = (vptr) tsp[0];
X		b->type = 'n';
X	    }
X	    tip++, tsp++;
X	    return b;
X	} else if (tip[2] != TEST_STR) {
X	    b = par_cond_double(tsp[0], tsp[1]);
X	    tip += 2, tsp += 2;
X	    return b;
X	} else {
X	    b = par_cond_triple(tsp[0], tsp[1], tsp[2]);
X	    tip += 3, tsp += 3;
X	    return b;
X	}
X    }
X    return NULL;
X}
X
Xint get_xcompctl(name, av, cc, isdef)	/**/
Xchar *name;
Xchar ***av;
XCompctl cc;
Xint isdef;
X{
X    char **argv = *av, *t, *tt, sav;
X    int n, l = 0, ready = 0, dummy;
X    Compcond m, c, o;
X    Compctl *next = &(cc->ext);
X
X    while (!ready) {
X	o = m = c = (Compcond) zcalloc(sizeof(*c));
X	for (t = *argv; *t;) {
X	    while (*t == ' ')
X		t++;
X	    switch (*t) {
X	    case 's':
X		c->type = CCT_CURSUF;
X		break;
X	    case 'S':
X		c->type = CCT_CURPRE;
X		break;
X	    case 'p':
X		c->type = CCT_POS;
X		break;
X	    case 'c':
X		c->type = CCT_CURSTR;
X		break;
X	    case 'C':
X		c->type = CCT_CURPAT;
X		break;
X	    case 'w':
X		c->type = CCT_WORDSTR;
X		break;
X	    case 'W':
X		c->type = CCT_WORDPAT;
X		break;
X	    case 'n':
X		c->type = CCT_CURSUB;
X		break;
X	    case 'N':
X		c->type = CCT_CURSUBC;
X		break;
X	    case 'm':
X		c->type = CCT_NUMWORDS;
X		break;
X	    case 'r':
X		c->type = CCT_RANGESTR;
X		break;
X	    case 'R':
X		c->type = CCT_RANGEPAT;
X		break;
X	    default:
X		t[1] = '\0';
X		zerrnam(name, "unknown condition code: %s", t, 0);
X		freecompctl(cc);
X		zfree(m, sizeof(struct compcond));
X
X		return 1;
X	    }
X	    if (t[1] != '[') {
X		t[1] = '\0';
X		zerrnam(name, "expected condition after condition code: %s", t, 0);
X		freecompctl(cc);
X		zfree(m, sizeof(struct compcond));
X
X		return 1;
X	    }
X	    t++;
X	    for (n = 0, tt = t; *tt == '['; n++) {
X		for (l = 1, tt++; *tt && l; tt++)
X		    if (*tt == '\\' && tt[1])
X			tt++;
X		    else if (*tt == '[')
X			l++;
X		    else if (*tt == ']')
X			l--;
X		    else if (l == 1 && *tt == ',')
X			*tt = '\201';
X		if (tt[-1] == ']')
X		    tt[-1] = '\200';
X	    }
X
X	    if (l) {
X		t[1] = '\0';
X		zerrnam(name, "error after condition code: %s", t, 0);
X		freecompctl(cc);
X		zfree(m, sizeof(struct compcond));
X
X		return 1;
X	    }
X	    c->n = n;
X
X	    if (c->type == CCT_POS ||
X		c->type == CCT_NUMWORDS) {
X		c->u.r.a = (int *)zcalloc(n * sizeof(int));
X		c->u.r.b = (int *)zcalloc(n * sizeof(int));
X	    } else if (c->type == CCT_CURSUF ||
X		       c->type == CCT_CURPRE)
X		c->u.s.s = (char **)zcalloc(n * sizeof(char *));
X
X	    else if (c->type == CCT_RANGESTR ||
X		     c->type == CCT_RANGEPAT) {
X		c->u.l.a = (char **)zcalloc(n * sizeof(char *));
X		c->u.l.b = (char **)zcalloc(n * sizeof(char *));
X	    } else {
X		c->u.s.p = (int *)zcalloc(n * sizeof(int));
X		c->u.s.s = (char **)zcalloc(n * sizeof(char *));
X	    }
X	    for (l = 0; *t == '['; l++, t++) {
X		for (t++; *t && *t == ' '; t++);
X		tt = t;
X		if (c->type == CCT_POS ||
X		    c->type == CCT_NUMWORDS) {
X		    for (; *t && *t != '\201' && *t != '\200'; t++);
X		    if (!(sav = *t)) {
X			zerrnam(name, "error in condition", NULL, 0);
X			freecompctl(cc);
X			freecompcond(m);
X			return 1;
X		    }
X		    *t = '\0';
X		    c->u.r.a[l] = atoi(tt);
X		    if (sav == '\200')
X			c->u.r.b[l] = c->u.r.a[l];
X		    else {
X			tt = ++t;
X			for (; *t && *t != '\200'; t++);
X			if (!*t) {
X			    zerrnam(name, "error in condition", NULL, 0);
X			    freecompctl(cc);
X			    freecompcond(m);
X			    return 1;
X			}
X			*t = '\0';
X			c->u.r.b[l] = atoi(tt);
X		    }
X		} else if (c->type == CCT_CURSUF ||
X			   c->type == CCT_CURPRE) {
X		    for (; *t && *t != '\200'; t++)
X			if (*t == '\201')
X			    *t = ',';
X		    if (!*t) {
X			zerrnam(name, "error in condition", NULL, 0);
X			freecompctl(cc);
X			freecompcond(m);
X			return 1;
X		    }
X		    *t = '\0';
X		    c->u.s.s[l] = ztrdup(tt);
X		} else if (c->type == CCT_RANGESTR ||
X			   c->type == CCT_RANGEPAT) {
X		    for (; *t && *t != '\201'; t++);
X		    if (!*t) {
X			zerrnam(name, "error in condition", NULL, 0);
X			freecompctl(cc);
X			freecompcond(m);
X			return 1;
X		    }
X		    *t = '\0';
X		    c->u.l.a[l] = ztrdup(tt);
X		    tt = ++t;
X		    for (; *t && *t != '\200'; t++)
X			if (*t == '\201')
X			    *t = ',';
X		    if (!*t) {
X			zerrnam(name, "error in condition", NULL, 0);
X			freecompctl(cc);
X			freecompcond(m);
X			return 1;
X		    }
X		    *t = '\0';
X		    c->u.l.b[l] = ztrdup(tt);
X		} else {
X		    for (; *t && *t != '\201'; t++);
X		    if (!*t) {
X			zerrnam(name, "error in condition", NULL, 0);
X			freecompctl(cc);
X			freecompcond(m);
X			return 1;
X		    }
X		    *t = '\0';
X		    c->u.s.p[l] = atoi(tt);
X		    tt = ++t;
X		    for (; *t && *t != '\200'; t++)
X			if (*t == '\201')
X			    *t = ',';
X		    if (!*t) {
X			zerrnam(name, "error in condition", NULL, 0);
X			freecompctl(cc);
X			freecompcond(m);
X			return 1;
X		    }
X		    *t = '\0';
X		    c->u.s.s[l] = ztrdup(tt);
X		}
X	    }
X	    while (*t == ' ')
X		t++;
X	    if (*t == ',') {
X		o->or = c = (Compcond) zcalloc(sizeof(*c));
X		o = c;
X		t++;
X	    } else if (*t) {
X		c->and = (Compcond) zcalloc(sizeof(*c));
X		c = c->and;
X	    }
X	}
X	*next = (Compctl) zcalloc(sizeof(*cc));
X	(*next)->cond = m;
X	argv++;
X	if (get_compctl(name, &argv, *next, &dummy, 0, isdef)) {
X	    freecompctl(cc);
X	    return 1;
X	}
X	if ((!argv || !*argv) &&
X	    (cc == &cc_default || cc == &cc_compos))
X	    ready = 1;
X	else {
X	    if (!argv || !*argv || **argv != '-' ||
X		((!argv[0][1] || argv[0][1] == '+') && !argv[1])) {
X		zerrnam(name, "missing command names", NULL, 0);
X		freecompctl(cc);
X		return 1;
X	    }
X	    if (!strcmp(*argv, "--"))
X		ready = 1;
X	    else if (!strcmp(*argv, "-+") && argv[1] && !strcmp(argv[1], "--")) {
X		ready = 1;
X		argv++;
X	    }
X	    argv++;
X	    next = &((*next)->next);
X	}
X    }
X    *av = argv - 1;
X    return 0;
X}
X
Xint get_compctl(name, av, cc, t, first, isdef)	/**/
Xchar *name;
Xchar ***av;
XCompctl cc;
Xint *t;
Xint first;
Xint isdef;
X{
X    unsigned long flags = 0;
X    Compctl cc2 = NULL;
X    char **argv = *av, *usrkeys = NULL, *compglob = NULL, *str = NULL;
X    char *funcn = NULL, *explain = NULL, *compprefix = NULL, *suffix = NULL;
X    char *subcmd = NULL, *hpat = NULL;
X    int ready = 0, hnum = 0, hx = 0;
X
X    for (; !ready && *argv && **argv == '-';) {
X	if (**argv == '-' && !(*argv)[1])
X	    *argv = "-+";
X	while (!ready && *++(*argv))
X	    switch (**argv) {
X	    case 'f':
X		flags |= CC_FILES;
X		break;
X	    case 'c':
X		flags |= CC_COMMPATH;
X		break;
X	    case 'o':
X		flags |= CC_OPTIONS;
X		break;
X	    case 'v':
X		flags |= CC_VARS;
X		break;
X	    case 'b':
X		flags |= CC_BINDINGS;
X		break;
X	    case 'A':
X		flags |= CC_ARRAYS;
X		break;
X	    case 'I':
X		flags |= CC_INTVARS;
X		break;
X	    case 'F':
X		flags |= CC_FUNCS;
X		break;
X	    case 'p':
X		flags |= CC_PARAMS;
X		break;
X	    case 'E':
X		flags |= CC_ENVVARS;
X		break;
X	    case 'j':
X		flags |= CC_JOBS;
X		break;
X	    case 'r':
X		flags |= CC_RUNNING;
X		break;
X	    case 'z':
X		flags |= CC_STOPPED;
X		break;
X	    case 'B':
X		flags |= CC_BUILTINS;
X		break;
X	    case 'a':
X		flags |= CC_ALREG | CC_ALGLOB;
X		break;
X	    case 'R':
X		flags |= CC_ALREG;
X		break;
X	    case 'G':
X		flags |= CC_ALGLOB;
X		break;
X	    case 'u':
X		flags |= CC_USERS;
X		break;
X	    case 'd':
X		flags |= CC_DISCMDS;
X		break;
X	    case 'e':
X		flags |= CC_EXCMDS;
X		break;
X	    case 'N':
X		flags |= CC_SCALARS;
X		break;
X	    case 'O':
X		flags |= CC_READONLYS;
X		break;
X	    case 'Z':
X		flags |= CC_SPECIALS;
X		break;
X	    case 'q':
X		flags |= CC_REMOVE;
X		break;
X	    case 'U':
X		flags |= CC_DELETE;
X		break;
X	    case 'n':
X		flags |= CC_NAMED;
X		break;
X	    case 'k':
X		if ((*argv)[1]) {
X		    usrkeys = (*argv) + 1;
X		    *argv = "" - 1;
X		} else if (!argv[1]) {
X		    zerrnam(name, "variable name expected after -k", NULL, 0);
X		    return 1;
X		} else {
X		    usrkeys = *++argv;
X		    *argv = "" - 1;
X		}
X		break;
X	    case 'K':
X		if ((*argv)[1]) {
X		    funcn = (*argv) + 1;
X		    *argv = "" - 1;
X		} else if (!argv[1]) {
X		    zerrnam(name, "function name expected after -K", NULL, 0);
X		    return 1;
X		} else {
X		    funcn = *++argv;
X		    *argv = "" - 1;
X		}
X		break;
X	    case 'X':
X		if ((*argv)[1]) {
X		    explain = (*argv) + 1;
X		    *argv = "" - 1;
X		} else if (!argv[1]) {
X		    zerrnam(name, "string expected after -X", NULL, 0);
X		    return 1;
X		} else {
X		    explain = *++argv;
X		    *argv = "" - 1;
X		}
X		break;
X	    case 'P':
X		if (hx) {
X		    zerrnam(name, "prefix definition in xor'd completion not allowed",
X			    NULL, 0);
X		    return 1;
X		}
X		if ((*argv)[1]) {
X		    compprefix = (*argv) + 1;
X		    *argv = "" - 1;
X		} else if (!argv[1]) {
X		    zerrnam(name, "string expected after -P", NULL, 0);
X		    return 1;
X		} else {
X		    compprefix = *++argv;
X		    *argv = "" - 1;
X		}
X		break;
X	    case 'S':
X		if (hx) {
X		    zerrnam(name, "suffix definition in xor'd completion not allowed",
X			    NULL, 0);
X		    return 1;
X		}
X		if ((*argv)[1]) {
X		    suffix = (*argv) + 1;
X		    *argv = "" - 1;
X		} else if (!argv[1]) {
X		    zerrnam(name, "string expected after -S", NULL, 0);
X		    return 1;
X		} else {
X		    suffix = *++argv;
X		    *argv = "" - 1;
X		}
X		break;
X	    case 'g':
X		if ((*argv)[1]) {
X		    compglob = (*argv) + 1;
X		    *argv = "" - 1;
X		} else if (!argv[1]) {
X		    zerrnam(name, "glob pattern expected after -g", NULL, 0);
X		    return 1;
X		} else {
X		    compglob = *++argv;
X		    *argv = "" - 1;
X		}
X		break;
X	    case 's':
X		if ((*argv)[1]) {
X		    str = (*argv) + 1;
X		    *argv = "" - 1;
X		} else if (!argv[1]) {
X		    zerrnam(name, "command string expected after -s", NULL, 0);
X		    return 1;
X		} else {
X		    str = *++argv;
X		    *argv = "" - 1;
X		}
X		break;
X	    case 'l':
X		if ((*argv)[1]) {
X		    subcmd = (*argv) + 1;
X		    *argv = "" - 1;
X		} else if (!argv[1]) {
X		    zerrnam(name, "command name expected after -s", NULL, 0);
X		    return 1;
X		} else {
X		    subcmd = *++argv;
X		    *argv = "" - 1;
X		}
X		break;
X	    case 'H':
X		if ((*argv)[1])
X		    hnum = atoi((*argv) + 1);
X		else if (argv[1])
X		    hnum = atoi(*++argv);
X		else {
X		    zerrnam(name, "number expected after -H", NULL, 0);
X		    return 1;
X		}
X		if (!argv[1]) {
X		    zerrnam(name, "missing pattern after -H", NULL, 0);
X		    return 1;
X		}
X		hpat = *++argv;
X		if (hnum < 1)
X		    hnum = 0;
X		if (*hpat == '*' && !hpat[1])
X		    hpat = "";
X		*argv = "" - 1;
X		break;
X	    case 'C':
X		if (first && !hx) {
X		    Compctl c2;
X
X		    cc = cc2 = &cc_compos;
X
X		    c2 = (Compctl) zcalloc(sizeof *cc2);
X		    c2->xor = cc2->xor;
X		    c2->ext = cc2->ext;
X		    c2->refc = 1;
X
X		    freecompctl(c2);
X
X		    cc2->ext = cc2->xor = NULL;
X		} else {
X		    zerrnam(name, "misplaced command completion (-C) flag", NULL, 0);
X		    return 1;
X		}
X		break;
X	    case 'D':
X		if (first && !hx) {
X		    Compctl c2;
X
X		    cc = cc2 = &cc_default, isdef = 1;
X		    c2 = (Compctl) zcalloc(sizeof *cc2);
X		    c2->xor = cc2->xor;
X		    c2->ext = cc2->ext;
X		    c2->refc = 1;
X
X		    freecompctl(c2);
X
X		    cc2->ext = cc2->xor = NULL;
X		} else {
X		    zerrnam(name, "misplaced default completion (-D) flag", NULL, 0);
X		    return 1;
X		}
X		break;
X	    case 'x':
X		if (!argv[1]) {
X		    zerrnam(name, "condition expected after -x", NULL, 0);
X		    return 1;
X		}
X		if (first) {
X		    argv++;
X		    if (get_xcompctl(name, &argv, cc, isdef))
X			return 2;
X		    ready = 2;
X		} else {
X		    zerrnam(name, "recursive extended completion not allowed",
X			    NULL, 0);
X		    return 1;
X		}
X		break;
X	    default:
X		if (!first && (**argv == '-' || **argv == '+'))
X		    (*argv)--, argv--, ready = 1;
X		else {
X		    zerrnam(name, "bad option: %c", NULL, **argv);
X		    return 1;
X		}
X	    }
X
X	if (*++argv && (!ready || ready == 2) && **argv == '+' && !argv[0][1]) {
X	    hx = 1;
X	    ready = 0;
X
X	    if (subcmd &&
X		(usrkeys || compglob || str || funcn || explain || compprefix ||
X		 suffix || hpat || flags)) {
X		zerrnam(name, "illegal combination of options", NULL, 0);
X		return 1;
X	    }
X	    cc->mask = flags;
X	    zsfree(cc->keyvar);
X	    zsfree(cc->glob);
X	    zsfree(cc->str);
X	    zsfree(cc->func);
X	    zsfree(cc->explain);
X	    zsfree(cc->prefix);
X	    zsfree(cc->suffix);
X	    zsfree(cc->subcmd);
X	    zsfree(cc->hpat);
X
X	    cc->mask = flags;
X	    cc->keyvar = ztrdup(usrkeys);
X	    cc->glob = ztrdup(compglob);
X	    cc->str = ztrdup(str);
X	    cc->func = ztrdup(funcn);
X	    cc->explain = ztrdup(explain);
X	    cc->prefix = ztrdup(compprefix);
X	    cc->suffix = ztrdup(suffix);
X	    cc->subcmd = ztrdup(subcmd);
X	    cc->hpat = ztrdup(hpat);
X	    cc->hnum = hnum;
X
X	    if (!*++argv || **argv != '-' ||
X		(**argv == '-' && (!argv[0][1] ||
X				   (argv[0][1] == '-' && !argv[0][2])))) {
X		if (isdef) {
X		    zerrnam(name, "recursive xor'd default completions not allowed",
X			    NULL, 0);
X		    return 1;
X		}
X		cc->xor = &cc_default;
X		if (!*argv || **argv == '-') {
X		    if (*argv)
X			(*argv)--;
X		    argv--;
X		    ready = 1;
X		}
X	    } else {
X		cc->xor = (Compctl) zcalloc(sizeof(*cc));
X		cc = cc->xor;
X		flags = 0;
X		usrkeys = NULL;
X		compglob = NULL;
X		str = NULL;
X		funcn = NULL;
X		explain = NULL;
X		compprefix = NULL;
X		suffix = NULL;
X		subcmd = NULL;
X		hpat = NULL;
X		hnum = 0;
X	    }
X	}
X    }
X
X    if (subcmd &&
X	(usrkeys || compglob || str || funcn || explain || compprefix || suffix ||
X	 hpat || flags)) {
X	zerrnam(name, "illegal combination of options", NULL, 0);
X	return 1;
X    }
X    if (cc2)
X	*t = 1;
X
X    cc->mask = flags;
X    zsfree(cc->keyvar);
X    zsfree(cc->glob);
X    zsfree(cc->str);
X    zsfree(cc->func);
X    zsfree(cc->explain);
X    zsfree(cc->prefix);
X    zsfree(cc->suffix);
X    zsfree(cc->subcmd);
X    zsfree(cc->hpat);
X
X    cc->mask = flags;
X    cc->keyvar = ztrdup(usrkeys);
X    cc->glob = ztrdup(compglob);
X    cc->str = ztrdup(str);
X    cc->func = ztrdup(funcn);
X    cc->explain = ztrdup(explain);
X    cc->prefix = ztrdup(compprefix);
X    cc->suffix = ztrdup(suffix);
X    cc->subcmd = ztrdup(subcmd);
X    cc->hpat = ztrdup(hpat);
X    cc->hnum = hnum;
X    *av = argv;
X
X    return 0;
X}
X
Xint bin_compctl(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    Compctl cc = NULL;
X    int t = 0, t2;
X    unsigned long flags = 0;
X
X    if (*argv) {
X	cc = (Compctl) zcalloc(sizeof(*cc));
X
X	if ((t2 = get_compctl(name, &argv, cc, &t, 1, 0))) {
X	    if (t2 == 1)
X		freecompctl(cc);
X	    return 1;
X	}
X	if (*argv)
X	    compctl_process_cc(argv, cc);
X
X	flags = cc->mask;
X
X	if (!*argv)
X	    freecompctl(cc);
X    }
X    if (!*argv && !t) {
X	showflag = flags;
X	listhtable(compctltab, (HFunc) printcompctlp);
X	printcompctl("COMMAND", &cc_compos);
X	printcompctl("DEFAULT", &cc_default);
X    }
X    return 0;
X}
X
Xvoid printif(str, c)		/**/
Xchar *str;
Xint c;
X{
X    if (str)
X	printf("-%c \"%s\" ", c, str);
X}
X
Xvoid printcompctlp(s, ccp)	/**/
Xchar *s;
XCompctlp ccp;
X{
X    printcompctl(s, ccp->cc);
X}
X
Xvoid printcompctl(s, cc)	/**/
Xchar *s;
XCompctl cc;
X{
X    char *css = "fcqovbAIFpEjrzBRGudeNOZUn";
X    char *mss = " pcCwWsSnNmrR";
X    unsigned long t = 0x7fffffff;
X
X    if (cc->mask & showflag) {
X	if (s)
X	    puts(s);
X    } else if (!showflag) {
X	unsigned long flags = cc->mask;
X
X	if (s)
X	    printf("%s ", s);
X	if (flags & t) {
X	    putchar('-');
X	    if ((flags & (CC_ALREG | CC_ALGLOB)) == (CC_ALREG | CC_ALGLOB))
X		putchar('a'), flags &= ~(CC_ALREG | CC_ALGLOB);
X	    while (*css) {
X		if ((flags & 1) && (t & 1))
X		    putchar(*css);
X		css++;
X		flags >>= 1;
X		t >>= 1;
X	    }
X	    putchar(' ');
X	}
X	flags = cc->mask;
X	if (cc->keyvar)
X	    printf(*cc->keyvar == '(' ? "-k \"%s\" " : "-k %s ", cc->keyvar);
X	printif(cc->func, 'K');
X	printif(cc->explain, 'X');
X	printif(cc->prefix, 'P');
X	printif(cc->suffix, 'S');
X	printif(cc->glob, 'g');
X	printif(cc->str, 's');
X	printif(cc->subcmd, 'l');
X	if (cc->hpat)
X	    printf("-H %d \"%s\" ", cc->hnum, cc->hpat);
X	if (cc->ext) {
X	    Compcond c, o;
X	    int i;
X
X	    cc = cc->ext;
X	    printf("-x ");
X
X	    while (cc) {
X		c = cc->cond;
X
X		putchar('\"');
X		for (c = cc->cond; c;) {
X		    o = c->or;
X		    while (c) {
X			putchar(mss[c->type]);
X
X			for (i = 0; i < c->n; i++)
X			    switch (c->type) {
X			    case CCT_POS:
X			    case CCT_NUMWORDS:
X				printf("[%d,%d]", c->u.r.a[i], c->u.r.b[i]);
X				break;
X			    case CCT_CURSUF:
X			    case CCT_CURPRE:
X				printf("[%s]", c->u.s.s[i]);
X				break;
X			    case CCT_RANGESTR:
X			    case CCT_RANGEPAT:
X				printf("[%s,%s]", c->u.l.a[i], c->u.l.b[i]);
X				break;
X			    default:
X				printf("[%d,%s]", c->u.s.p[i], c->u.s.s[i]);
X			    }
X			if ((c = c->and))
X			    putchar(' ');
X		    }
X		    if ((c = o))
X			printf(" , ");
X		}
X		printf("\" ");
X		c = cc->cond;
X		cc->cond = NULL;
X		printcompctl(NULL, cc);
X		cc->cond = c;
X		if ((cc = (Compctl) (cc->next)))
X		    printf("- ");
X	    }
X	}
X	if (cc && cc->xor) {
X	    printf("+ ");
X	    if (cc->xor != &cc_default)
X		printcompctl(NULL, cc->xor);
X	}
X	if (s)
X	    putchar('\n');
X    }
X}
X
Xvoid compctl_process(s, mask, uk, gl, st, fu, ex, pr, su, sc, hp, hn)	/**/
Xchar **s;
Xint mask;
Xchar *uk;
Xchar *gl;
Xchar *st;
Xchar *fu;
Xchar *ex;
Xchar *pr;
Xchar *su;
Xchar *sc;
Xchar *hp;
Xint hn;
X{
X    Compctl cc;
X
X    cc = (Compctl) zcalloc(sizeof *cc);
X    cc->mask = mask;
X    cc->keyvar = ztrdup(uk);
X    cc->glob = ztrdup(gl);
X    cc->str = ztrdup(st);
X    cc->func = ztrdup(fu);
X    cc->explain = ztrdup(ex);
X    cc->prefix = ztrdup(pr);
X    cc->suffix = ztrdup(su);
X    cc->subcmd = ztrdup(sc);
X    cc->hpat = ztrdup(hp);
X    cc->hnum = hn;
X
X    compctl_process_cc(s, cc);
X}
X
Xvoid compctl_process_cc(s, cc)	/**/
Xchar **s;
XCompctl cc;
X{
X    Compctlp ccp;
X
X    cc->refc = 0;
X    for (; *s; s++) {
X	cc->refc++;
X	ccp = (Compctlp) zalloc(sizeof *ccp);
X	ccp->cc = cc;
X	addhnode(ztrdup(*s), ccp, compctltab, freecompctlp);
X    }
X}
X
Xint bin_ttyctl(name, argv, ops, func)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    if (!ops['@'])
X	printf("tty is %sfrozen\n", ttyfrozen ? "" : "not ");
X    else if (ops['f'])
X	ttyfrozen = 1;
X    else
X	ttyfrozen = 0;
X    return 0;
X}
END_OF_FILE
  if test 50522 -ne `wc -c <'zsh-2.5.0/src/builtin.c.B'`; then
    echo shar: \"'zsh-2.5.0/src/builtin.c.B'\" unpacked with wrong size!
  elif test -f 'zsh-2.5.0/src/builtin.c.A'; then
    echo shar: Combining  \"'zsh-2.5.0/src/builtin.c'\" \(106554 characters\)
    cat 'zsh-2.5.0/src/builtin.c.A' 'zsh-2.5.0/src/builtin.c.B' > 'zsh-2.5.0/src/builtin.c'
    if test 106554 -ne `wc -c <'zsh-2.5.0/src/builtin.c'`; then
      echo shar: \"'zsh-2.5.0/src/builtin.c'\" combined with wrong size!
    else
      rm zsh-2.5.0/src/builtin.c.A zsh-2.5.0/src/builtin.c.B
    fi
  fi
  # end of 'zsh-2.5.0/src/builtin.c.B'
fi
if test -f 'zsh-2.5.0/src/subst.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/src/subst.c'\"
else
  echo shar: Extracting \"'zsh-2.5.0/src/subst.c'\" \(30409 characters\)
  sed "s/^X//" >'zsh-2.5.0/src/subst.c' <<'END_OF_FILE'
X/*
X *
X * subst.c - various substitutions
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made.
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk.
X *
X */
X
X#include "zsh.h"
X#include <pwd.h>
X
X/* do substitutions before fork */
X
Xvoid prefork(list, flags)	/**/
XLklist list;
Xint flags;
X{
X    Lknode node = firstnode(list);
X    int qt;
X
X /* bits 0 and 1 of flags are flags to filesub (treat as assignment)
X     * bit 2 is a flag to paramsubst (single word sub)
X     */
X    while (node) {
X	char *str, *str3;
X	int keep = 1;
X
X	str = str3 = (char *)getdata(node);
X	if ((*str == Inang || *str == Outang || *str == Equals) &&
X	    str[1] == Inpar) {
X	    if (*str == Inang)
X		setdata(node, (vptr) getoutproc(str + 2));	/* <(...) */
X	    else if (*str == Equals)
X		setdata(node, (vptr) getoutputfile(str + 2));	/* =(...) */
X	    else
X		setdata(node, (vptr) getinproc(str + 2));	/* >(...) */
X	    if (!getdata(node)) {
X		zerr("parse error in process substitution", NULL, 0);
X		return;
X	    }
X	} else
X	    while (*str) {
X		if ((qt = *str == Qstring) || *str == String)
X		    if (str[1] != Inpar)
X			if (str[1] == Inbrack) {
X			    arithsubst((vptr *) & str, &str3);	/* $[...] */
X			    setdata(node, (vptr) str3);
X			    str = str3;
X			    continue;
X			} else {
X			    if (!paramsubst(list, node, str, str3,
X					    qt | (flags & 4), !(flags & 010)))
X				keep = 0;
X			    if (errflag)
X				return;
X			    if (!keep)
X				break;
X			    str3 = str = (char *)getdata(node);
X			    continue;
X			}
X		str++;
X		if (errflag)
X		    return;
X	    }
X	if (keep) {
X	    if (*(char *)getdata(node))
X		remnulargs(getdata(node));
X	    if (unset(IGNOREBRACES))
X		while (hasbraces(getdata(node)))
X		    xpandbraces(list, &node);
X	    filesub((char **)getaddrdata(node), flags & 3);
X	    if (errflag)
X		return;
X	    incnode(node);
X	} else {
X	    Lknode zapnode;
X
X	    zapnode = node;
X	    incnode(node);
X	    uremnode(list, zapnode);
X	}
X    }
X}
X
Xvoid postfork(list, flags)	/**/
XLklist list;
Xint flags;
X{
X    Lknode node = firstnode(list);
X    int glb = 1;
X
X /* bit 0 of flags is to do glob, bit 1 is flag for single substitution */
X    badcshglob = 0;
X    if (isset(NOGLOBOPT) || !(flags & 1))
X	glb = 0;
X    while (node) {
X	char *str3, *str;
X
X	str = str3 = (char *)getdata(node);
X	while (*str) {
X	    if (((*str == String || *str == Qstring) && str[1] == Inpar) ||
X		*str == Tick || *str == Qtick) {
X		Lknode n = prevnode(node);
X
X	    /* `...`,$(...) */
X		commsubst(list, node, str, str3,
X			  (*str == Qstring || *str == Qtick || flags > 1));
X		if (errflag)
X		    return;
X		if (!(node = nextnode(n)))
X		    return;
X		str = str3 = (char *)getdata(node);
X		continue;
X	    }
X	    str++;
X	}
X	if (glb) {
X	    if (haswilds(getdata(node)))
X		glob(list, &node);
X	    if (errflag)
X		return;
X	}
X	incnode(node);
X    }
X    if (badcshglob == 1)
X	zerr("no match", NULL, 0);
X}
X
X/* perform substitution on a single word */
X
Xvoid singsub(s)			/**/
Xchar **s;
X{
X    Lklist foo;
X
X    foo = newlist();
X    addnode(foo, *s);
X    prefork(foo, 014);
X    if (errflag)
X	return;
X    postfork(foo, 010);
X    if (errflag)
X	return;
X    *s = (char *)ugetnode(foo);
X    remnulargs(*s);
X    if (firstnode(foo))
X	zerr("ambiguous: %s", *s, 0);
X}
X
X/* ~, = subs: assign = 2 => typeset; assign = 1 => something that looks
X	like an assignment but may not be; assign = 3 => normal assignment */
X
Xvoid filesub(namptr, assign)	/**/
Xchar **namptr;
Xint assign;
X{
X    char *sub = (char *)NULL, *str, *ptr;
X    int len;
X
X    filesubstr(namptr, assign);
X
X    if (!assign)
X	return;
X
X    if (assign < 3)
X	if ((*namptr)[1] && (sub = strchr(*namptr + 1, Equals))) {
X	    if (assign == 1)
X		for (ptr = *namptr; ptr != sub; ptr++)
X		    if (!iident(*ptr) && !INULL(*ptr))
X			return;
X	    *sub = Equals;
X	    str = sub + 1;
X	    if ((sub[1] == Tilde || sub[1] == Equals) && filesubstr(&str, assign)) {
X		sub[1] = '\0';
X		*namptr = dyncat(*namptr, str);
X	    }
X	} else
X	    return;
X
X    ptr = *namptr;
X    while ((sub = strchr(ptr, ':'))) {
X	str = sub + 1;
X	len = sub - *namptr;
X	if ((sub[1] == Tilde || sub[1] == Equals) && filesubstr(&str, assign)) {
X	    sub[1] = '\0';
X	    *namptr = dyncat(*namptr, str);
X	}
X	ptr = *namptr + len + 1;
X    }
X}
X
Xint filesubstr(namptr, assign)	/**/
Xchar **namptr;
Xint assign;
X{
X    char *str = *namptr, *cnam;
X
X    if (*str == Tilde && str[1] != '=' && str[1] != Equals) {
X	if (str[1] == '+' && (str[2] == '/' || str[2] == Inpar ||
X			      (assign && str[2] == ':') || !str[2])) {
X	    *namptr = dyncat(pwd, str + 2);	/* ~+ */
X	    return 1;
X	} else if (str[1] == '-' && (str[2] == '/' || str[2] == Inpar ||
X				     (assign && str[2] == ':') || !str[2])) {
X	    *namptr = dyncat((cnam = oldpwd) ? cnam : pwd, str + 2);	/* ~- */
X	    return 1;
X	} else if (ialpha(str[1])) {	/* ~foo */
X	    char *ptr, *hom;
X
X	    for (ptr = ++str; *ptr && iuser(*ptr); ptr++);
X	    if (*ptr && *ptr != '/' && *ptr != Inpar &&
X		(!assign || *ptr != ':'))
X		return 0;
X	    if (!(hom = getnamedir(str, ptr - str))) {
X		if (!isset(NONOMATCH))
X		    zerr("user not found: %l", str, ptr - str);
X		return 0;
X	    }
X	    *namptr = dyncat(hom, ptr);
X	    return 1;
X	} else if (str[1] == '/' || str[1] == Inpar ||
X		   (assign && str[1] == ':')) {	/* ~/foo */
X	    *namptr = dyncat(home, str + 1);
X	    return 1;
X	} else if (!str[1]) {	/* ~ by itself */
X	    *namptr = dupstring(home);
X	    return 1;
X	}
X    } else if (*str == Equals && unset(NOEQUALS) && str[1]) {
X	char *ptr, *ds;
X	int val;
X
X	if (str[1] == '-') {	/* =- */
X	    val = -1;
X	    ptr = str + 2;
X	} else if (idigit(str[1]))
X	    val = zstrtol(str + 1, &ptr, 10);	/* =# */
X	else
X	/* =foo */
X	{
X	    char sav, *pp;
X
X	    for (pp = str + 1; *pp && *pp != Inpar && (!assign || *pp != ':');
X		 pp++);
X	    sav = *pp;
X	    *pp = '\0';
X	    if (!(cnam = findcmd(str + 1))) {
X		if (!isset(NONOMATCH))
X		    zerr("%s not found", str + 1, 0);
X		return 0;
X	    }
X	    *namptr = dupstring(cnam);
X	    zsfree(cnam);
X	    if (sav) {
X		*pp = sav;
X		*namptr = dyncat(*namptr, pp);
X	    }
X	    return 1;
X	}
X	ds = dstackent(val);
X	if (!ds)
X	    return 1;
X	*namptr = dyncat(ds, ptr);
X	return 1;
X    }
X    return 0;
X}
X
X/* get a named directory */
X
Xchar *getnamedir(user, len)	/**/
Xchar *user;
Xint len;
X{
X    char sav, *str, *ret_val = NULL;
X    struct passwd *pw;
X    int t0;
X    struct param *pm;
X
X    if (len == 0)
X	return dupstring(home);
X    sav = user[len];
X    user[len] = '\0';
X    if ((t0 = findname(user)) != -1)
X	ret_val = dupstring(namdirs[t0].dir);
X    else if ((pm = (struct param *)gethnode(user, paramtab)) &&
X	     !(pm->flags & (PMFLAG_i | PMFLAG_A)) &&
X	     (str = getsparam(user)) && *str == '/') {
X	adduserdir(user, str, 0, 1);
X	ret_val = str;
X    } else if ((pw = getpwnam(user))) {
X	str = xsymlink(pw->pw_dir);
X	adduserdir(user, str, 1, 1);
X	ret_val = dupstring(str);
X	zsfree(str);
X    }
X    user[len] = sav;
X    return ret_val;
X}
X
X/* `...`, $(...) */
X
Xvoid commsubst(l, n, str3, str, qt)	/**/
XLklist l;
XLknode n;
Xchar *str3;
Xchar *str;
Xint qt;
X{
X    char *str2;
X    Lknode where = prevnode(n);
X    Lklist pl;
X
X    if (*str3 == Tick || *str3 == Qtick) {
X	*str3 = '\0';
X	for (str2 = ++str3; *str3 && *str3 != Tick && *str3 != Qtick; str3++);
X	*str3++ = '\0';
X    } else {
X	*str3++ = '\0';
X	for (str2 = ++str3; *str3 && *str3 != Outpar; str3++);
X	*str3++ = '\0';
X    }
X    uremnode(l, n);
X    if (!(pl = getoutput(str2, qt))) {
X	if (!errflag)
X	    zerr("parse error in command substitution", NULL, 0);
X	return;
X    }
X    if (full(pl)) {
X	setdata(firstnode(pl), (vptr) dyncat(str, peekfirst(pl)));
X	setdata(lastnode(pl), (vptr) dyncat(getdata(lastnode(pl)), str3));
X	inslist(pl, where, l);
X    } else
X	insnode(l, where, dyncat(str, str3));
X}
X
Xvoid strcatsub(dest, src, globsubst)	/**/
Xchar *dest;
Xchar *src;
Xint globsubst;
X{
X    strcat(dest, src);
X    if (globsubst)
X	tokenize(dest);
X}
X
Xint strpcmp(a, b)		/**/
Xconst void *a;
Xconst void *b;
X{
X    return strcmp(*(char **)a, *(char **)b);
X}
X
Xint invstrpcmp(a, b)		/**/
Xconst void *a;
Xconst void *b;
X{
X    return -strcmp(*(char **)a, *(char **)b);
X}
X
Xint cstrpcmp(a, b)		/**/
Xconst void *a;
Xconst void *b;
X{
X    char *c = *(char **)a, *d = *(char **)b;
X
X    for (; *c && tulower(*c) == tulower(*d); c++, d++);
X
X    return (int)(unsigned char)tulower(*c) - (int)(unsigned char)tulower(*d);
X}
X
Xint invcstrpcmp(a, b)		/**/
Xconst void *a;
Xconst void *b;
X{
X    char *c = *(char **)a, *d = *(char **)b;
X
X    for (; *c && tulower(*c) == tulower(*d); c++, d++);
X
X    return (int)(unsigned char)tulower(*d) - (int)(unsigned char)tulower(*c);
X}
X
Xchar *dopadding(str, prenum, postnum, preone, postone, premul, postmul)	/**/
Xchar *str;
Xint prenum;
Xint postnum;
Xchar *preone;
Xchar *postone;
Xchar *premul;
Xchar *postmul;
X{
X    char def[2], *ret, *t, *r;
X    int ls, ls2, lpreone, lpostone, lpremul, lpostmul, lr, f, m, c, cc;
X
X    def[0] = ifs[0];
X    def[1] = '\0';
X    if (preone && !*preone)
X	preone = def;
X    if (postone && !*postone)
X	postone = def;
X    if (!premul || !*premul)
X	premul = def;
X    if (!postmul || !*postmul)
X	postmul = def;
X
X    ls = strlen(str);
X    lpreone = preone ? strlen(preone) : 0;
X    lpostone = postone ? strlen(postone) : 0;
X    lpremul = strlen(premul);
X    lpostmul = strlen(postmul);
X
X    lr = prenum + postnum;
X
X    if (lr == ls)
X	return str;
X
X    r = ret = (char *)halloc(lr + 1);
X
X    if (prenum) {
X	if (postnum) {
X	    ls2 = ls / 2;
X
X	    f = prenum - ls2;
X	    if (f <= 0)
X		for (str -= f, c = prenum; c--; *r++ = *str++);
X	    else {
X		if (f <= lpreone)
X		    for (c = f, t = preone + lpreone - f; c--; *r++ = *t++);
X		else {
X		    f -= lpreone;
X		    if ((m = f % lpremul))
X			for (c = m, t = premul + lpremul - m; c--; *r++ = *t++);
X		    for (cc = f / lpremul; cc--;)
X			for (c = lpremul, t = premul; c--; *r++ = *t++);
X		    for (c = lpreone; c--; *r++ = *preone++);
X		}
X		for (c = ls2; c--; *r++ = *str++);
X	    }
X	    ls2 = ls - ls2;
X	    f = postnum - ls2;
X	    if (f <= 0)
X		for (c = postnum; c--; *r++ = *str++);
X	    else {
X		for (c = ls2; c--; *r++ = *str++);
X		if (f <= lpostone)
X		    for (c = f; c--; *r++ = *postone++);
X		else {
X		    f -= lpostone;
X		    for (c = lpostone; c--; *r++ = *postone++);
X		    for (cc = f / lpostmul; cc--;)
X			for (c = lpostmul, t = postmul; c--; *r++ = *t++);
X		    if ((m = f % lpostmul))
X			for (; m--; *r++ = *postmul++);
X		}
X	    }
X	} else {
X	    f = prenum - ls;
X	    if (f <= 0)
X		for (c = prenum, str -= f; c--; *r++ = *str++);
X	    else {
X		if (f <= lpreone)
X		    for (c = f, t = preone + lpreone - f; c--; *r++ = *t++);
X		else {
X		    f -= lpreone;
X		    if ((m = f % lpremul))
X			for (c = m, t = premul + lpremul - m; c--; *r++ = *t++);
X		    for (cc = f / lpremul; cc--;)
X			for (c = lpremul, t = premul; c--; *r++ = *t++);
X		    for (c = lpreone; c--; *r++ = *preone++);
X		}
X		for (c = ls; c--; *r++ = *str++);
X	    }
X	}
X    } else if (postnum) {
X	f = postnum - ls;
X	if (f <= 0)
X	    for (c = postnum; c--; *r++ = *str++);
X	else {
X	    for (c = ls; c--; *r++ = *str++);
X	    if (f <= lpostone)
X		for (c = f; c--; *r++ = *postone++);
X	    else {
X		f -= lpostone;
X		for (c = lpostone; c--; *r++ = *postone++);
X		for (cc = f / lpostmul; cc--;)
X		    for (c = lpostmul, t = postmul; c--; *r++ = *t++);
X		if ((m = f % lpostmul))
X		    for (; m--; *r++ = *postmul++);
X	    }
X	}
X    }
X    *r = '\0';
X
X    return ret;
X}
X
Xchar *get_strarg(s)		/**/
Xchar *s;
X{
X    char t = *s++;
X
X    if (!t)
X	return s - 1;
X
X    switch (t) {
X    case '(':
X	t = ')';
X	break;
X    case '[':
X	t = ']';
X	break;
X    case '{':
X	t = '}';
X	break;
X    case '<':
X	t = '>';
X	break;
X    case Inpar:
X	t = Outpar;
X	break;
X    case Inang:
X	t = Outang;
X	break;
X    case Inbrace:
X	t = Outbrace;
X	break;
X    case Inbrack:
X	t = Outbrack;
X	break;
X    }
X
X    while (*s && *s != t)
X	s++;
X
X    return s;
X}
X
X/* parameter substitution */
X
X#define	isstring(c)	(c == '$' || c == String || c == Qstring)
X#define	isbrace(c)	(c == '{' || c == Inbrace)
X
Xint paramsubst(l, n, aptr, bptr, qt, sp)	/**/
XLklist l;
XLknode n;
Xchar *aptr;
Xchar *bptr;
Xint qt;				/* if bit 0 set, real quote, else single word substitution */
Xint sp;
X{
X    char *s = aptr, *u, *idbeg, *idend, *ostr = bptr;
X    int brs;			/* != 0 means ${...}, otherwise $... */
X    int colf;			/* != 0 means we found a colon after the name */
X    int doub = 0;		/* != 0 means we have %%, not %, or ##, not # */
X    int isarr = 0;
X    int plan9 = isset(RCEXPANDPARAM);
X    int globsubst = isset(GLOBSUBST);
X    int getlen = 0;
X    int whichlen = 0;
X    int chkset = 0;
X    int vunset = 0;
X    int spbreak = isset(SHWORDSPLIT) && sp && !qt;
X    char *val = NULL, **aval = NULL;
X    int fwidth = 0;
X    Value v;
X    int flags = 0;
X    int flnum = 0;
X    int substr = 0;
X    int sortit = 0, casind = 0;
X    int casmod = 0;
X    char *sep = NULL, *spsep = NULL;
X    char *premul = NULL, *postmul = NULL, *preone = NULL, *postone = NULL;
X    long prenum = 0, postnum = 0;
X    int copied = 0;
X
X    *s++ = '\0';
X    if (!ialnum(*s) && *s != '#' && *s != Pound && *s != '-' &&
X	*s != '!' && *s != '$' && *s != String && *s != Qstring &&
X	*s != '?' && *s != Quest && *s != '_' &&
X	*s != '*' && *s != Star && *s != '@' && *s != '{' &&
X	*s != Inbrace && *s != '=' && *s != Equals && *s != Hat &&
X	*s != '^' &&
X	*s != '+') {
X	s[-1] = '$';
X	return 1;
X    }
X    if ((brs = (*s == '{' || *s == Inbrace))) {
X	s++;
X
X	if (*s == '(' || *s == Inpar) {
X	    char *t, sav, *d;
X	    int tt = 0;
X	    long num;
X
X	    for (s++; *s != ')' && *s != Outpar; s++, tt = 0) {
X		switch (*s) {
X		case ')':
X		case Outpar:
X		    break;
X		case 'M':
X		    flags |= 8;
X		    break;
X		case 'R':
X		    flags |= 16;
X		    break;
X		case 'B':
X		    flags |= 32;
X		    break;
X		case 'E':
X		    flags |= 64;
X		    break;
X		case 'N':
X		    flags |= 128;
X		    break;
X		case 'S':
X		    substr = 1;
X		    break;
X		case 'I':
X		    flnum = 0;
X		    t = get_strarg(++s);
X		    if (*t) {
X			sav = *t;
X			*t = '\0';
X			d = dupstring(s + 1);
X			untokenize(d);
X			if ((flnum = mathevalarg(s + 1, &d)) < 0)
X			    flnum = -flnum;
X			*t = sav;
X			s = t;
X		    } else
X			goto flagerr;
X		    break;
X
X		case 'L':
X		    casmod = 2;
X		    break;
X		case 'U':
X		    casmod = 1;
X		    break;
X		case 'C':
X		    casmod = 3;
X		    break;
X
X		case 'o':
X		    sortit = 1;
X		    break;
X		case 'O':
X		    sortit = 2;
X		    break;
X		case 'i':
X		    casind = 1;
X		    break;
X
X		case 'c':
X		    whichlen = 1;
X		    break;
X		case 'w':
X		    whichlen = 2;
X		    break;
X
X		case 's':
X		    tt = 1;
X		/* fall through */
X		case 'j':
X		    t = get_strarg(++s);
X		    if (*t) {
X			sav = *t;
X			*t = '\0';
X			if (tt)
X			    spsep = dupstring(s + 1);
X			else
X			    sep = dupstring(s + 1);
X			*t = sav;
X			s = t;
X		    } else
X			goto flagerr;
X		    break;
X
X		case 'l':
X		    tt = 1;
X		/* fall through */
X		case 'r':
X		    t = get_strarg(++s);
X		    if (!*t)
X			goto flagerr;
X		    sav = *t;
X		    *t = '\0';
X		    d = dupstring(s + 1);
X		    untokenize(d);
X		    if ((num = mathevalarg(d, &d)) < 0)
X			num = -num;
X		    if (tt)
X			prenum = num;
X		    else
X			postnum = num;
X		    *t = sav;
X		    sav = *s;
X		    s = t + 1;
X		    if (*s != sav) {
X			s--;
X			break;
X		    }
X		    t = get_strarg(s);
X		    if (!*t)
X			goto flagerr;
X		    sav = *t;
X		    *t = '\0';
X		    if (tt)
X			premul = dupstring(s + 1);
X		    else
X			postmul = dupstring(s + 1);
X		    *t = sav;
X		    sav = *s;
X		    s = t + 1;
X		    if (*s != sav) {
X			s--;
X			break;
X		    }
X		    t = get_strarg(s);
X		    if (!*t)
X			goto flagerr;
X		    sav = *t;
X		    *t = '\0';
X		    if (tt)
X			preone = dupstring(s + 1);
X		    else
X			postone = dupstring(s + 1);
X		    *t = sav;
X		    s = t;
X		    break;
X
X		default:
X		  flagerr:
X		    zerr("error in flags", NULL, 0);
X		    return 1;
X		}
X	    }
X	    s++;
X	}
X    }
X    if (sortit && casind)
X	sortit |= (casind << 1);
X
X    if (!premul)
X	premul = " ";
X    if (!postmul)
X	postmul = " ";
X
X    for (;;) {
X	if (*s == '^' || *s == Hat)
X	    plan9 ^= 1, s++;
X	else if (*s == '=' || *s == Equals)
X	    spbreak ^= 1, s++;
X	else if ((*s == '#' || *s == Pound) && (iident(s[1])
X						|| s[1] == '*' || s[1] == Star || s[1] == '@'
X						|| (isstring(s[1]) && isbrace(s[2]) && iident(s[3]))))
X	    getlen = 1 + whichlen, s++;
X	else if (*s == '~' || *s == Tilde)
X	    globsubst ^= 1, s++;
X	else if (*s == '+' && iident(s[1]))
X	    chkset = 1, s++;
X	else
X	    break;
X    }
X    globsubst = globsubst && !(qt & 1);
X
X    idbeg = s;
X    if (isstring(*s) && isbrace(s[1])) {
X	int bct, sav;
X
X	val = s;
X	for (bct = 1, s += 2; *s && bct; ++s)
X	    if (*s == Inbrace || *s == '{')
X		++bct;
X	    else if (*s == Outbrace || *s == '}')
X		--bct;
X	sav = *s;
X	*s = 0;
X	singsub(&val);
X	*s = sav;
X	isarr = 0;
X	v = (Value) NULL;
X    } else if (!(v = getvalue(&s, 1))) {
X	vunset = 1;
X    } else if ((isarr = v->isarr)) {
X	aval = getarrvalue(v);
X	if (qt && ((qt & 1) || !getlen) && isarr > 0) {
X	    val = sepjoin(aval, sep);
X	    isarr = 0;
X	}
X    } else {
X	if (v->pm->flags & PMFLAG_A) {
X	    int tmplen = arrlen(v->pm->gets.afn(v->pm));
X
X	    if (v->a < 0)
X		v->a += tmplen + v->inv;
X	    if (!v->inv && (v->a >= tmplen || v->a < 0))
X		vunset = 1;
X	}
X	if (!vunset) {
X	    val = getstrvalue(v);
X	    fwidth = v->pm->ct ? v->pm->ct : strlen(val);
X	    switch (v->pm->flags & (PMFLAG_L | PMFLAG_R | PMFLAG_Z)) {
X		char *t;
X		int t0;
X
X	    case PMFLAG_L:
X	    case PMFLAG_L | PMFLAG_Z:
X		t = val;
X		if (v->pm->flags & PMFLAG_Z)
X		    while (*t == '0')
X			t++;
X		else
X		    while (isep(*t))
X			t++;
X		val = (char *)ncalloc(fwidth + 1);
X		val[fwidth] = '\0';
X		if ((t0 = strlen(t)) > fwidth)
X		    t0 = fwidth;
X		memset(val, ' ', fwidth);
X		strncpy(val, t, t0);
X		break;
X	    case PMFLAG_R:
X	    case PMFLAG_Z:
X	    case PMFLAG_Z | PMFLAG_R:
X		if (strlen(val) < fwidth) {
X		    t = (char *)ncalloc(fwidth + 1);
X		    memset(t, (v->pm->flags & PMFLAG_R) ? ' ' : '0', fwidth);
X		    if ((t0 = strlen(val)) > fwidth)
X			t0 = fwidth;
X		    strcpy(t + (fwidth - t0), val);
X		    val = t;
X		} else {
X		    t = (char *)ncalloc(fwidth + 1);
X		    t[fwidth] = '\0';
X		    strncpy(t, val + strlen(val) - fwidth, fwidth);
X		    val = t;
X		}
X		break;
X	    }
X	    switch (v->pm->flags & (PMFLAG_l | PMFLAG_u)) {
X		char *t;
X
X	    case PMFLAG_l:
X		t = val;
X		for (; *t; t++)
X		    *t = tulower(*t);
X		break;
X	    case PMFLAG_u:
X		t = val;
X		for (; *t; t++)
X		    *t = tuupper(*t);
X		break;
X	    }
X	}
X    }
X    idend = s;
X    if ((colf = *s == ':'))
X	s++;
X
X/* check for ${..?...} or ${..=..} or one of those.  Only works
X		if the name is in braces. */
X
X    if (brs && (*s == '-' || *s == '=' || *s == Equals || *s == '?' ||
X		*s == '+' || *s == '#' || *s == '%' || *s == Quest || *s == Pound)) {
X
X	if (!flnum)
X	    flnum++;
X	if (*s == '%')
X	    flags |= 1;
X
X	if ((*s == '%' || *s == '#' || *s == Pound) && *s == s[1]) {
X	    s++;
X	    doub = 1;
X	}
X	u = ++s;
X
X	flags |= (doub | (substr << 1)) << 1;
X	if (!(flags & 0xf8))
X	    flags |= 16;
X
X	if (brs) {
X	    int bct = 1;
X
X	    for (;;) {
X		if (*s == '{' || *s == Inbrace)
X		    bct++;
X		else if (*s == '}' || *s == Outbrace)
X		    bct--;
X		if (!bct || !*s)
X		    break;
X		s++;
X	    }
X	} else {
X	    while (*s++);
X	    s--;
X	}
X	if (*s)
X	    *s++ = '\0';
X	if (colf && !vunset)
X	    vunset = (isarr) ? !*aval : !*val;
X
X	switch ((int)(unsigned char)u[-1]) {
X	case '-':
X	    if (vunset)
X		val = dupstring(u), isarr = 0;
X	    break;
X	case '=':
X	case (int)STOUC(Equals):
X	    if (vunset) {
X		char sav = *idend;
X
X		*idend = '\0';
X		val = dupstring(u);
X		singsub(&val);
X		setsparam(idbeg, ztrdup(val));
X		*idend = sav;
X		isarr = 0;
X	    }
X	    break;
X	case '?':
X	case (int)STOUC(Quest):
X	    if (vunset) {
X		char *msg;
X
X		*idend = '\0';
X		msg = tricat(idbeg, ": ", *u ? u : "parameter not set");
X		zerr("%s", msg, 0);
X		zsfree(msg);
X		if (!interact)
X		    exit(1);
X		return 1;
X	    }
X	    break;
X	case '+':
X	    if (vunset)
X		val = dupstring("");
X	    else
X		val = dupstring(u);
X	    isarr = 0;
X	    break;
X	case '%':
X	case '#':
X	case (int)STOUC(Pound):
X	    if (qt & 1)
X		tokenize(u);
X
X	    if (!vunset && v && v->isarr) {
X		char **ap = aval;
X		char **pp = aval = (char **)ncalloc(sizeof(char *) * (arrlen(aval) + 1));
X
X		singsub(&u);
X		while ((*pp = *ap++)) {
X		    getmatch(pp, u, flags, flnum);
X		    pp++;
X		}
X		if (!isarr)
X		    val = sepjoin(aval, sep);
X	    } else {
X		if (vunset)
X		    val = dupstring("");
X		singsub(&u);
X		getmatch(&val, u, flags, flnum);
X	    }
X	    break;
X	}
X    } else {			/* no ${...=...} or anything, but possible modifiers. */
X	if (chkset) {
X	    val = dupstring(vunset ? "0" : "1");
X	    isarr = 0;
X	} else if (vunset) {
X	    if (isset(NOUNSET)) {
X		*idend = '\0';
X		zerr("%s: parameter not set", idbeg, 0);
X		return 1;
X	    }
X	    val = dupstring("");
X	}
X	if (colf) {
X	    s--;
X	    if (!isarr)
X		modify(&val, &s);
X	    else {
X		char *ss = s;
X		char **ap = aval;
X		char **pp = aval = (char **)ncalloc(sizeof(char *) * (arrlen(aval) + 1));
X
X		while ((*pp = *ap++)) {
X		    ss = s;
X		    modify(pp++, &ss);
X		}
X		s = ss;
X	    }
X	}
X	if (brs) {
X	    if (*s != '}' && *s != Outbrace) {
X		zerr("closing brace expected", NULL, 0);
X		return 1;
X	    }
X	    s++;
X	}
X    }
X    if (errflag)
X	return 1;
X    if (getlen) {
X	long len = 0;
X	char buf[14];
X
X	if (isarr) {
X	    char **ctr;
X	    int sl = sep ? strlen(sep) : 1;
X
X	    if (getlen == 1)
X		for (ctr = aval; *ctr; ctr++, len++);
X	    else if (getlen == 2)
X		for (len = -sl, ctr = aval; *ctr; len += sl + strlen(*ctr), ctr++);
X	    else
X		for (ctr = aval;
X		     *ctr;
X		     len += wordcount(*ctr, sep, getlen > 3), ctr++);
X	} else {
X	    if (getlen < 3)
X		len = strlen(val);
X	    else
X		len = wordcount(val, sep, getlen > 3);
X	}
X
X	sprintf(buf, "%ld", len);
X	val = dupstring(buf);
X	isarr = 0;
X    }
X    if (isarr > 0 && !plan9 && (!aval || !aval[0])) {
X	val = dupstring("");
X	isarr = 0;
X    } else if (isarr && aval && aval[0] && !aval[1]) {
X	val = aval[0];
X	isarr = 0;
X    }
X    if (!qt && (spbreak || spsep || sep)) {
X	if (isarr)
X	    val = sepjoin(aval, sep);
X	if (spbreak || spsep) {
X	    isarr = 1;
X	    aval = sepsplit(val, spsep);
X	    if (!aval || !aval[0]) {
X		val = dupstring("");
X		isarr = 0;
X	    } else if (!aval[1]) {
X		val = aval[0];
X		isarr = 0;
X	    }
X	} else
X	    isarr = 0;
X    }
X    if (casmod) {
X	if (isarr) {
X	    char **ap;
X
X	    ap = aval = arrdup(aval);
X	    copied = 1;
X
X	    if (casmod == 1)
X		for (; *ap; ap++)
X		    makeuppercase(ap);
X	    else if (casmod == 2)
X		for (; *ap; ap++)
X		    makelowercase(ap);
X	    else
X		for (; *ap; ap++)
X		    makecapitals(ap);
X
X	} else {
X	    val = dupstring(val);
X	    copied = 1;
X	    if (casmod == 1)
X		makeuppercase(&val);
X	    else if (casmod == 2)
X		makelowercase(&val);
X	    else
X		makecapitals(&val);
X	}
X    }
X    if (isarr) {
X	char *x;
X	char *y;
X	int xlen;
X	int i;
X
X	if (!aval[0]) {
X	    if (plan9)
X		return 0;
X	    y = (char *)ncalloc((aptr - bptr) + strlen(s) + 1);
X	    strcpy(y, ostr);
X	    strcat(y, s);
X	    remnulargs(y);
X	    if (INULL(*y))
X		return 0;
X	    else {
X		setdata(n, (vptr) y);
X		return 1;
X	    }
X	}
X	if (sortit && !copied)
X	    aval = arrdup(aval);
X	if (sortit == 1)
X	    qsort(aval, arrlen(aval), sizeof(char *), (int (*)())strpcmp);
X
X	else if (sortit == 2)
X	    qsort(aval, arrlen(aval), sizeof(char *), (int (*)())invstrpcmp);
X
X	else if (sortit == 3)
X	    qsort(aval, arrlen(aval), sizeof(char *), (int (*)())cstrpcmp);
X
X	else if (sortit)
X	    qsort(aval, arrlen(aval), sizeof(char *), (int (*)())invcstrpcmp);
X
X	if (plan9) {
X	    int dlen;
X
X	    dlen = (aptr - bptr) + strlen(s) + 1;
X	    i = 0;
X	    while (aval[i]) {
X		x = aval[i++];
X		if (prenum || postnum)
X		    x = dopadding(x, prenum, postnum, preone, postone,
X				  premul, postmul);
X		if (qt && !*x) {
X		    x = nulstring;
X		    xlen = nulstrlen;
X		} else
X		    xlen = strlen(x);
X		y = (char *)ncalloc(dlen + xlen);
X		strcpy(y, ostr);
X		strcatsub(y, x, globsubst);
X		strcat(y, s);
X		if (i == 1)
X		    setdata(n, (vptr) y);
X		else
X		    insnode(l, n, (vptr) y), incnode(n);
X	    }
X	} else {
X	    x = aval[0];
X	    if (prenum || postnum)
X		x = dopadding(x, prenum, postnum, preone, postone,
X			      premul, postmul);
X	    if (qt && !*x) {
X		x = nulstring;
X		xlen = nulstrlen;
X	    } else
X		xlen = strlen(x);
X	    y = (char *)ncalloc((aptr - bptr) + xlen + 1);
X	    strcpy(y, ostr);
X	    strcatsub(y, x, globsubst);
X	    setdata(n, (vptr) y);
X
X	    i = 1;
X	    while (aval[i] && aval[i + 1]) {
X		x = aval[i++];
X		if (prenum || postnum)
X		    x = dopadding(x, prenum, postnum, preone, postone,
X				  premul, postmul);
X		if (qt && !*x)
X		    y = dupstring(nulstring);
X		else if (globsubst) {
X		    y = (char *)ncalloc(strlen(x) + 1);
X		    *y = '\0';
X		    strcatsub(y, x, 1);
X		} else
X		    y = x;
X		insnode(l, n, (vptr) y), incnode(n);
X	    }
X
X	    x = aval[i];
X	    if (prenum || postnum)
X		x = dopadding(x, prenum, postnum, preone, postone,
X			      premul, postmul);
X	    if (qt && !*x) {
X		x = nulstring;
X		xlen = nulstrlen;
X	    } else
X		xlen = strlen(x);
X	    y = (char *)ncalloc(xlen + strlen(s) + 1);
X	    strcpy(y, x);
X	    strcat(y, s);
X	    insnode(l, n, (vptr) y);
X	}
X    } else {
X	int xlen;
X	char *x;
X	char *y;
X
X	x = val;
X	if (prenum || postnum)
X	    x = dopadding(x, prenum, postnum, preone, postone,
X			  premul, postmul);
X	if (qt && !*x) {
X	    x = nulstring;
X	    xlen = nulstrlen;
X	} else
X	    xlen = strlen(x);
X	y = (char *)ncalloc((aptr - bptr) + xlen + strlen(s) + 1);
X	strcpy(y, ostr);
X	strcatsub(y, x, globsubst);
X	strcat(y, s);
X	setdata(n, (vptr) y);
X    }
X
X    return 1;
X}
X
X/* arithmetic substitution */
X
Xvoid arithsubst(aptr, bptr)	/**/
Xvptr *aptr;
Xchar **bptr;
X{
X    char *s = (char *)*aptr, *t, buf[16];
X    long v;
X
X    *s = '\0';
X    for (; *s != Outbrack; s++);
X    *s++ = '\0';
X    v = matheval((char *)*aptr + 2);
X    sprintf(buf, "%ld", v);
X    t = (char *)ncalloc(strlen(*bptr) + strlen(buf) + strlen(s) + 1);
X    strcpy(t, *bptr);
X    strcat(t, buf);
X    strcat(t, s);
X    *bptr = t;
X}
X
Xvoid modify(str, ptr)		/**/
Xchar **str;
Xchar **ptr;
X{
X    char *ptr1, *ptr2, *ptr3, del, *lptr, c, *test, *sep, *t, *tt, tc, *e;
X    char *copy, *all, *tmp, sav;
X    int gbal, wall, rec, al, nl;
X
X    test = NULL;
X
X    if (**ptr == ':')
X	*str = dupstring(*str);
X
X    while (**ptr == ':') {
X	lptr = *ptr;
X	(*ptr)++;
X	wall = gbal = 0;
X	rec = 1;
X	c = '\0';
X	sep = NULL;
X
X	for (; !c && **ptr;) {
X	    switch (**ptr) {
X	    case 'h':
X	    case 'r':
X	    case 'e':
X	    case 't':
X	    case 'l':
X	    case 'u':
X		c = **ptr;
X		break;
X
X	    case 's':
X		c = **ptr;
X		(*ptr)++;
X		zsfree(hsubl);
X		zsfree(hsubr);
X		ptr1 = *ptr;
X		del = *ptr1++;
X		for (ptr2 = ptr1; *ptr2 != del && *ptr2; ptr2++);
X		if (!*ptr2) {
X		    zerr("bad subtitution", NULL, 0);
X		    return;
X		}
X		*ptr2++ = '\0';
X		for (ptr3 = ptr2; *ptr3 != del && *ptr3; ptr3++);
X		if ((sav = *ptr3))
X		    *ptr3++ = '\0';
X		for (tt = hsubl = ztrdup(ptr1); *tt; tt++)
X		    if (INULL(*tt))
X			chuck(tt);
X		for (tt = hsubr = ztrdup(ptr2); *tt; tt++)
X		    if (INULL(*tt))
X			chuck(tt);
X		ptr2[-1] = del;
X		if (sav)
X		    ptr3[-1] = sav;
X		*ptr = ptr3 - 1;
X		break;
X
X	    case '&':
X		c = 's';
X		break;
X
X	    case 'g':
X		(*ptr)++;
X		gbal = 1;
X		break;
X
X	    case 'w':
X		wall = 1;
X		(*ptr)++;
X		break;
X	    case 'W':
X		wall = 1;
X		(*ptr)++;
X		ptr1 = get_strarg(ptr2 = *ptr);
X		if ((sav = *ptr1))
X		    *ptr1 = '\0';
X		sep = dupstring(ptr2 + 1);
X		if (sav)
X		    *ptr1 = sav;
X		*ptr = ptr1 + 1;
X		c = '\0';
X		break;
X
X	    case 'f':
X		rec = -1;
X		(*ptr)++;
X		break;
X	    case 'F':
X		rec = -1;
X		(*ptr)++;
X		ptr1 = get_strarg(ptr2 = *ptr);
X		if ((sav = *ptr1))
X		    *ptr1 = '\0';
X		ptr2 = dupstring(ptr2 + 1);
X		if (sav)
X		    *ptr1 = sav;
X		untokenize(ptr2);
X		rec = mathevalarg(ptr2, &ptr2);
X		*ptr = ptr1 + 1;
X		c = '\0';
X		break;
X	    default:
X		*ptr = lptr;
X		return;
X	    }
X	}
X	(*ptr)++;
X	if (!c) {
X	    *ptr = lptr;
X	    return;
X	}
X	if (rec < 0)
X	    test = dupstring(*str);
X
X	while (rec--) {
X	    if (wall) {
X		al = 0;
X		all = NULL;
X		for (t = e = *str; (tt = findword(&e, sep));) {
X		    tc = *e;
X		    *e = '\0';
X		    copy = dupstring(tt);
X		    *e = tc;
X		    switch (c) {
X		    case 'h':
X			remtpath(&copy);
X			break;
X		    case 'r':
X			remtext(&copy);
X			break;
X		    case 'e':
X			rembutext(&copy);
X			break;
X		    case 't':
X			remlpaths(&copy);
X			break;
X		    case 'l':
X			downcase(&copy);
X			break;
X		    case 'u':
X			upcase(&copy);
X			break;
X		    case 's':
X			if (hsubl && hsubr)
X			    subst(&copy, hsubl, hsubr, gbal);
X			break;
X		    }
X		    tc = *tt;
X		    *tt = '\0';
X		    nl = al + strlen(t) + strlen(copy);
X		    ptr1 = tmp = (char *)halloc(nl + 1);
X		    if (all)
X			for (ptr2 = all; *ptr2;)
X			    *ptr1++ = *ptr2++;
X		    for (ptr2 = t; *ptr2;)
X			*ptr1++ = *ptr2++;
X		    *tt = tc;
X		    for (ptr2 = copy; *ptr2;)
X			*ptr1++ = *ptr2++;
X		    *ptr1 = '\0';
X		    al = nl;
X		    all = tmp;
X		    t = e;
X		}
X		*str = all;
X
X	    } else {
X		switch (c) {
X		case 'h':
X		    remtpath(str);
X		    break;
X		case 'r':
X		    remtext(str);
X		    break;
X		case 'e':
X		    rembutext(str);
X		    break;
X		case 't':
X		    remlpaths(str);
X		    break;
X		case 'l':
X		    downcase(str);
X		    break;
X		case 'u':
X		    upcase(str);
X		    break;
X		case 's':
X		    if (hsubl && hsubr) {
X			char *oldstr = *str;
X
X			subst(str, hsubl, hsubr, gbal);
X			if (*str != oldstr) {
X			    *str = dupstring(oldstr = *str);
X			    zsfree(oldstr);
X			}
X		    }
X		    break;
X		}
X	    }
X	    if (rec < 0) {
X		if (!strcmp(test, *str))
X		    rec = 0;
X		else
X		    test = dupstring(*str);
X	    }
X	}
X    }
X}
X
X/* get a directory stack entry */
X
Xchar *dstackent(val)		/**/
Xint val;
X{
X    Lknode node;
X
X    if ((val < 0 && !firstnode(dirstack)) || !val--)
X	return pwd;
X    if (val < 0)
X	node = lastnode(dirstack);
X    else
X	for (node = firstnode(dirstack); node && val; val--, incnode(node));
X    if (!node) {
X	if (!isset(NONOMATCH))
X	    zerr("not enough dir stack entries.", NULL, 0);
X	return NULL;
X    }
X    return (char *)getdata(node);
X}
X
X/* make an alias hash table node */
X
Xstruct alias *mkanode(txt, cmflag)	/**/
Xchar *txt;
Xint cmflag;
X{
X    struct alias *ptr = (Alias) zcalloc(sizeof *ptr);
X
X    ptr->text = txt;
X    ptr->cmd = cmflag;
X    ptr->inuse = 0;
X    return ptr;
X}
END_OF_FILE
  if test 30409 -ne `wc -c <'zsh-2.5.0/src/subst.c'`; then
    echo shar: \"'zsh-2.5.0/src/subst.c'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/src/subst.c'
fi
if test -f 'zsh-2.5.0/src/ztype.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/src/ztype.h'\"
else
  echo shar: Extracting \"'zsh-2.5.0/src/ztype.h'\" \(1479 characters\)
  sed "s/^X//" >'zsh-2.5.0/src/ztype.h' <<'END_OF_FILE'
X/*
X *
X * ztype.h - character classification macros
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made.
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk.
X *
X */
X
X#define IDIGIT  1
X#define IALNUM  2
X#define IBLANK  4
X#define INBLANK 8
X#define ITOK    16
X#define ISEP    32
X#define IALPHA  64
X#define IIDENT  128
X#define IUSER   256
X#define ICNTRL  512
X#define IWORD	 1024
X#define ISPECIAL 2048
X#define _icom(X,Y) (typtab[(int) (unsigned char) (X)] & Y)
X#define idigit(X) _icom(X,IDIGIT)
X#define ialnum(X) _icom(X,IALNUM)
X#define iblank(X) _icom(X,IBLANK)	/* blank, not including \n */
X#define inblank(X) _icom(X,INBLANK)	/* blank or \n */
X#define itok(X) _icom(X,ITOK)
X#define isep(X) _icom(X,ISEP)
X#define ialpha(X) _icom(X,IALPHA)
X#define iident(X) _icom(X,IIDENT)
X#define iuser(X) _icom(X,IUSER)	/* username char */
X#define icntrl(X) _icom(X,ICNTRL)
X#define iword(X) _icom(X,IWORD)
X#define ispecial(X) _icom(X,ISPECIAL)
X
XEXTERN short int typtab[256];
END_OF_FILE
  if test 1479 -ne `wc -c <'zsh-2.5.0/src/ztype.h'`; then
    echo shar: \"'zsh-2.5.0/src/ztype.h'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/src/ztype.h'
fi
echo shar: End of archive 10 \(of 18\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
