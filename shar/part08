Path: news.csc.fi!news.eunet.fi!EU.net!uunet!sparky!not-for-mail
From: zsh-list@sterling.com (Bas de Bakker)
Newsgroups: comp.sources.misc
Subject: v43i097:  zsh - The Z shell, version 2.5.0, Part08/18
Followup-To: comp.sources.d
Date: 13 Jul 1994 23:04:19 -0500
Organization: Sterling Software
Lines: 3020
Sender: kent@sparky.sterling.com
Approved: kent@sparky.sterling.com
Message-ID: <302dg3$t24@sparky.sterling.com>
References: <csm-v43i089=zsh.230017@sparky.sterling.com>
NNTP-Posting-Host: sparky.sterling.com
X-Md4-Signature: 6da8012f56150e0532b736b48e1d3bde

Submitted-by: zsh-list@sterling.com (Bas de Bakker)
Posting-number: Volume 43, Issue 97
Archive-name: zsh/part08
Environment: UNIX
Supersedes: zsh: Volume 35, Issue 51-72

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  zsh-2.5.0/NEWS zsh-2.5.0/doc/zsh.texi.B
#   zsh-2.5.0/src/zle_main.c
# Wrapped by kent@sparky on Tue Jul 12 16:47:21 1994
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 8 (of 18)."'
if test -f 'zsh-2.5.0/NEWS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/NEWS'\"
else
  echo shar: Extracting \"'zsh-2.5.0/NEWS'\" \(2009 characters\)
  sed "s/^X//" >'zsh-2.5.0/NEWS' <<'END_OF_FILE'
XNew features in zsh version 2.5
X
XGreatly expanded completion possibilities.  Programmable completion
Xallows detailed control over what arguments of what commands can be
Xcompleted to what.  See dots/zcomp in the distribution for examples.
X
XExpand filenames with ~ and = on the right hand side of parameter
Xassignments.  New option MAGIC_EQUAL_SUBST to do it in all
Xidentifier=expression arguments.
X
X${+name} becomes 1 or 0 if name is set or unset.  ${~spec} toggles
XGLOB_SUBST in substitution.  Parameter substitution takes lots
Xof flags in the format ${(flags)name}.
X
XNew glob qualifiers for block/character special files, times in glob
Xqualifiers can be in months, weeks, days, hours, minutes.  Qualifiers
Xcan work on links or on what they point to.  Qualifiers separated by
Xcommas are or-ed.
X
XNew parameter substitution modifiers (fFwW) to repeat actions.  New
Xoption CSH_JUNKIE_HISTORY.
X
XNew line editor functions history-beginning-search-backward,
Xhistory-beginning-search-forward, expand-or-complete-prefix,
Xpush-input, push-line-or-edit.
X
XAssign to part of a string, use qualifiers on string subscription with
X$foo[(qual)2,5]
X
XNew parameters: EGID, EUID, KEYTIMEOUT
X
XNew prompt escape sequence %_ to get constructs like for and while in
Xthe secondary prompt.  %E in prompt clears to end of screen.
X
XConditional expressions in PROMPT and WATCHFMT.
X
XNew options ALWAYS_LAST_PROMPT, ALWAYS_TO_END, AUTO_PARAM_KEYS,
XCOMPLETE_ALIASES, COMPLETE_IN_WORD, CSH_JUNKIE_HISTORY,
XGLOB_SUBST, LIST_AMBIGOUS, MAGIC_EQUAL_SUBST, NO_FLOW_CONTROL,
XPROMPT_SUBST
X
XNew option -m to many builtins makes arguments subject to pattern
Xmatching.
X
XBindkey can now bind both key sequences and prefixes of those.  You
Xcan for example bind ESC and function keys sending ESC sequences.
X
XAdditional options to read builtin to use in functions called by
Xcompletion.
X
XNew options to print to sort arguments and print them in columns.
X
XSome additional resource limits can be specified.
X
XSome editor functions now work in the minibuffer.
END_OF_FILE
  if test 2009 -ne `wc -c <'zsh-2.5.0/NEWS'`; then
    echo shar: \"'zsh-2.5.0/NEWS'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/NEWS'
fi
if test -f 'zsh-2.5.0/doc/zsh.texi.B' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/doc/zsh.texi.B'\"
else
  echo shar: Extracting \"'zsh-2.5.0/doc/zsh.texi.B'\" \(57479 characters\)
  sed "s/^X//" >'zsh-2.5.0/doc/zsh.texi.B' <<'END_OF_FILE'
X@vindex TERM
X@pindex SINGLE_LINE_ZLE, use of
X@cindex ksh, editor mode
X@cindex editor, modes
X@noindent
XThere are two display modes.  The first, multiline mode, is the default.
XIt only works if the @code{TERM} parameter is set to a valid terminal
Xtype that can move the cursor up.  The second, single line mode, is used
Xif @code{TERM} is invalid or incapable of moving the cursor up, or if
Xthe @code{SINGLE_LINE_ZLE} option is set.  This mode is similar to ksh,
Xand uses no termcap sequences.  If @code{TERM} is @samp{emacs}, the
X@code{ZLE} option will be unset by the shell.@refill
X
X@cindex bindings, key
X@cindex key bindings
X@findex bindkey, use of
X@vindex VISUAL
X@vindex EDITOR
X@noindent
XCommand bindings may be set using the @code{bindkey} builtin.  There are
Xtwo keymaps---the main keymap and the alternate keymap.  The alternate
Xkeymap is bound to vi command mode.  The main keymap is bound to emacs
Xmode by default.  To bind the main keymap to vi insert mode, use
X@code{bindkey -v}.  However, if either of
Xthe @code{VISUAL} or @code{EDITOR} environment variables contains the
Xstring @samp{vi} when the shell starts up the main keymap will be bound
Xto vi insert mode by default.@refill
X
X@noindent
XThe following is a list of all the key commands and their default
Xbindings in emacs and vi command mode.
X
X@menu
X* Movement::			
X* History Control::		
X* Modifying Text::		
X* Arguments::			
X* Completion::			
X* Miscellaneous::		
X@end menu
X
X@node Movement, History Control,  , Zsh Line Editor
X@section Movement
X
X@table @code
X@tindex vi-backward-blank-word
X@kindex B
X@item vi-backward-blank-word (unbound) (@kbd{B})
XMove backward one word, where a word is defined as a series of non-blank
Xcharacters.
X
X@tindex backward-char
X@kindex CTRL-B
X@kindex ESC-[D
X@item backward-char (@kbd{^B} @kbd{ESC-[D})
XMove backward one character.
X
X@tindex vi-backward-char
X@kindex ESC-B
X@kindex ESC-b
X@item vi-backward-char (unbound) (@kbd{h})
XMove backward one character, without changing lines.
X
X@tindex backward-word
X@item backward-word (@kbd{ESC-B} @kbd{ESC-b})
XMove to the beginning of the previous word.
X
X@tindex emacs-backward-word
X@item emacs-backward-word
XMove to the beginning of the previous word.
X
X@tindex vi-backward-word
X@kindex b
X@item vi-backward-word (unbound) (@kbd{b})
XMove to the beginning of the previous word, vi-style.
X
X@tindex beginning-of-line
X@kindex CTRL-A
X@kindex 0
X@item beginning-of-line (@kbd{^A}) (@kbd{0})
XMove to the beginning of the line.  If already at the beginning of the
Xline, move to the beginning of the previous line, if any.
X
X@tindex vi-beginning-of-line
X@item vi-beginning-of-line
XMove to the beginning of the line, without changing lines.
X
X@tindex end-of-line
X@kindex CTRL-E
X@item end-of-line (@kbd{^E})
XMove to the end of the line.  If already at the end of the line, move to
Xthe end of the next line, if any.
X
X@tindex vi-end-of-line
X@kindex $
X@item vi-end-of-line (unbound) (@kbd{$})
XMove to the end of the line.
X
X@tindex vi-forward-blank-word
X@kindex W
X@item vi-forward-blank-word (unbound) (@kbd{W})
XMove forward one word, where a word is defined as a series of non-blank
Xcharacters.
X
X@tindex vi-forward-blank-word-end
X@kindex E
X@item vi-forward-blank-word-end (unbound) (@kbd{E})
XMove to the end of the current word, or, if at the end of the current
Xword, to the end of the next word, where a word is defined as a series
Xof non-blank characters.
X
X@tindex forward-char
X@kindex CTRL-F
X@kindex ESC-[C
X@item forward-char (@kbd{^F} @kbd{ESC-[C})
XMove forward one character.
X
X@tindex vi-forward-char
X@kindex l
X@kindex SPACE
X@item vi-forward-char (unbound) (@key{SPACE} @kbd{l})
XMove forward one character.
X
X@tindex vi-find-next-char
X@kindex CTRL-X CTRL-F
X@kindex f
X@item vi-find-next-char (@kbd{^X^F}) (@kbd{f})
XRead a character from the keyboard, and move to the next occurrence of
Xit in the line.
X
X@tindex vi-find-next-char-skip
X@kindex t
X@item vi-find-next-char-skip (unbound) (@kbd{t})
XRead a character from the keyboard, and move to the position just before
Xthe next occurrence of it in the line.
X
X@tindex vi-find-prev-char
X@kindex F
X@item vi-find-prev-char (unbound) (@kbd{F})
XRead a character from the keyboard, and move to the previous occurrence
Xof it in the line.
X
X@tindex vi-find-prev-char-skip
X@kindex T
X@item vi-find-prev-char-skip (unbound) (@kbd{T})
XRead a character from the keyboard, and move to the position just after
Xthe previous occurrence of it in the line.
X
X@tindex vi-first-non-blank
X@kindex ^
X@item vi-first-non-blank (unbound) (@kbd{^})
XMove to the first non-blank character in the line.
X
X@tindex vi-forward-word
X@kindex w
X@item vi-forward-word (unbound) (@kbd{w})
XMove forward one word, vi-style.
X
X@tindex forward-word
X@kindex ESC-F
X@kindex ESC-f
X@item forward-word (@kbd{ESC-F} @kbd{ESC-f})
XMove to the beginning of the next word.  The editor's idea of a word is
Xspecified with the @code{WORDCHARS} parameter.@refill
X
X@tindex emacs-forward-word
X@item emacs-forward-word
XMove to the end of the next word.
X
X@tindex vi-forward-word-end
X@kindex e
X@item vi-forward-word-end (unbound) (@kbd{e})
XMove to the end of the next word.
X
X@tindex vi-goto-column
X@kindex ESC-|
X@kindex |
X@item vi-goto-column (@kbd{ESC-|}) (@kbd{|})
XMove to the column specified by the numeric argument.
X
X@tindex vi-goto-mark
X@kindex `
X@item vi-goto-mark (unbound) (@kbd{`})
XMove to the specified mark.
X
X@tindex vi-goto-mark-line
X@kindex '
X@item vi-goto-mark-line (unbound) (@kbd{'})
XMove to the beginning of the line containing the specified mark.
X
X@tindex vi-repeat-find
X@kindex ;
X@item vi-repeat-find (unbound) (@kbd{;})
XRepeat the last @code{vi-find} command.
X
X@tindex vi-rev-repeat-find
X@kindex ,
X@item vi-rev-repeat-find (unbound) (@kbd{,})
XRepeat the last @code{vi-find} command in the opposite direction.
X@end table
X
X@node History Control, Modifying Text, Movement, Zsh Line Editor
X@section History Control
X
X@table @code
X@tindex beginning-of-buffer-or-history
X@kindex ESC-<
X@item beginning-of-buffer-or-history (@kbd{ESC-<})
XMove to the beginning of the buffer, or if already there, move to the
Xfirst event in the history list.
X
X@tindex beginning-of-line-hist
X@item beginning-of-line-hist
XMove to the beginning of the line.  If already at the beginning of the
Xbuffer, move to the previous history line.
X
X@tindex beginning-of-history
X@item beginning-of-history
XMove to the first event in the history list.
X
X@tindex down-line-or-history
X@kindex CTRL-N
X@kindex ESC-[B
X@kindex +
X@kindex j
X@item down-line-or-history (@kbd{^N} @kbd{ESC-[B}) (@kbd{+} @kbd{j})
XMove down a line in the buffer, or if already at the bottom line, move
Xto the next event in the history list.
X
X@tindex down-line-or-search
X@item down-line-or-search
XMove down a line in the buffer, or if already at the bottom line,
Xsearch forward in the history for a line beginning with the first
Xword in the buffer.
X
X@tindex down-history
X@kindex CTRL-N
X@item down-history (unbound) (@kbd{^N})
XMove to the next event in the history list.
X
X@tindex history-beginning-search-backward
X@item history-beginning-search-backward
XSearch backward in the history for a line beginning with the current
Xline up to the cursor.  This leaves the cursor in its original position.
X
X@tindex end-of-buffer-or-history
X@kindex ESC->
X@item end-of-buffer-or-history (@kbd{ESC->})
XMove to the end of the buffer, or if already there, move to the last
Xevent in the history list.
X
X@tindex end-of-line-hist
X@item end-of-line-hist
XMove to the end of the line.  If already at the end of the buffer, move
Xto the next history line.
X
X@tindex end-of-history
X@item end-of-history
XMove to the last event in the history list.
X
X@tindex vi-fetch-history
X@kindex G
X@item vi-fetch-history (unbound) (@kbd{G})
XFetch the history line specified by the numeric argument.
X
X@tindex history-incremental-search-backward
X@kindex CTRL-R
X@kindex CTRL-X r
X@item history-incremental-search-backward (@kbd{^R} @kbd{^Xr})
XSearch backward incrementally for a specified string.  The string may
Xbegin with @code{^} to anchor the search to the beginning of the line.
XA restricted set of editing functions is available in the mini-buffer.
XAn interrupt signal, as defined by the stty setting, will stop the
Xsearch and go back to the original line.  An undefined key will have the
Xsame effect.  The supported functions are: @code{backward-delete-char},
X@code{quoted-insert}, @code{accept-and-hold},
X@code{accept-and-infer-next-history}, @code{accept-line} and
X@code{accept-line-and-down-history}; @code{magic-space} just inserts a
Xspace.  Any string that is bound to an out-string (via @code{bindkey
X-s}) will behave as if out-string were typed directly.  Typing the
Xbinding of @code{history-incremental-search-backward} will get the next
Xoccurrence of the contents of the mini-buffer.  Typing the binding of
X@code{history-incremental-search-forward} inverts the sense of the
Xsearch.  The direction of the search is indicated in the mini-buffer.
XAny multi-character string that is not bound to one of the above
Xfunctions will beep and interrupt the search, leaving the last found
Xline in the buffer.  Any single character that is not bound to one of
Xthe above functions, or @code{self-insert} or @code{self-insert-unmeta},
Xwill have the same effect but the function will be executed.@refill
X
X@tindex history-incremental-search-forward
X@kindex CTRL-X s
X@item history-incremental-search-forward (@kbd{^Xs})
XSearch forward incrementally for a specified string.  The string may
Xbegin with @code{^} to anchor the search to the beginning of the line.
XThe functions available in the mini-buffer are the same as for
X@code{history-incremental-search-backward}.@refill
X
X@tindex history-search-backward
X@kindex ESC-P
X@kindex ESC-p
X@kindex K
X@item history-search-backward (@kbd{ESC-P} @kbd{ESC-p}) (@kbd{K})
XSearch backward in the history for a line beginning with the first word
Xin the buffer.  
X
X@tindex vi-history-search-backward
X@kindex /
X@item vi-history-search-backward (unbound) (@kbd{/})
XSearch backward in the history for a specified string.  The string may
Xbegin with @code{^} to anchor the search to the beginning of the line.
XA restricted set of editing functions is available in the mini-buffer.
XAn interrupt signal, as defined by the stty setting, will stop the
Xsearch, as will a character bound to @code{vi-cmd-mode}.  The functions
Xavailable in the mini-buffer are: @code{accept-line},
X@code{backward-delete-char}, @code{vi-backward-delete-char} and
X@code{quoted-insert}.  Any string that is bound to an out-string (via
X@code{bindkey -s}) will behave as if out-string were typed directly.  Any other
Xcharacter that is not bound to @code{self-insert} or
X@code{self-insert-unmeta} will beep and be ignored.  If the function is
Xcalled from vi command mode, the bindings of vi insert mode will be
Xused.@refill
X
X@tindex history-search-forward
X@kindex ESC-N
X@kindex ESC-n
X@kindex J
X@item history-search-forward (@kbd{ESC-N} @kbd{ESC-n}) (@kbd{J})
XSearch forward in the history for a line beginning with the first word
Xin the buffer.
X
X@tindex vi-history-search-forward
X@kindex ?
X@item vi-history-search-forward (unbound) (@kbd{?})
XSearch forward in the history for a specified string.  The string may
Xbegin with @code{^} to anchor the search to the beginning of the line.
XThe functions available in the mini-buffer are the same as for
X@code{vi-history-search-backward}.@refill
X
X@tindex infer-next-history
X@kindex CTRL-X CTRL-N
X@item infer-next-history (@kbd{^X^N})
XSearch in the history for a line matching the current one and fetch the
Xevent following it.
X
X@tindex insert-last-word
X@kindex ESC-_
X@kindex ESC-.
X@item insert-last-word (@kbd{ESC-_} @kbd{ESC-.})
XInsert the last word from the previous history event at the cursor
Xposition.
X
X@tindex vi-repeat-search
X@kindex n
X@item vi-repeat-search (unbound) (@kbd{n})
XRepeat the last vi history search.
X
X@tindex vi-rev-repeat-search
X@kindex N
X@item vi-rev-repeat-search (unbound) (@kbd{N})
XRepeat the last vi history search, but in reverse.
X
X@tindex toggle-literal-history
X@pindex HIST_LIT, use of
X@kindex ESC-R
X@kindex ESC-r
X@item toggle-literal-history (@kbd{ESC-R} @kbd{ESC-r})
XToggle between literal and lexical history.  The default is lexical
Xhistory unless the @code{HIST_LIT} option is set.
X
X@tindex up-line-or-history
X@kindex CTRL-P
X@kindex ESC-[A
X@kindex -
X@kindex k
X@item up-line-or-history (@kbd{^P} @kbd{ESC-[A}) (@kbd{-} @kbd{k})
XMove up a line in the buffer, or if already at the top line, move to the
Xprevious event in the history list.
X
X@tindex up-line-or-search
X@item up-line-or-search
XMove up a line in the buffer, or if already at the top line, search
Xbackward in the history for a line beginning with the first word in the
Xbuffer.
X
X@tindex up-history
X@kindex CTRL-P
X@item up-history (unbound) (@kbd{^P})
XMove to the previous event in the history list.
X
X@tindex history-beginning-search-forward
X@item history-beginning-search-forward
XSearch forward in the history for a line beginning with the current line
Xup to the cursor.  This leaves the cursor at its original position.
X@end table
X
X@node Modifying Text, Arguments, History Control, Zsh Line Editor
X@section Modifying Text
X
X@table @code
X@tindex vi-add-eol
X@kindex A
X@item vi-add-eol (unbound) (@kbd{A})
XMove to the end of the line and enter insert mode.
X
X@tindex vi-add-next
X@kindex a
X@item vi-add-next (unbound) (@kbd{a})
XMove forward one character and enter insert mode.
X
X@tindex backward-delete-char
X@kindex CTRL-H
X@kindex CTRL-?
X@item backward-delete-char (@kbd{^H} @kbd{^?}) (@kbd{^?})
XDelete the character behind the cursor.
X
X@tindex vi-backward-delete-char
X@kindex X
X@item vi-backward-delete-char (unbound) (@kbd{X})
XDelete the character behind the cursor, without changing lines.
X
X@tindex backward-delete-word
X@item backward-delete-word
XDelete the word behind the cursor.
X
X@tindex backward-kill-line
X@item backward-kill-line
XKill from the beginning of the line to the cursor position.
X
X@tindex backward-kill-word
X@kindex CTRL-W
X@kindex ESC-CTRL-H
X@kindex ESC-CTRL-?
X@item backward-kill-word (@kbd{^W} @kbd{ESC-^H} @kbd{ESC-^?})
XKill the word behind the cursor.
X
X@tindex vi-backward-kill-word
X@kindex CTRL-W
X@item vi-backward-kill-word (unbound) (@kbd{^W})
XKill the word behind the cursor.
X
X@tindex capitalize-word
X@kindex ESC-C
X@kindex ESC-c
X@item capitalize-word (@kbd{ESC-C} @kbd{ESC-c})
XCapitalize the current word and move past it.
X
X@tindex vi-change
X@kindex c
X@item vi-change (unbound) (@kbd{c})
XRead a movement command from the keyboard, and kill from the cursor
Xposition to the endpoint of the movement.  Then enter insert mode.  If
Xthe command is @code{vi-change}, kill the current line.@refill
X
X@tindex vi-change-eol
X@kindex C
X@item vi-change-eol (unbound) (@kbd{C})
XKill to the end of the line and enter insert mode.
X
X@tindex vi-change-whole-line
X@kindex S
X@kindex s
X@item vi-change-whole-line (unbound) (@kbd{S} @kbd{s})
XKill the current line and enter insert mode.
X
X@tindex copy-region-as-kill
X@kindex ESC-W
X@kindex ESC-w
X@item copy-region-as-kill (@kbd{ESC-W} @kbd{ESC-w})
XCopy the area from the cursor to the mark to the kill buffer.
X
X@tindex copy-prev-word
X@kindex ESC-CTRL-_
X@item copy-prev-word (@kbd{ESC-^_})
XDuplicate the word behind the cursor.
X
X@tindex vi-delete
X@kindex d
X@item vi-delete (unbound) (@kbd{d})
XRead a movement command from the keyboard, and kill from the cursor
Xposition to the endpoint of the movement.  If the command is
X@code{vi-delete}, kill the current line.@refill
X
X@tindex delete-char
X@kindex x
X@item delete-char (unbound) (@kbd{x})
XDelete the character under the cursor.
X
X@tindex vi-delete-char
X@item vi-delete-char (unbound) (@kbd{x})
XDelete the character under the cursor.
X
X@tindex delete-word
X@kindex ESC-D
X@kindex ESC-d
X@item delete-word (@kbd{ESC-D} @kbd{ESC-d})
XDelete the current word.
X
X@tindex down-case-word
X@kindex ESC-L
X@kindex ESC-l
X@item down-case-word (@kbd{ESC-L} @kbd{ESC-l})
XConvert the current word to all lowercase and move past it.
X
X@tindex kill-word
X@item kill-word
XKill the current word.
X
X@tindex gosmacs-transpose-chars
X@item gosmacs-transpose-chars
XExchange the two characters behind the cursor.
X
X@tindex vi-indent
X@kindex >
X@item vi-indent (unbound) (@kbd{>})
XIndent a number of lines.
X
X@tindex vi-insert
X@kindex i
X@item vi-insert (unbound) (@kbd{i})
XEnter insert mode.
X
X@tindex vi-insert-bol
X@kindex I
X@item vi-insert-bol (unbound) (@kbd{I})
XMove to the beginning of the line and enter insert mode.
X
X@tindex vi-join
X@kindex CTRL-X CTRL-J
X@item vi-join (@kbd{^X^J})
XJoin the current line with the next one.
X
X@tindex kill-line
X@kindex CTRL-K
X@kindex D
X@item kill-line (@kbd{^K}) (@kbd{D})
XKill from the cursor to the end of the line.
X
X@tindex vi-kill-line
X@item vi-kill-line
XKill from the cursor to the beginning of the line.
X
X@tindex kill-region
X@item kill-region
XKill from the cursor to the mark.
X
X@tindex kill-buffer
X@kindex CTRL-X CTRL-K
X@kindex CTRL-U
X@item kill-buffer (@kbd{^X^K}) (@kbd{^U})
XKill the entire buffer.
X
X@tindex kill-whole-line
X@kindex CTRL-U
X@item kill-whole-line (@kbd{^U})
XKill the current line.
X
X@tindex vi-match-bracket
X@kindex CTRL-X CTRL-B
X@kindex %
X@item vi-match-bracket (@kbd{^X^B}) (@kbd{%})
XMove to the bracket character (one of @code{@{@}}, @code{()}, or
X@code{[]}) that matches the one under the cursor.@refill
X
X@tindex vi-open-line-above
X@kindex O
X@item vi-open-line-above (unbound) (@kbd{O})
XOpen a line above the cursor and enter insert mode.
X
X@tindex vi-open-line-below
X@kindex o
X@item vi-open-line-below (unbound) (@kbd{o})
XOpen a line below the cursor and enter insert mode.
X
X@tindex vi-oper-swap-case
X@item vi-oper-swap-case
XRead a movement command from the keyboard, and swap the case of all
Xcharacters from the cursor position to the endpoint of the movement.  If
Xthe movement command is @code{vi-oper-swap-case}, swap the case of all
Xcharacters on the current line.@refill
X
X@tindex overwrite-mode
X@kindex CTRL-X CTRL-O
X@item overwrite-mode (@kbd{^X^O})
XToggle between overwrite mode and insert mode.
X
X@tindex vi-put-after
X@kindex p
X@item vi-put-after (unbound) (@kbd{p})
XInsert the contents of the kill buffer after the cursor.
X
X@tindex quoted-insert
X@kindex CTRL-V
X@item quoted-insert (@kbd{^V})
XInsert the next character typed into the buffer literally.
X
X@tindex quote-line
X@kindex ESC-'
X@item quote-line (@kbd{ESC-'})
XQuote the current line; that is, put a @code{'} character at the
Xbeginning and the end, and convert all @code{'} characters to
X@code{\'}.@refill
X
X@tindex quote-region
X@kindex ESC-"
X@item quote-region (@kbd{ESC-"})
XQuote the region from the cursor to the mark.
X
X@tindex vi-replace
X@kindex R
X@item vi-replace (unbound) (@kbd{R})
XEnter overwrite mode.
X
X@tindex vi-repeat-change
X@kindex .
X@item vi-repeat-change (unbound) (@kbd{.})
XRepeat the last vi mode text modification.
X
X@tindex vi-replace-chars
X@kindex r
X@item vi-replace-chars (unbound) (@kbd{r})
XReplace the character under the cursor with a character read from the
Xkeyboard.
X
X@tindex self-insert
X@item self-insert (printable characters)
XPut a character in the buffer at the cursor position.
X
X@tindex self-insert-unmeta
X@kindex ESC-CTRL-I
X@kindex ESC-CTRL-J
X@kindex ESC-CTRL-M
X@item self-insert-unmeta (@kbd{ESC-^I} @kbd{ESC-^J} @kbd{ESC-^M})
XPut a character in the buffer after stripping the meta bit and
Xconverting @code{^M} to @code{^J}.@refill
X
X@tindex vi-substitute
X@kindex s
X@item vi-substitute (unbound) (@kbd{s})
XSubstitute the next character(s).
X
X@tindex vi-swap-case
X@kindex ~
X@item vi-swap-case (unbound) (@kbd{~})
XSwap the case of the character under the cursor and move past it.
X
X@tindex transpose-chars
X@kindex CTRL-T
X@item transpose-chars (@kbd{^T})
XExchange the two characters to the left of the cursor if at end of line,
Xelse exchange the character under the cursor with the character to the
Xleft.
X
X@tindex transpose-words
X@kindex ESC-T
X@kindex ESC-t
X@item transpose-words (@kbd{ESC-T} @kbd{ESC-t})
XExchange the current word with the one before it.
X
X@tindex vi-unindent
X@kindex <
X@item vi-unindent (unbound) (@kbd{<})
XUnindent a number of lines.
X
X@tindex up-case-word
X@kindex ESC-U
X@kindex ESC-u
X@item up-case-word (@kbd{ESC-U} @kbd{ESC-u})
XConvert the current word to all caps and move past it.
X
X@tindex yank
X@kindex CTRL-Y
X@kindex P
X@item yank (@kbd{^Y}) (@kbd{P})
XInsert the contents of the kill buffer at the cursor position.
X
X@tindex yank-pop
X@kindex ESC-y
X@item yank-pop (@kbd{ESC-y})
XRemove the text just yanked, rotate the kill-ring, and yank the new top.
XOnly works following @code{yank} or @code{yank-pop}.
X
X@tindex vi-yank
X@kindex y
X@item vi-yank (unbound) (@kbd{y})
XRead a movement command from the keyboard, and copy the region from the
Xcursor position to the endpoint of the movement into the kill buffer.
XIf the command is @code{vi-yank}, copy the current line.
X
X@tindex vi-yank-eol
X@kindex Y
X@item vi-yank-eol (unbound) (@kbd{Y})
XCopy the region from the cursor position to the end of the line into the
Xkill buffer.
X@end table
X
X@node Arguments, Completion, Modifying Text, Zsh Line Editor
X@section Arguments
X
X@table @code
X@tindex digit-argument
X@kindex ESC-0
X@kindex ESC-9
X@kindex 0
X@kindex 9
X@item digit-argument (@kbd{ESC-0}@dots{}@kbd{ESC-9}) (0-9)
XStart a new numeric argument, or add to the current one.
X
X@tindex neg-argument
X@kindex ESC--
X@item neg-argument (@kbd{ESC--})
XChanges the sign of the following argument.
X
X@tindex universal-argument
X@item universal-argument
XMultiply the argument of the next command by 4.
X@end table
X
X@node Completion, Miscellaneous, Arguments, Zsh Line Editor
X@section Completion
X
X@table @code
X@tindex accept-and-menu-complete
X@item accept-and-menu-complete
XIn a menu completion, insert the current completion into the buffer, and
Xadvance to the next possible completion.
X
X@tindex complete-word
X@kindex \
X@item complete-word (unbound) (@kbd{\})
XAttempt completion on the current word.
X
X@tindex delete-char-or-list
X@kindex CTRL-D
X@item delete-char-or-list (@kbd{^D})
XDelete the character under the cursor.  If the cursor is at the end of
Xthe line, list possible completions for the current word.
X
X@tindex execute-named-cmd
X@kindex ESC-x
X@item execute-named-cmd (@kbd{ESC-x})
XRead the name of a editor command and execute it.  A restricted set of
Xediting functions is available in the mini-buffer.  An interrupt signal,
Xas defined by the stty setting, will abort the function.  The allowed
Xfunctions are: @code{backward-delete-char},
X@code{vi-backward-delete-char}, @code{kill-region} (kills the last
Xword), @code{backward-kill-word}, @code{vi-backward-kill-word},
X@code{kill-whole-line}, @code{vi-kill-line}, @code{backward-kill-line}
Xand @code{accept-line}.  The @key{SPACE} and @key{TAB} keys, if not
Xbound to one of these functions, will complete the name and then list
Xthe possibilities if the @code{AUTO_LIST} option is set.@refill
X
X@tindex execute-last-named-cmd
X@kindex ESC-z
X@item execute-last-named-cmd (@kbd{ESC-z})
XRedo the last function executed with @code{execute-named-cmd}.@refill
X
X@tindex expand-cmd-path
X@item expand-cmd-path
XExpand the current command to its full pathname.
X
X@tindex expand-or-complete
X@kindex TAB
X@kindex CTRL-X
X@item expand-or-complete (@key{TAB}) (@key{TAB} @kbd{^X})
XAttempt shell expansion on the current word.  If that fails, attempt
Xcompletion.
X
X@tindex expand-or-complete-prefix
X@item expand-or-complete-prefix
XAttempt shell expansion on the current word up to the cursor.
X
X@tindex expand-history
X@kindex ESC-SPACE
X@kindex ESC-!
X@item expand-history (@kbd{ESC-SPACE} @kbd{ESC-!})
XPerform history expansion on the edit buffer.
X
X@tindex expand-word
X@kindex CTRL-X *
X@item expand-word (@kbd{^X*})
XAttempt shell expansion on the current word.
X
X@tindex list-choices
X@kindex ESC-CTRL-D
X@kindex CTRL-D
X@kindex =
X@item list-choices (@kbd{ESC-^D}) (@kbd{^D=})
XList possible completions for the current word.
X
X@tindex list-expand
X@kindex CTRL-X g
X@kindex CTRL-X G
X@kindex CTRL-G
X@item list-expand (@kbd{^Xg} @kbd{^XG}) (@kbd{^G})
XList the expansion of the current word.
X
X@tindex magic-space
X@item magic-space
XPerform history expansion and insert a space into the buffer.  This is
Xintended to be bound to @key{SPACE}.
X
X@tindex menu-complete
X@pindex MENU_COMPLETE, use of
X@item menu-complete
XLike @code{complete-word}, except that menu completion is used.
X@xref{Options}, for the @code{MENU_COMPLETE} option.@refill
X
X@tindex menu-expand-or-complete
X@item menu-expand-or-complete
XLike @code{expand-or-complete}, except that menu completion is used.
X
X@tindex reverse-menu-complete
X@item reverse-menu-complete
X@xref{Options}, for the @code{MENU_COMPLETE} option.
X@end table
X
X@node Miscellaneous,  , Completion, Zsh Line Editor
X@section Miscellaneous
X
X@table @code
X@tindex accept-and-hold
X@kindex ESC-A
X@kindex ESC-a
X@item accept-and-hold (@kbd{ESC-A} @kbd{ESC-a})
XPush the contents of the buffer on the buffer stack and execute it.
X
X@tindex accept-and-infer-next-history
X@item accept-and-infer-next-history
XExecute the contents of the buffer.  Then search the history list for a
Xline matching the current one and push the event following onto the
Xbuffer stack.
X
X@tindex accept-line
X@kindex CTRL-J
X@kindex CTRL-M
X@item accept-line (@kbd{^J} @kbd{^M})
XExecute the contents of the buffer.
X
X@tindex accept-line-and-down-history
X@kindex CTRL-O
X@item accept-line-and-down-history (@kbd{^O})
XExecute the current line, and push the next history event on the the
Xbuffer stack.
X
X@tindex vi-cmd-mode
X@kindex CTRL-X CTRL-V
X@kindex CTRL-[
X@item vi-cmd-mode (@kbd{^X^V}) (@kbd{^[})
XEnter command mode; that is, use the alternate keymap.  Yes, this is
Xbound by default in emacs mode.
X
X@tindex vi-caps-lock-panic
X@kindex H
X@kindex K
X@item vi-caps-lock-panic (unbound) (@kbd{H} @kbd{K})
XHang until any lowercase key is pressed.  This is for vi users without
Xthe mental capacity to keep track of their caps lock key (like the
Xauthor).
X
X@tindex clear-screen
X@kindex CTRL-L
X@kindex ESC-CTRL-L
X@item clear-screen (@kbd{^L} @kbd{ESC-^L})
XClear the screen and redraw the prompt.
X
X@tindex exchange-point-and-mark
X@kindex CTRL-X CTRL-X
X@item exchange-point-and-mark (@kbd{^X^X})
XExchange the cursor position with the position of the mark.
X
X@tindex get-line
X@kindex ESC-G
X@kindex ESC-g
X@item get-line (@kbd{ESC-G} @kbd{ESC-g})
XPop the top line off the buffer stack and insert it at the cursor
Xposition.
X
X@tindex pound-insert
X@kindex #
X@pindex INTERACTIVE_COMMENTS, use of
X@item pound-insert (unbound) (@kbd{#})
XIf there is no @code{#} character at the beginning of the current line,
Xadd one.  If there is one, remove it.  In either case, accept the
Xcurrent line.  The @code{INTERACTIVE_COMMENTS} option must be set for
Xthis to have any usefulness.@refill
X
X@tindex push-input
X@item push-input
XPush the entire current multiline construct onto the buffer stack and
Xreturn to the top-level (@code{PS1}) prompt.  If the current parser
Xconstruct is only a single line, this is exactly like @code{push-line}.
XNext time the editor starts up or is popped with @code{get-line}, the
Xconstruct will be popped off the top of the buffer stack and loaded into
Xthe editing buffer.@refill
X
X@tindex push-line
X@kindex CTRL-Q
X@kindex ESC-Q
X@kindex ESC-q
X@item push-line (@kbd{^Q} @kbd{ESC-Q} @kbd{ESC-q})
XPush the current buffer onto the buffer stack and clear the buffer.
XNext time the editor starts up, the buffer will be popped off the top of
Xthe buffer stack and loaded into the editing buffer.
X
X@tindex push-line-or-edit
X@item push-line-or-edit
XAt the top-level (@code{PS1}) prompt, equivalent to @code{push-line}.
XAt a secondary (@code{PS2}) prompt, move the entire current multiline
Xconstruct into the editor buffer.  The latter is equivalent to
X@code{push-line} followed by @code{get-line}.@refill
X
X@tindex redisplay
X@kindex CTRL-R
X@item redisplay (unbound) (@kbd{^R})
XRedisplays the edit buffer.
X
X@tindex run-help
X@kindex ESC-H
X@kindex ESC-h
X@item run-help (@kbd{ESC-H} @kbd{ESC-h})
XPush the buffer onto the buffer stack, and execute the command
X@code{run-help @var{cmd}}, where @var{cmd} is the current command.
X@code{run-help} is normally aliased to @code{man}.@refill
X
X@tindex send-break
X@kindex CTRL-C
X@item send-break (@kbd{^C})
XAbort the current editor function, e.g.@: @code{execute-named-command}, or
Xthe editor itself, e.g.@: if you are in @code{vared}.  Otherwise abort the
Xparsing of the current line.@refill
X
X@tindex vi-set-buffer
X@kindex "
X@item vi-set-buffer (unbound) (@kbd{"})
XSpecify a buffer to be used in the following command.
X
X@tindex vi-set-mark
X@kindex m
X@item vi-set-mark (unbound) (@kbd{m})
XSet the specified mark at the cursor position.
X
X@tindex set-mark-command
X@kindex CTRL-@@
X@item set-mark-command (@kbd{^@@})
XSet the mark at the cursor position.
X
X@tindex spell-word
X@kindex ESC-$
X@kindex ESC-S
X@kindex ESC-s
X@item spell-word (@kbd{ESC-$} @kbd{ESC-S} @kbd{ESC-s})
XAttempt spelling correction on the current word.
X
X@tindex undefined-key
X@item undefined-key
XBeep.
X
X@tindex undo
X@kindex CTRL-_
X@kindex CTRL-X CTRL-U
X@kindex CTRL-X u
X@kindex u
X@item undo (@kbd{^_} @kbd{^X^U} @kbd{^Xu} (@kbd{u})
XIncrementally undo the last text modification.
X
X@tindex which-command
X@kindex ESC-?
X@item which-command (@kbd{ESC-?})
XPush the buffer onto the buffer stack, and execute the command
X@code{which-command @var{cmd}}, where @var{cmd} is the current command.
X@code{which-command} is normally aliased to @code{whence}.@refill
X@end table
X
X@node Parameters, Options, Zsh Line Editor, Top
X@chapter Parameters
X@cindex parameters
X
X@findex typeset, use of
X@findex set, use of
X@noindent
XA parameter has a name, a value, and a number of attributes.  A name may
Xbe any sequence of alphanumeric characters and @code{_}'s, or the single
Xcharacters @code{*}, @code{@@}, @code{#}, @code{?}, @code{-}, @code{$},
Xor @code{!}.  The value may be either a scalar (a string), an
Xinteger, or an array.  To assign a scalar or integer value to a
Xparameter, use the @code{typeset} builtin.  To assign an array value,
Xuse @samp{set -A @var{name} @var{value} @dots{}}.  The value of a
Xparameter may also be assigned by writing:@refill
X
X@code{@var{name}=@var{value} @dots{}}
X
X@noindent
XIf the integer attribute, @code{-i}, is set for @var{name}, the
X@var{value} is subject to arithmetic evaluation.@refill
X
X@menu
X* Array Parameters::		
X* Positional Parameters::	
X* Parameters Set By The Shell::	 
X* Parameters Used By The Shell::  
X@end menu
X
X@node Array Parameters, Positional Parameters,  , Parameters
X@section Array Parameters
X
X@noindent
XThe value of an array parameter may be assigned by writing:
X
X@var{name}=(@var{value} @dots{}) @dots{}
X
X@cindex array elements
X@noindent
XIndividual elements of an array may be selected using a subscript.  A
Xsubscript of the form @code{[@var{exp}]} selects the single element
X@var{exp}, where @var{exp} is an arithmetic expression.  The elements
Xare numbered beginning with 1.  A subscript of the form @code{[*]} or
X@code{[@@]} evaluates to all elements of an array; there is no
Xdifference between the two except when they appear within double quotes.
X@code{"$foo[*]"} evaluates to @code{"$foo[1] $foo[2] @dots{}"}, while
X@code{"$foo[@@]"} evaluates to @code{"$foo[1]"} @code{"$foo[2]"}, etc.
XA subscript of the form @code{[@var{exp1},@var{exp2}]} selects all
Xelements in the range @var{exp1} to @var{exp2}, inclusive.  If one of
Xthe subscripts evaluates to a negative number, say @code{-@var{n}}, then
Xthe @var{n}'th element from the end of the array is used.  Thus
X@code{$foo[-3]} is the third element from the end of the array
X@code{foo}, and @code{$foo[1,-1]} is the same as @code{$foo[*]}.@refill
X
X@cindex substrings
X@noindent
XSubscripting may also be performed on non-array values, in which case
Xthe subscripts specify a substring to be extracted.  For example, if
X@code{FOO} is set to @code{foobar}, then @code{echo $FOO[2,5]} prints
X@code{ooba}.@refill
X
X@noindent
XIf a subscript is used on the left side of an assignment the selected
Xrange is replaced by the expression on the right side.
X
X@noindent
XIf the opening bracket or the comma is directly followed by an opening
Xparenthesis the string up to the matching closing parenthesis is
Xconsidered to be a list of flags.  The possible flags are:
X
X@table @code
X@item e
XThe argument is expanded using full shell expansion first.
X
X@item w
XIf the parameter subscripted is a scalar, then this flag makes
Xsubscription work on a per-word basis instead of on a per-character
Xbasis.
X
X@item s:@var{string}:
XDefines the @var{string} that separates words (for use with the @code{w}
Xflag).@refill
X
X@item r
XThe subscript is taken as a pattern, and the result is the first
Xmatching array element, substring, or word (if the parameter is an
Xarray, scalar, or a scalar and the @code{w} flag is given,
Xrespectively).  Note that this is like giving a number;
X@code{$foo[(r)??,3]} and @code{$foo[(r)??,(r)f*]} work.@refill
X
X@item R
XLike @code{r}, but returns the last match.
X
X@item i
XLike @code{r}, but returns the index of the match.  This may not be
Xcombined with a second argument.@refill
X
X@item I
XLike @code{i}, but returns the index of the last match.
X
X@item n:@var{expr}:
XIf combined with @code{r}, @code{R}, @code{i}, or @code{I}, makes them
Xreturn the @var{n}'th or @var{n}'th last match (assuming @var{expr}
Xevaluates to @var{n}).@refill
X@end table
X
X@node Positional Parameters, Parameters Set By The Shell, Array Parameters, Parameters
X@section Positional Parameters
X
X@noindent
XPositional parameters are set by the shell on invocation, by the
X@code{set} builtin, or by direct assignment.  The parameter @var{n},
Xwhere @var{n} is a number, is the @var{n}'th positional parameter.  The
Xparameters @code{*}, @code{@@}, and @code{argv} are arrays containing
Xall the positional parameters; thus @code{argv[@var{n}]}, is equivalent
Xto simply @var{n}.@refill
X
X@node Parameters Set By The Shell, Parameters Used By The Shell, Positional Parameters, Parameters
X@section Parameters Set By The Shell
X
X@noindent
XThe following parameters are automatically set by the shell:
X
X@table @code
X@vindex !
X@item !
XThe process id of the last background command invoked.
X
X@vindex #
X@item #
XThe number of positional parameters in decimal.
X
X@vindex ARGC
X@item ARGC
XSame as @code{#}.
X
X@vindex $
X@item $
XThe process id of this shell.
X
X@vindex -
X@item -
XFlags supplied to the shell on invocation or by the @code{set} or
X@code{setopt} commands.@refill
X
X@vindex *
X@item *
XAn array containing the positional parameters.
X
X@vindex argv
X@item argv
XSame as @code{*}.
X
X@vindex @@
X@item @@
XSame as @code{argv[@@]}.
X
X@vindex ?
X@item ?
XThe exit value returned by the last command.
X
X@vindex status
X@item status
XSame as @code{?}.
X
X@vindex _
X@item _
XThe last argument of the previous command.  Also, this parameter is set
Xin the environment of every command executed to the full pathname of the
Xcommand.
X
X@vindex EGID
X@item EGID
XThe effective group id of the shell process.
X
X@vindex EUID
X@item EUID
XThe effective user id of the shell process.
X
X@vindex ERRNO
X@item ERRNO
XThe value of @code{errno} as set by the most recently failed system
Xcall.  This value is system dependent and is intended for debugging
Xpurposes.@refill
X
X@vindex GID
X@item GID
XThe group id of the shell process.
X
X@vindex HOST
X@item HOST
XThe current hostname.
X
X@vindex HOSTTYPE
X@item HOSTTYPE
XA string corresponding to the type of the host the shell is running on.
X
X@vindex LINENO
X@item LINENO
XThe line number of the current line within the current script being
Xexecuted.
X
X@vindex OLDPWD
X@item OLDPWD
XThe previous working directory.
X
X@vindex OPTARG
X@item OPTARG
XThe value of the last option argument processed by the @code{getopts}
Xcommand.@refill
X
X@vindex OPTIND
X@item OPTIND
XThe index of the last option argument processed by the @code{getopts}
Xcommand.@refill
X
X@vindex PPID
X@item PPID
XThe process id of the parent of the shell.
X
X@vindex PWD
X@item PWD
XThe present working directory.
X
X@vindex RANDOM
X@item RANDOM
XA random integer from 0 to 32767, newly generated each time this
Xparameter is referenced.  The random number generator can be seeded by
Xassigning a numeric value to @code{RANDOM}.@refill
X
X@vindex SECONDS
X@item SECONDS
XThe number of seconds since shell invocation.  If this parameter is
Xassigned a value, then the value returned upon reference will be the
Xvalue that was assigned plus the number of seconds since the assignment.
X
X@vindex SHLVL
X@item SHLVL
XIncremented by one each time a new shell is started.
X
X@vindex signals
X@item signals
XAn array containing the names of the signals.
X
X@vindex TTY
X@item TTY
XThe name of the tty associated with the shell, if any.
X
X@vindex UID
X@item UID
XThe user id of the shell process.
X
X@vindex USERNAME
X@item USERNAME
X@vindex LOGNAME
X@itemx LOGNAME
XThe username corresponding to the user id of the shell process.
X
X@vindex VERSION
X@item VERSION
XThe version number of this @code{zsh}.
X@end table
X
X@node Parameters Used By The Shell,  , Parameters Set By The Shell, Parameters
X@section Parameters Used By The Shell
X
X@noindent
XThe following parameters are used by the shell:
X
X@table @code
X@vindex ARGV0
X@item ARGV
XIf exported, its value is used as argv[0] of external commands.  Usually
Xused in constructs like @samp{ARGV0=emacs nethack}.@refill
X
X@vindex BAUD
X@item BAUD
XThe baud rate of the current connection.  Used by the line editor update
Xmechanism to compensate for a slow terminal by delaying updates until
Xnecessary.  This may be profitably set to a lower value in some
Xcircumstances, e.g.@: for slow modems dialing into a communications server
Xwhich is connected to a host via a fast link; in this case, this
Xvariable would be set by default to the speed of the fast link, and not
Xthe modem.  This parameter should be set to the baud rate of the slowest
Xpart of the link for best performance.  The compensation mechanism can
Xbe turned off by setting the variable to zero.
X
X@vindex cdpath
X@vindex CDPATH
X@item cdpath (CDPATH)
XAn array (colon-separated list) of directories specifying the search
Xpath for the @code{cd} command.@refill
X
X@vindex COLUMNS
X@item COLUMNS
XThe number of columns for this terminal session.  Used for printing
Xselect lists and for the line editor.
X
X@vindex DIRSTACKSIZE
X@pindex AUTO_PUSHD, use of
X@item DIRSTACKSIZE
XThe maximum size of the directory stack.  If the stack gets larger than
Xthis, it will be truncated automatically.  This is useful with the
X@code{AUTO_PUSHD} option.@refill
X
X@vindex FCEDIT
X@item FCEDIT
XThe default editor for the @code{fc} builtin.
X
X@vindex fignore
X@vindex FIGNORE
X@item fignore (FIGNORE)
XAn array (colon-separated list) containing the suffixes of files to be
Xignored during filename completion.
X
X@vindex fpath
X@vindex FPATH
X@item fpath (FPATH)
XAn array (colon-separated list) of directories specifying the search
Xpath for function definitions.  This path is searched when a function
Xwith the @code{-u} attribute is referenced.  If an executable file is
Xfound, then it is read and executed in the current environment.@refill
X
X@vindex HISTCHARS
X@item HISTCHARS
XThree characters used by the shell's history and lexical analysis
Xmechanism.  The first character signals the start of a history
Xsubstitution (default @code{!}).  The second character signals the start
Xof a quick history substitution (default @code{^}).  The third character
Xis the comment character (default @code{#}).@refill
X
X@vindex HISTFILE
X@item HISTFILE
XThe file to save the history in when an interactive shell exits.  If
Xunset, the history is not saved.
X
X@vindex HISTSIZE
X@item HISTSIZE
XThe maximum size of the history list.
X
X@vindex HOME
X@item HOME
XThe default argument for the @code{cd} command.
X
X@vindex IFS
X@item IFS
XInternal field separators, normally space, tab, and newline, that are
Xused to separate words which result from command or parameter
Xsubstitution and words read by the @code{read} builtin.@refill
X
X@vindex KEYTIMEOUT
X@item KEYTIMEOUT
XThe time the shell waits, in hundredths of seconds, for another key to
Xbe pressed when reading bound multi-character sequences.
X
X@vindex LINES
X@item LINES
XThe number of lines for this terminal session.  Used for printing select
Xlists and for the line editor.
X
X@vindex LISTMAX
X@item LISTMAX
XIn the line editor, the number of filenames to list without asking
Xfirst.  If set to zero, the shell asks only if the listing would scroll
Xoff the screen.
X
X@vindex LITHISTSIZE
X@item LITHISTSIZE
XThe maximum size of the literal history list (before history expansion).
X
X@vindex LOGCHECK
X@item LOGCHECK
XThe interval in seconds between checks for login/logout activity using
Xthe @code{watch} parameter.@refill
X
X@vindex MAIL
X@item MAIL
XIf this parameter is set and @code{mailpath} is not set, the shell looks
Xfor mail in the specified file.  By default it is set to the user's
Xsystem mailbox.@refill
X
X@vindex MAILCHECK
X@item MAILCHECK
XThe interval in seconds between checks for new mail.
X
X@vindex mailpath
X@vindex MAILPATH
X@item mailpath (MAILPATH)
XAn array (colon-separated list) of filenames to check for new mail.
XEach filename can be followed by a @code{?} and a message that will be
Xprinted.  The sequence @code{$_} in the message will be replaced by the
Xname of the mail file.  The default message is @samp{You have new
Xmail}.  If an element is a directory instead of a file the shell will
Xrecursively check every file in every subdirectory of the
Xelement.@refill
X
X@vindex manpath
X@vindex MANPATH
X@item manpath (MANPATH)
XAn array (colon-separated list) whose value is not used by the shell.
XThe @code{manpath} array can be useful, however, since setting it also
Xsets @code{MANPATH}, and vice versa.@refill
X
X@vindex NULLCMD
X@cindex null command, setting
X@cindex csh, null command style
X@cindex ksh, null command style
X@item NULLCMD
XThe command name to assume if a redirection is specified with no
Xcommand.  Defaults to @code{cat}.  For sh/ksh-like behavior, change this
Xto @code{:}.  For csh-like behavior, unset this parameter; the shell will
Xprint an error message if null commands are entered.@refill
X
X@vindex path
X@vindex PATH
X@item path (PATH)
XAn array (colon-separated list) of directories to search for commands.
XWhen this parameter is set, each directory is scanned and all files
Xfound are put in a hash table.
X
X@vindex POSTEDIT
X@item POSTEDIT
XThis string is output whenever the line editor exits.  It usually
Xcontains termcap strings to reset the terminal.
X
X@vindex PROMPT
X@item PROMPT
XThe primary prompt string, printed before a command is read; the default
Xis @samp{%m%# }.  If the escape sequence takes an optional integer, it
Xshould appear between the @code{%} and the next character of the
Xsequence.  The following escape sequences are recognized:@refill
X
X@table @code
X@item %d
X@itemx %/
XPresent working directory (@code{$PWD}).
X
X@item %~
X@code{$PWD}.  If it has a named directory as its prefix, that part is
Xreplaced by a @code{~} followed by the name of the directory.  If it
Xstarts with @code{$HOME}, that part is replaced by a @code{~}.@refill
X
X@item %c
X@itemx %.
X@itemx %C
XTrailing component of @code{$PWD}.  An integer may follow the @code{%}
Xto get more than one component.  Unless @code{%C} is used, tilde
Xexpansion is performed first.@refill
X
X@item !
X@itemx %h
X@itemx %!
XCurrent history event number
X
X@item %M
XThe full machine hostname.
X
X@item %m
XThe hostname up to the first @samp{.}.  An integer may follow the @code{%} to
Xspecify how many components of the hostname are desired.@refill
X
X@item %S (%s)
XStart (stop) standout mode.
X
X@item %U (%u)
XStart (stop) underline mode.
X
X@item %B (%b)
XStart (stop) boldface mode.
X
X@item %t
X@itemx %@@
XCurrent time of day, in 12-hour, am/pm format.
X
X@item %T
XCurrent time of day, in 24-hour format.
X
X@item %*
XCurrent time of day in 24-hour format, with seconds.
X
X@item %n
X@code{$USERNAME}.
X
X@item %w
XThe date in day-dd format.
X
X@item %W
XThe date in mm/dd/yy format.
X
X@item %D
XThe date in yy-mm-dd format.
X
X@item %D@{@var{string}@}
X@var{string} is formatted using the @code{strftime} function.  See
X@code{strftime(3)} for more details, if your system has it.@refill
X
X@item %l
XThe line (tty) the user is logged in on.
X
X@item %?
XThe return code of the last command executed just before the
Xprompt.@refill 
X
X@item %_
XThe status of the parser, i.e. the shell constructs (like @code{if} and
X@code{for}) that have been started on the command line.  If given an
Xinteger number, that many strings will be printed.@refill
X
X@item %E
XClears to end of screen.  Useful with @code{ALWAYS_LAST_PROMPT}
Xset.@refill
X
X@item %#
XA @code{#} if the shell is running as root, a @code{%} if not.
XEquivalent to @code{%(#.#.%%)}@refill
X
X@item %v
XThe value of the first element of the @code{psvar} array parameter.
XFollowing the @code{%} with an integer gives that element of the
Xarray.@refill
X
X@item %@{@dots{}%@}
XInclude a string as a literal escape sequence.  The string within the
Xbraces should not change the cursor position.@refill
X
X@item %(x.@var{true-text}.@var{false-text})
XSpecifies a ternary expression.  The character following the @code{x} is
Xarbitrary; the same character is used to separate the text for the true
Xresult from that for the false result.  Both the separator and the right
Xparenthesis may be escaped with a backslash.  @var{true-text} and
X@var{false-text} may both contain arbitrarily-nested escape sequences,
Xincluding further ternary expressions.  The left parenthesis may be
Xpreceded or followed by a positive integer @var{n}, which defaults to
Xzero.  The text character @code{x} may be any of the following:@refill
X
X@table @code
X@item c
X@itemx .
X@itemx ~
XTrue if the current path, with prefix replacement, has at least @var{n}
Xelements.@refill
X@item /
X@itemx C
XTrue if the current absolute path has at least @var{n} elements.
X@item t
XTrue if the time in minutes is equal to @var{n}.
X@item T
XTrue if the time in hours is equal to @var{n}.
X@item d
XTrue if the day of the month is equal to @var{n}.
X@item D
XTrue if the month is equal to @var{n} (January = 0).
X@item w
XTrue if the day of the week is equal to @var{n} (Sunday = 0).
X@item ?
XTrue if the exit status of the last command was @var{n}.
X@item # 
XTrue if the effective uid of the current process is @var{n}.
X@item g
XTrue if the effective gid of the current process is @var{n}.
X@item L
XTrue if the @code{SHLVL} parameter is at least @var{n}.
X@item S
XTrue if the @code{SECONDS} parameter is at least @var{n}.
X@item v
XTrue if the array @code{psvar} has at least @var{n} elements.
X@item _
XTrue if at least @var{n} shell constructs were started.
X@end table
X@end table
X
X@vindex PROMPT2
X@item PROMPT2
XThe secondary prompt, printed when the shell needs more information to
Xcomplete a command.  Recognizes the same escape sequences as
X@code{PROMPT}.  The default is @samp{> }.@refill
X
X@vindex PROMPT3
X@item PROMPT3
XSelection prompt used within a @code{select} loop.  Recognizes the same
Xescape sequences as @code{PROMPT}.  The default is @samp{?# }.@refill
X
X@vindex PROMPT4
X@item PROMPT4
XThe execution trace prompt.  Default is @samp{+ }.
X
X@vindex PS1
X@vindex PS2
X@vindex PS3
X@vindex PS4
X@item PS1
X@itemx PS2
X@itemx PS3
X@itemx PS4
XSame as @code{PROMPT}, @code{PROMPT2}, @code{PROMPT3}, and @code{PROMPT4},
Xrespectively.@refill
X
X@vindex psvar
X@vindex PSVAR
X@item psvar (PSVAR)
XAn array (colon-separated list) whose first nine values can be used in
X@code{PROMPT} strings.  Setting @code{psvar} also sets @code{PSVAR}, and
Xvice versa.@refill
X
X@vindex prompt
X@item prompt
XSame as @code{PROMPT}.
X
X@vindex READNULLCMD
X@item READNULLCMD
XThe command name to assume if a single input redirection is specified
Xwith no command.  Defaults to @code{more}.@refill
X
X@vindex REPORTTIME
X@item REPORTTIME
XIf nonzero, commands whose combined user and system execution times
X(measured in seconds) are greater than this value have timing statistics
Xprinted for them.@refill
X
X@vindex RPROMPT
X@vindex RPS1
X@item RPROMPT
X@itemx RPS1
XThis prompt is displayed on the right-hand side of the screen when the
Xprimary prompt is being displayed on the left.  This does not work if
Xthe @code{SINGLE_LINE_ZLE} option is set.  Recognizes the same escape
Xsequences as @code{PROMPT}.@refill
X
X@vindex SAVEHIST
X@item SAVEHIST
XThe maximum number of history events to save in the history file.
X
X@vindex SPROMPT
X@item SPROMPT
XThe prompt used for spelling correction.  The sequence @code{%R} expands
Xto the string which presumably needs spelling correction, and @code{%r}
Xexpands to the proposed correction.  All other @code{PROMPT} escapes are
Xalso allowed.@refill
X
X@vindex STTY
X@item STTY
XIf this parameter is set in a command's environment, the shell runs the
X@code{stty} command with the value of this parameter as arguments in
Xorder to set up the terminal before executing the command.  The modes
Xapply only to the command, and are reset when it finishes or is
Xsuspended.  If the command is suspended and continued later with the
X@code{fg} or @code{wait} builtins it will see the modes specified by
XSTTY, as if it were not suspended.  This (intentionally) does not apply
Xif the command is continued via @code{kill -CONT}.  @code{STTY} is
Xignored if the command is run in the background, or if it is in the
Xenvironment of the shell but not explicitly assigned to in the input
Xline.  This avoids running @code{stty} at every external command by
Xaccidentally exporting it.  Also note that @code{STTY} should not be
Xused for window size specifications; these will not be local to the
Xcommand.@refill
X  
X@vindex TIMEFMT
X@item TIMEFMT
XThe format of process time reports with the @code{time} keyword.  The
Xdefault is @samp{%E real  %U user  %S system  %P %J}.  Recognizes the
Xfollowing escape sequences:@refill
X
X@table @code
X@item %U
XCPU seconds spent in user mode.
X@item %S
XCPU seconds spent in kernel mode.
X@item %E
XElapsed time in seconds.
X@item %P
XThe CPU percentage, computed as (%U+%S)/%E.
X@item %W
XNumber of times the process was swapped.
X@item %X
XThe average amount of (shared) text space used in Kbytes.
X@item %D
XThe average amount of (unshared) data/stack space used in Kbytes.
X@item %K
XThe total space used (%X+%D) in Kbytes.
X@item %M
XThe maximum memory the process had in use at any time in Kbytes.
X@item %F
XThe number of major page faults (page needed to be brought from
Xdisk).@refill
X@item %R
XThe number of minor page faults.
X@item %I
XThe number of input operations.
X@item %O
XThe number of output operations.
X@item %r
XThe number of socket messages received.
X@item %s
XThe number of socket messages sent.
X@item %k
XThe number of signals received.
X@item %w
XNumber of voluntary context switches (waits).
X@item %c
XNumber of involuntary context switches.
X@item %J
XThe name of this job.
X@end table
X
X@vindex TMOUT
X@item TMOUT
XIf this parameter is nonzero, the shell will terminate if a command is
Xnot entered within the specified number of seconds after issuing a
Xprompt.
X
X@vindex TMPPREFIX
X@item TMPPREFIX
XA pathname prefix which the shell will use for all temporary files.
XNote that this should include an initial part for the file name as well
Xas any directory names.  The default is /tmp/zsh.
X
X@vindex watch
X@vindex WATCH
X@item watch (WATCH)
XAn array (colon-separated list) of login/logout events to report.  If it
Xcontains the single word @samp{all}, then all login/logout events are
Xreported.  If it contains the single word @samp{notme}, then all
Xlogin/logout events are reported except for those originating from
X@code{$USERNAME}.  An entry in this list may consist of a username, an
X@code{@@} followed by a remote hostname, and a @code{%} followed by a
Xline (tty).  Any or all of these components may be present in an entry;
Xif a login/logout event matches all of them, it is reported.@refill
X
X@vindex WATCHFMT
X@item WATCHFMT
XThe format of login/logout reports if the @code{watch} parameter is set.
XDefault is @samp{%n has %a %l from %m}.  Recognizes the following escape
Xsequences:@refill
X
X@table @code
X@item %n
XThe name of the user that logged in/out.
X
X@item %a
XThe observed action, i.e. @samp{logged on} or @samp{logged off}.
X
X@item %l
XThe line (tty) the user is logged in on.
X
X@item %M
XThe full hostname of the remote host.
X
X@item %m
XThe hostname up to the first @samp{.}.  If only the IP address is
Xavailable or the utmp field contains the name of an X-windows display,
Xthe whole name is printed.@refill
X
X@noindent
XNOTE: The @code{%m} and @code{%M} escapes will work only if there is a
Xhost name field in the @code{utmp} on your machine.  Otherwise they are
Xtreated as ordinary strings.@refill
X
X@item %S (%s)
XStart (stop) standout mode.
X
X@item %U (%u)
XStart (stop) underline mode.
X
X@item %B (%b)
XStart (stop) boldface mode.
X
X@item %t
X@itemx %@@
XThe time, in 12-hour, am/pm format.
X
X@item %T
XThe time, in 24-hour format.
X
X@item %w
XThe date in day-dd format.
X
X@item %W
XThe date in mm/dd/yy format.
X
X@item %D
XThe date in yy-mm-dd format.
X
X@item %(x:@var{true-text}:@var{false-text})
XSpecifies a ternary expression.  The character following the @code{x} is
Xarbitrary; the same character is used to separate the text for the true
Xresult from that for the false result.  Both the separator and the right
Xparenthesis may be escaped with a backslash.  Ternary expressions may be
Xnested.@refill
X
X@noindent
XThe test character @code{x} may be any one of @code{l}, @code{n},
X@code{m}, or @code{M}, which indicate a true result if the corresponding
Xescape sequence would return a non-empty value; or it may be @code{a},
Xwhich indicates a true result if the watched user has logged in, or
Xfalse if he has logged out.  Other characters evaluate to neither true
Xnor false; the entire expression is omitted in this case.@refill
X
X@noindent
XIf the result is true, then the @var{true-text} is formatted according
Xto the result above and printed, and the @var{false-text} is skipped.
XIf false, the @var{true-text} is skipped, and the @var{false-text} is
Xformatted and printed.  Either or both of the branches may be empty, but
Xboth separators must always be present.@refill
X@end table
X
X@vindex WORDCHARS
X@item WORDCHARS
XA list of nonalphanumeric characters considered part of a word by the
Xline editor.
X
X@vindex ZDOTDIR
X@item ZDOTDIR
XThe directory to search for shell startup files (@file{.zshrc}, etc), if
Xnot @code{$HOME}.@refill
X@end table
X
X@node Options, Shell Builtin Commands, Parameters, Top
X@chapter Options
X@cindex options
X
X@noindent
XThe following options may be set upon invocation of the shell, or with
Xthe @code{set} or @code{setopt} builtins.  The names are
Xcase-insensitive and underscores are ignored, that is, @samp{allexport}
Xis equivalent to @samp{A_lleXP_ort}.@refill
X
X@table @code
X@cindex export, automatic
X@pindex ALL_EXPORT
X@item ALL_EXPORT (-a)
XAll parameters subsequently defined are automatically exported.
X
X@cindex history, appending to file
X@pindex ALWAYS_LAST_PROMPT
X@item ALWAYS_LAST_PROMPT
XIf unset, key functions that list completions try to return to the last
Xprompt if given a numeric argument.  If set, these functions try to
Xreturn to the last prompt if given no numeric argument.@refill
X
X@pindex ALWAYS_TO_END
X@item ALWAYS_TO_END
XIf a completion with the cursor in the word was started and it results
Xin only one match, the cursor is placed at the end of the word.
X
X@pindex APPEND_HISTORY
X@item APPEND_HISTORY
XIf this is set, zsh sessions will append their history list to the
Xhistory file, rather than overwrite it.  Thus, multiple parallel zsh
Xsessions will all have their history lists added to the history file, in
Xthe order they are killed.  @xref{Shell Builtin Commands}, for the
X@code{fc} command.@refill
X
X@cindex cd, automatic
X@pindex AUTO_CD
X@item AUTO_CD (-J)
XIf a command is not in the hash table, and there exists an executable
Xdirectory by that name, perform the @code{cd} command to that directory.
X
X@cindex completion, listing choices
X@pindex AUTO_LIST
X@item AUTO_LIST (-9)
XAutomatically list choices on an ambiguous completion.
X
X@cindex completion, menu, on TAB
X@pindex AUTO_MENU
X@item AUTO_MENU
XAutomatically use menu completion after the second consecutive request
Xfor completion, for example by pressing the @key{TAB} key repeatedly.
XThis option is overriden by @code{MENU_COMPLETE}.@refill
X
X@cindex directories, named
X@pindex AUTO_NAME_DIRS
X@item AUTO_NAME_DIRS
XAny parameter that is set to the absolute name of a directory
Ximmediately becomes a name for that directory in the usual form
X@code{~param}.  If this option is not set, the parameter must be used in
Xthat form for it to become a name (a command-line completion is
Xsufficient for this).@refill
X
X@pindex AUTO_PARAM_KEYS
X@item AUTO_PARAM_KEYS
XIf a parameter name was completed and the next character typed is one of
Xthose that have to come directly after the name (like @code{@}},
X@code{:}, etc.), they are placed there automatically.@refill
X
X@cindex cd, behaving like pushd
X@cindex pushd, making cd behave like
X@pindex AUTO_PUSHD
X@item AUTO_PUSHD (-N)
XMake @code{cd} act like @code{pushd}.
X
X@cindex slash, removing trailing
X@pindex AUTO_REMOVE_SLASH
X@item AUTO_REMOVE_SLASH
XWhen the last character resulting from a completion is a slash and the next
Xcharacter typed is a word delimiter, remove the slash.@refill
X
X@cindex jobs, resuming automatically
X@cindex resuming jobs automatically
X@pindex AUTO_RESUME
X@item AUTO_RESUME (-W)
XTreat single word simple commands without redirection as candidates for
Xresumption of an existing job.
X
X@cindex jobs, background priority
X@cindex background jobs, priority of
X@pindex BGNICE
X@item BGNICE (-6)
XRun all background jobs at a lower priority.  This option is set by
Xdefault.
X
X@cindex brace expansion, extending
X@cindex expansion, brace, extended
X@pindex BRACE_CCL
X@item BRACE_CCL
XAllow brace expansions of the form @code{@{a-zA-Z@}}, etc.
X
X@cindex cd, to parameter
X@pindex CDABLE_VARS
X@item CDABLE_VARS (-T)
XIf the argument to a @code{cd} command (or an implied cd with the
X@code{AUTO_CD} option set) is not a directory, and does not begin with a
Xslash, try to expand the expression as if it were preceded by a
X@code{~} (@pxref{Filename Expansion}).@refill 
X
END_OF_FILE
  if test 57479 -ne `wc -c <'zsh-2.5.0/doc/zsh.texi.B'`; then
    echo shar: \"'zsh-2.5.0/doc/zsh.texi.B'\" unpacked with wrong size!
  elif test -f 'zsh-2.5.0/doc/zsh.texi.A' && test -f 'zsh-2.5.0/doc/zsh.texi.C'; then
    echo shar: Combining  \"'zsh-2.5.0/doc/zsh.texi'\" \(190781 characters\)
    cat 'zsh-2.5.0/doc/zsh.texi.A' 'zsh-2.5.0/doc/zsh.texi.B' 'zsh-2.5.0/doc/zsh.texi.C' > 'zsh-2.5.0/doc/zsh.texi'
    if test 190781 -ne `wc -c <'zsh-2.5.0/doc/zsh.texi'`; then
      echo shar: \"'zsh-2.5.0/doc/zsh.texi'\" combined with wrong size!
    else
      rm zsh-2.5.0/doc/zsh.texi.A zsh-2.5.0/doc/zsh.texi.B zsh-2.5.0/doc/zsh.texi.C
    fi
  fi
  # end of 'zsh-2.5.0/doc/zsh.texi.B'
fi
if test -f 'zsh-2.5.0/src/zle_main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/src/zle_main.c'\"
else
  echo shar: Extracting \"'zsh-2.5.0/src/zle_main.c'\" \(23103 characters\)
  sed "s/^X//" >'zsh-2.5.0/src/zle_main.c' <<'END_OF_FILE'
X/*
X *
X * zle_main.c - main routines for line editor
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made.
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk.
X *
X */
X
X#define ZLEGLOBALS
X#define ZLE
X#include "zsh.h"
X#include <sys/types.h>
X#include <errno.h>
X#ifdef HAS_SYS_SELECT
X#include <sys/select.h>
X#endif
X
Xstatic int emacs_cur_bindtab[256], eofchar, eofsent;
Xint viins_cur_bindtab[256], ungetok;	/* needed in zle_hist */
X
X/* hash table containing the zle multi-character bindings */
X
Xstatic Hashtab xbindtab, vi_xbindtab, em_xbindtab;
X
Xstatic Key cky;
X
X/* set up terminal */
X
Xvoid setterm()
X{				/**/
X    struct ttyinfo ti;
X
X#if defined(CLOBBERS_TYPEAHEAD) && defined(FIONREAD)
X    int val;
X
X    ioctl(SHTTY, FIONREAD, (char *)&val);
X    if (val)
X	return;
X#endif
X
X/* sanitize the tty */
X#ifdef HAS_TIO
X    shttyinfo.tio.c_lflag |= ICANON | ECHO;
X#ifdef FLUSHO
X    shttyinfo.tio.c_lflag &= ~FLUSHO;
X#endif
X#else				/* not HAS_TIO */
X    shttyinfo.sgttyb.sg_flags = (shttyinfo.sgttyb.sg_flags & ~CBREAK) | ECHO;
X    shttyinfo.lmodes &= ~LFLUSHO;
X#endif
X
X    attachtty(mypgrp);
X    ti = shttyinfo;
X#ifdef HAS_TIO
X    if (isset(NOFLOWCONTROL))
X	ti.tio.c_iflag &= ~IXON;
X    ti.tio.c_lflag &= ~(ICANON | ECHO
X#ifdef FLUSHO
X			| FLUSHO
X#endif
X	);
X#ifdef TAB3
X    ti.tio.c_oflag &= ~TAB3;
X#else
X#ifdef OXTABS
X    ti.tio.c_oflag &= ~OXTABS;
X#else
X    ti.tio.c_oflag &= ~XTABS;
X#endif
X#endif
X    ti.tio.c_oflag |= ONLCR;
X    ti.tio.c_cc[VQUIT] =
X#ifdef VDISCARD
X	ti.tio.c_cc[VDISCARD] =
X#endif
X#ifdef VSUSP
X	ti.tio.c_cc[VSUSP] =
X#endif
X#ifdef VDSUSP
X	ti.tio.c_cc[VDSUSP] =
X#endif
X#ifdef VSWTCH
X	ti.tio.c_cc[VSWTCH] =
X#endif
X#ifdef VLNEXT
X	ti.tio.c_cc[VLNEXT] =
X#endif
X	VDISABLEVAL;
X#if defined(VSTART) && defined(VSTOP)
X    if (isset(NOFLOWCONTROL))
X	ti.tio.c_cc[VSTART] = ti.tio.c_cc[VSTOP] = VDISABLEVAL;
X#endif
X    eofchar = ti.tio.c_cc[VEOF];
X    ti.tio.c_cc[VMIN] = 1;
X    ti.tio.c_cc[VTIME] = 0;
X    ti.tio.c_iflag |= (INLCR | ICRNL);
X /* this line exchanges \n and \r; it's changed back in getkey
X	so that the net effect is no change at all inside the shell.
X	This double swap is to allow typeahead in common cases, eg.
X
X	% bindkey -s '^J' 'echo foo^M'
X	% sleep 10
X	echo foo<return>  <--- typed before sleep returns
X
X	The shell sees \n instead of \r, since it was changed by the kernel
X	while zsh wasn't looking. Then in getkey() \n is changed back to \r,
X	and it sees "echo foo<accept line>", as expected. Without the double
X	swap the shell would see "echo foo\n", which is translated to
X	"echo fooecho foo<accept line>" because of the binding.
X	Note that if you type <line-feed> during the sleep the shell just sees
X	\n, which is translated to \r in getkey(), and you just get another
X	prompt. For type-ahead to work in ALL cases you have to use
X	stty inlcr.
X	This workaround is due to Sven Wischnowsky <oberon@cs.tu-berlin.de>.
X
X	Unfortunately it's IMPOSSIBLE to have a general solution if both
X	<return> and <line-feed> are mapped to the same character. The shell
X	could check if there is input and read it before setting it's own
X	terminal modes but if we get a \n we don't know whether to keep it or
X	change to \r :-(
X	*/
X
X#else				/* not HAS_TIO */
X    ti.sgttyb.sg_flags = (ti.sgttyb.sg_flags | CBREAK) & ~ECHO & ~XTABS;
X    ti.lmodes &= ~LFLUSHO;
X    eofchar = ti.tchars.t_eofc;
X    ti.tchars.t_quitc =
X	ti.ltchars.t_suspc =
X	ti.ltchars.t_flushc =
X	ti.ltchars.t_dsuspc = ti.ltchars.t_lnextc = -1;
X#endif
X
X#if defined(TTY_NEEDS_DRAINING) && defined(TIOCOUTQ) && defined(HAS_SELECT)
X/* this is mostly stolen from bash's draino() */
X    if (baud) {			/**/
X	int n = 0;
X
X	while ((ioctl(SHTTY, TIOCOUTQ, (char *)&n) >= 0) && n) {
X	    struct timeval tv;
X
X	    tv.tv_sec = n / baud;
X	    tv.tv_usec = ((n % baud) * 1000000) / baud;
X	    select(0, NULL, NULL, NULL, &tv);
X	}
X    }
X#endif
X
X    settyinfo(&ti);
X}
X
Xstatic char *kungetbuf;
Xstatic int kungetct, kungetsz;
X
Xvoid ungetkey(ch)		/**/
Xint ch;
X{
X    if (kungetct == kungetsz)
X	kungetbuf = realloc(kungetbuf, kungetsz *= 2);
X    kungetbuf[kungetct++] = ch;
X}
X
Xvoid ungetkeys(s, len)		/**/
Xchar *s;
Xint len;
X{
X    s += len;
X    while (len--)
X	ungetkey(*--s);
X}
X
X#if defined(pyr) && defined(HAS_SELECT)
Xstatic int breakread(fd, buf, n)
Xint fd, n;
Xchar *buf;
X{
X    fd_set f;
X
X    FD_ZERO(&f);
X    FD_SET(fd, &f);
X    return (select(fd + 1, (SELECT_ARG_2_T) & f, NULL, NULL, NULL) == -1 ?
X	    EOF : read(fd, buf, n));
X}
X
X#define read    breakread
X#endif
X
Xint getkey(keytmout)		/**/
Xint keytmout;
X{
X    char cc;
X    unsigned int ret;
X    long exp100ths;
X    int die = 0, r;
X    int old_errno = errno;
X
X#ifdef HAS_SELECT
X    fd_set foofd;
X
X#else
X#ifdef HAS_TIO
X    struct ttyinfo ti;
X
X#endif
X#endif
X
X    if (kungetct)
X	ret = (int)(unsigned char)kungetbuf[--kungetct];
X    else {
X	if (keytmout) {
X	    if (keytimeout > 500)
X		exp100ths = 500;
X	    else if (keytimeout > 0)
X		exp100ths = keytimeout;
X	    else
X		exp100ths = 0;
X#ifdef HAS_SELECT
X	    if (exp100ths) {
X		struct timeval expire_tv;
X
X		expire_tv.tv_sec = exp100ths / 100;
X		expire_tv.tv_usec = (exp100ths % 100) * 10000L;
X		FD_ZERO(&foofd);
X		FD_SET(0, &foofd);
X		if (select(1, (SELECT_ARG_2_T) & foofd, NULL, NULL, &expire_tv) <= 0)
X		    return EOF;
X	    }
X#else
X#ifdef HAS_TIO
X	    ti = shttyinfo;
X	    ti.tio.c_lflag &= ~ICANON;
X	    ti.tio.c_cc[VMIN] = 0;
X	    ti.tio.c_cc[VTIME] = exp100ths / 10;
X	    ioctl(SHTTY, TCSETA, &ti.tio);
X	    r = read(0, &cc, 1);
X	    ioctl(SHTTY, TCSETA, &shttyinfo.tio);
X	    return (r <= 0) ? -1 : cc;
X#endif
X#endif
X	}
X	while ((r = read(0, &cc, 1)) != 1) {
X	    if (r == 0) {
X		if (isset(IGNOREEOF))
X		    continue;
X		stopmsg = 1;
X		zexit(1);
X	    }
X	    if (errno == EINTR) {
X		die = 0;
X		if (!errflag)
X		    continue;
X		errflag = 0;
X		errno = old_errno;
X		return EOF;
X	    } else if (errno == EWOULDBLOCK) {
X		fcntl(0, F_SETFL, 0);
X	    } else if (errno == EIO && !die) {
X		ret = jobbingv;
X		jobbingv = OPT_SET;
X		attachtty(mypgrp);
X		refresh();	/* kludge! */
X		jobbingv = ret;
X		die = 1;
X	    } else if (errno != 0) {
X		zerr("error on TTY read: %e", NULL, errno);
X		stopmsg = 1;
X		zexit(1);
X	    }
X	}
X	if (cc == '\r')		/* undo the exchange of \n and \r determined by */
X	    cc = '\n';		/* setterm() */
X	else if (cc == '\n')
X	    cc = '\r';
X
X	ret = (int)(unsigned char)cc;
X    }
X    if (vichgflag) {
X	if (vichgbufptr == vichgbufsz)
X	    vichgbuf = realloc(vichgbuf, vichgbufsz *= 2);
X	vichgbuf[vichgbufptr++] = ret;
X    }
X    errno = old_errno;
X    return ret;
X}
X
X/* read a line */
X
Xunsigned char *zleread(ppt, ppt2, plen, p2len)	/**/
Xunsigned char *ppt;
Xunsigned char *ppt2;
Xint plen;
Xint p2len;
X{
X    int z;
X    unsigned char *s;
X    int old_errno = errno;
X
X#ifdef HAS_SELECT
X    long costmult = (baud) ? 3840000L / baud : 0;
X    struct timeval tv;
X    fd_set foofd;
X
X    tv.tv_sec = 0;
X#endif
X
X    fflush(stdout);
X    fflush(stderr);
X    intr();
X    insmode = unset(OVERSTRIKE);
X    eofsent = 0;
X    resetneeded = 0;
X    pmpt = (char *)ppt;
X    pmpt2 = (char *)ppt2;
X    pptlen = plen;
X    ppt2len = p2len;
X    permalloc();
X    histline = curhist;
X#ifdef HAS_SELECT
X    FD_ZERO(&foofd);
X#endif
X    undoing = 1;
X    line = (unsigned char *)zalloc((linesz = 256) + 1);
X    *line = '\0';
X    virangeflag = lastcmd = done = cs = ll = mark = 0;
X    curhistline = NULL;
X    mult = 1;
X    vibufspec = 0;
X    bindtab = mainbindtab;
X    addedsuffix = complexpect = vichgflag = 0;
X    viinsbegin = 0;
X    statusline = NULL;
X    if ((s = (unsigned char *)getnode(bufstack))) {
X	setline((char *)s);
X	zsfree((char *)s);
X	if (stackcs != -1) {
X	    cs = stackcs;
X	    stackcs = -1;
X	    if (cs > ll)
X		cs = ll;
X	}
X	if (stackhist != -1) {
X	    histline = stackhist;
X	    stackhist = -1;
X	}
X    }
X    initundo();
X    if (unset(NOPROMPTCR))
X	putchar('\r');
X    if (tmout)
X	alarm(tmout);
X    zleactive = 1;
X    resetneeded = 1;
X    refresh();
X    errflag = retflag = 0;
X    while (!done && !errflag) {
X	struct zlecmd *zc;
X
X	statusline = NULL;
X	bindk = getkeycmd();
X	if (!ll && c == eofchar) {
X	    eofsent = 1;
X	    break;
X	}
X	if (bindk != -1) {
X	    int ce = complexpect;
X
X	    zc = zlecmds + bindk;
X	    if (!(lastcmd & ZLE_ARG))
X		mult = 1;
X	    if ((lastcmd & ZLE_UNDO) != (zc->flags & ZLE_UNDO) && undoing)
X		addundo();
X	    if (bindk != z_sendstring) {
X		if (!(zc->flags & ZLE_MENUCMP) && menucmp)
X		    menucmp = 0;
X		if (!(zc->flags & ZLE_MENUCMP) &&
X		    addedsuffix && !(zc->flags & ZLE_DELETE) &&
X		    !((zc->flags & ZLE_INSERT) && c != ' ')) {
X		    backdel(addedsuffix);
X		}
X		if (!menucmp)
X		    addedsuffix = 0;
X	    }
X	    if (zc->func)
X		(*zc->func) ();
X	    if (ce == complexpect && ce)
X		complexpect = 0;
X	    if (bindk != z_sendstring)
X		lastcmd = zc->flags;
X	    if (!(lastcmd & ZLE_UNDO) && undoing)
X		addundo();
X	} else {
X	    errflag = 1;
X	    break;
X	}
X#ifdef HAS_SELECT
X	if (baud && (!lastcmd & ZLE_MENUCMP)) {
X	    FD_SET(0, &foofd);
X	    if ((tv.tv_usec = cost * costmult) > 500000)
X		tv.tv_usec = 500000;
X	    if (!kungetct && select(1, (SELECT_ARG_2_T) & foofd, NULL, NULL, &tv) <= 0)
X		refresh();
X	} else
X#endif
X	if (!kungetct)
X	    refresh();
X    }
X    statusline = NULL;
X    trashzle();
X    zleactive = 0;
X    alarm(0);
X    z = strlen(UTOSCP(line));
X    line[z] = '\n';
X    line[z + 1] = 0;
X    heapalloc();
X    zsfree(curhistline);
X    if (eofsent) {
X	free(line);
X	line = NULL;
X    }
X    free(lastline);		/* freeundo */
X    errno = old_errno;
X    return line;
X}
X
Xint getkeycmd()
X{				/**/
X    int ret;
X    static int hops = 0;
X
X    cky = NULL;
X
X    if ((c = getkey(0)) < 0)
X	return -1;
X    if ((ret = bindtab[c]) == z_sequenceleadin) {
X	int lastlen = 0, t0 = 1, buflen = 50;
X	Key ky;
X	char *buf;
X
X	buf = (char *)zalloc(buflen);
X	ungetok = 0;
X	buf[0] = c, buf[1] = '\0';
X	if ((cky = (Key) gethnode(buf, xbindtab))->func == z_undefinedkey)
X	    cky = NULL;
X	else
X	    lastlen = 1;
X	if (!c)
X	    buf[0] = (char)0x80;
X	for (;;) {
X	    if ((c = getkey(cky ? 1 : 0)) >= 0) {
X		if (t0 == buflen - 1)
X		    buf = (char *)realloc(buf, buflen *= 2);
X		buf[t0++] = (c) ? c : 0x80;
X		buf[t0] = '\0';
X		ky = (Key) gethnode(buf, xbindtab);
X	    } else
X		ky = NULL;
X	    if (ky) {
X		if (ky->func == z_undefinedkey)
X		    continue;
X		cky = ky;
X		if (!ky->prefixct) {
X		    ret = ky->func;
X		    break;
X		}
X		lastlen = t0;
X	    } else if (cky) {
X		ungetkeys(&buf[lastlen], t0 - lastlen);
X		ret = cky->func;
X		c = buf[lastlen - 1];
X		break;
X	    } else
X		return z_undefinedkey;
X	}
X	zfree(buf, buflen);
X    } else
X	ungetok = 1;		/* for doisearch() */
X    if (ret == z_vidigitorbeginningofline)
X	ret = (lastcmd & ZLE_ARG) ? z_digitargument : z_beginningofline;
X    else if (ret == z_executenamedcmd && !statusline)
X	ret = executenamedcommand();
X    else if (ret == z_executelastnamedcmd)
X	ret = lastnamed;
X    else if (ret == z_sendstring) {
X#define MAXHOPS 20
X	if (++hops == MAXHOPS) {
X	    zerr("string inserting another one too many times", NULL, 0);
X	    hops = 0;
X	    return -1;
X	}
X    } else
X	hops = 0;
X    return ret;
X}
X
Xvoid sendstring()
X{				/**/
X    if (!cky) {
X	char buf[2];
X
X	buf[0] = c;
X	buf[1] = '\0';
X	cky = (Key) gethnode(buf, xbindtab);
X    }
X    ungetkeys(cky->str, cky->len);
X}
X
XKey makefunckey(fun)		/**/
Xint fun;
X{
X    Key ky = (Key) zcalloc(sizeof *ky);
X
X    ky->func = fun;
X    return ky;
X}
X
X/* initialize the bindings */
X
Xvoid initxbindtab()
X{				/**/
X    int t0, vi = 0;
X    char buf[3], *s;
X    Key ky;
X
X    lastnamed = z_undefinedkey;
X    for (t0 = 0; t0 != 32; t0++)
X	viins_cur_bindtab[t0] = viinsbind[t0];
X    for (t0 = 32; t0 != 256; t0++)
X	viins_cur_bindtab[t0] = z_selfinsert;
X    viins_cur_bindtab[127] = z_backwarddeletechar;
X    for (t0 = 0; t0 != 128; t0++)
X	emacs_cur_bindtab[t0] = emacsbind[t0];
X    for (t0 = 128; t0 != 256; t0++)
X	emacs_cur_bindtab[t0] = z_selfinsert;
X    em_xbindtab = newhtable(67);
X    vi_xbindtab = newhtable(20);
X    if ((s = zgetenv("VISUAL"))) {
X	if (ztrstr(s, "vi"))
X	    vi = 1;
X    } else if ((s = zgetenv("EDITOR")) && ztrstr(s, "vi"))
X	vi = 1;
X    if (vi) {
X	mainbindtab = viins_cur_bindtab;
X	xbindtab = vi_xbindtab;
X    } else {
X	mainbindtab = emacs_cur_bindtab;
X	xbindtab = em_xbindtab;
X    }
X    for (t0 = 0200; t0 != 0240; t0++)
X	emacs_cur_bindtab[t0] = viins_cur_bindtab[t0] = z_undefinedkey;
X    for (t0 = 0; t0 != 128; t0++)
X	altbindtab[t0] = vicmdbind[t0];
X    for (t0 = 128; t0 != 256; t0++)
X	altbindtab[t0] = emacsbind[t0];
X    bindtab = mainbindtab;
X    if (!kungetbuf)
X	kungetbuf = (char *)zalloc(kungetsz = 32);
X
X    addhnode(ztrdup("\33\133"), ky = makefunckey(z_undefinedkey), em_xbindtab, 0);
X    ky->prefixct = 4;
X    addhnode(ztrdup("\33\133C"), makefunckey(z_forwardchar), em_xbindtab, 0);
X    addhnode(ztrdup("\33\133D"), makefunckey(z_backwardchar), em_xbindtab, 0);
X    addhnode(ztrdup("\33\133A"), makefunckey(z_uplineorhistory), em_xbindtab, 0);
X    addhnode(ztrdup("\33\133B"), makefunckey(z_downlineorhistory), em_xbindtab, 0);
X    addhnode(ztrdup("\33"), ky = makefunckey(z_vicmdmode), vi_xbindtab, 0);
X    ky->prefixct = 4;
X    addhnode(ztrdup("\33\133"), ky = makefunckey(z_undefinedkey), vi_xbindtab, 0);
X    ky->prefixct = 4;
X    addhnode(ztrdup("\33\133C"), makefunckey(z_forwardchar), vi_xbindtab, 0);
X    addhnode(ztrdup("\33\133D"), makefunckey(z_backwardchar), vi_xbindtab, 0);
X    addhnode(ztrdup("\33\133A"), makefunckey(z_uplineorhistory), vi_xbindtab, 0);
X    addhnode(ztrdup("\33\133B"), makefunckey(z_downlineorhistory), vi_xbindtab, 0);
X    addhnode(ztrdup("\30"), ky = makefunckey(z_undefinedkey), em_xbindtab, 0);
X    ky->prefixct = 15;
X    addhnode(ztrdup("\30*"), makefunckey(z_expandword), em_xbindtab, (FFunc) 0);
X    addhnode(ztrdup("\30g"), makefunckey(z_listexpand), em_xbindtab, (FFunc) 0);
X    addhnode(ztrdup("\30G"), makefunckey(z_listexpand), em_xbindtab, (FFunc) 0);
X    addhnode(ztrdup("\30\16"), makefunckey(z_infernexthistory), em_xbindtab, 0);
X    addhnode(ztrdup("\30\13"), makefunckey(z_killbuffer), em_xbindtab, (FFunc) 0);
X    addhnode(ztrdup("\30\6"), makefunckey(z_vifindnextchar), em_xbindtab, (FFunc) 0);
X    addhnode(ztrdup("\30\17"), makefunckey(z_overwritemode), em_xbindtab, (FFunc) 0);
X    addhnode(ztrdup("\30\25"), makefunckey(z_undo), em_xbindtab, (FFunc) 0);
X    addhnode(ztrdup("\30\26"), makefunckey(z_vicmdmode), em_xbindtab, (FFunc) 0);
X    addhnode(ztrdup("\30\12"), makefunckey(z_vijoin), em_xbindtab, (FFunc) 0);
X    addhnode(ztrdup("\30\2"), makefunckey(z_vimatchbracket), em_xbindtab, (FFunc) 0);
X    addhnode(ztrdup("\30s"), makefunckey(z_historyincrementalsearchforward),
X	     em_xbindtab, (FFunc) 0);
X    addhnode(ztrdup("\30r"), makefunckey(z_historyincrementalsearchbackward),
X	     em_xbindtab, (FFunc) 0);
X    addhnode(ztrdup("\30u"), makefunckey(z_undo), em_xbindtab, (FFunc) 0);
X    addhnode(ztrdup("\30\30"), makefunckey(z_exchangepointandmark), em_xbindtab, 0);
X    addhnode(ztrdup("\33"), ky = makefunckey(z_undefinedkey), em_xbindtab, 0);
X    ky->prefixct = 4;
X
X    strcpy(buf, "\33q");
X    for (t0 = 128; t0 != 256; t0++)
X	if (emacsbind[t0] != z_undefinedkey) {
X	    buf[1] = t0 & 0x7f;
X	    addhnode(ztrdup(buf), makefunckey(emacsbind[t0]), em_xbindtab, 0);
X	    ky->prefixct++;
X	}
X    stackhist = stackcs = -1;
X}
X
Xchar *getkeystring(s, len, fromwhere, misc)	/**/
Xchar *s;
Xint *len;
Xint fromwhere;
Xint *misc;
X{
X    char *buf = ((fromwhere == 2)
X		 ? zalloc(strlen(s) + 1) : alloc(strlen(s) + 1));
X    char *t = buf, *u = NULL;
X    char svchar = '\0';
X    int meta = 0, control = 0;
X
X    for (; *s; s++) {
X	if (*s == '\\' && s[1])
X	    switch (*++s) {
X	    case 'a':
X#ifdef __STDC__
X		*t++ = '\a';
X#else
X		*t++ = '\07';
X#endif
X		break;
X	    case 'n':
X		*t++ = '\n';
X		break;
X	    case 'b':
X		*t++ = '\010';
X		break;
X	    case 't':
X		*t++ = '\t';
X		break;
X	    case 'v':
X		*t++ = '\v';
X		break;
X	    case 'f':
X		*t++ = '\f';
X		break;
X	    case 'r':
X		*t++ = '\r';
X		break;
X	    case 'E':
X		if (!fromwhere) {
X		    *t++ = '\\', s--;
X		    continue;
X		}
X	    case 'e':
X		*t++ = '\033';
X		break;
X	    case 'M':
X		if (fromwhere) {
X		    if (s[1] == '-')
X			s++;
X		    meta = 1 + control;	/* preserve the order of ^ and meta */
X		} else
X		    *t++ = '\\', s--;
X		continue;
X	    case 'C':
X		if (fromwhere) {
X		    if (s[1] == '-')
X			s++;
X		    control = 1;
X		} else
X		    *t++ = '\\', s--;
X		continue;
X	    case 'c':
X		if (fromwhere < 2) {
X		    *misc = 1;
X		    break;
X		}
X	    default:
X		if ((idigit(*s) && *s < '8') || *s == 'x') {
X		    if (!fromwhere)
X			if (*s == '0')
X			    s++;
X			else if (*s != 'x') {
X			    *t++ = '\\', s--;
X			    continue;
X			}
X		    if (s[1] && s[2] && s[3]) {
X			svchar = s[3];
X			s[3] = '\0';
X			u = s;
X		    }
X		    *t++ = zstrtol(s + (*s == 'x'), &s,
X				   (*s == 'x') ? 16 : 8);
X		    if (svchar) {
X			u[3] = svchar;
X			svchar = '\0';
X		    }
X		    s--;
X		} else {
X		    if (!fromwhere && *s != '\\')
X			*t++ = '\\';
X		    *t++ = *s;
X		}
X		break;
X	} else if (*s == '^' && fromwhere == 2) {
X	    control = 1;
X	    continue;
X	} else
X	    *t++ = *s;
X	if (meta == 2) {
X	    t[-1] |= 0x80;
X	    meta = 0;
X	}
X	if (control) {
X	    if (t[-1] == '?')
X		t[-1] = 0x7f;
X	    else
X		t[-1] &= 0x9f;
X	    control = 0;
X	}
X	if (meta) {
X	    t[-1] |= 0x80;
X	    meta = 0;
X	}
X    }
X    *t = '\0';
X    *len = t - buf;
X    return buf;
X}
X
Xvoid printbind(s, len)		/**/
Xchar *s;
Xint len;
X{
X    int ch;
X
X    while (len--) {
X	ch = (unsigned char)*s++;
X	if (ch & 0x80) {
X	    printf("\\M-");
X	    ch &= 0x7f;
X	}
X	if (icntrl(ch))
X	    switch (ch) {
X	    case 0x7f:
X		printf("^?");
X		break;
X	    default:
X		printf("^%c", (ch | 0x40));
X		break;
X	} else
X	    putchar(ch);
X    }
X}
X
Xvoid printbinding(str, k)	/**/
Xchar *str;
XKey k;
X{
X    int len;
X
X    if (k->func == z_undefinedkey)
X	return;
X    putchar('\"');
X    printbind(str, (len = strlen(str)) ? len : 1);
X    printf("\"\t");
X    if (k->func == z_sendstring) {
X	putchar('\"');
X	printbind(k->str, k->len);
X	printf("\"\n");
X    } else
X	printf("%s\n", zlecmds[k->func].name);
X}
X
Xint bin_bindkey(name, argv, ops, junc)	/**/
Xchar *name;
Xchar **argv;
Xchar *ops;
Xint junc;
X{
X    int i, *tab;
X
X    if (ops['v'] && ops['e']) {
X	zerrnam(name, "incompatible options", NULL, 0);
X	return 1;
X    }
X    if (ops['v'] || ops['e'] || ops['d'] || ops['m']) {
X	if (*argv) {
X	    zerrnam(name, "too many arguments", NULL, 0);
X	    return 1;
X	}
X	if (ops['d']) {
X	    freehtab(em_xbindtab, freekey);
X	    freehtab(vi_xbindtab, freekey);
X	    initxbindtab();
X	}
X	if (ops['e']) {
X	    mainbindtab = emacs_cur_bindtab;
X	    xbindtab = em_xbindtab;
X	} else if (ops['v']) {
X	    mainbindtab = viins_cur_bindtab;
X	    xbindtab = vi_xbindtab;
X	}
X	if (ops['m'])
X	    for (i = 128; i != 256; i++)
X		if (mainbindtab[i] == z_selfinsert)
X		    mainbindtab[i] = emacsbind[i];
X	return 0;
X    }
X    tab = (ops['a']) ? altbindtab : mainbindtab;
X    if (!*argv) {
X	char buf[2];
X
X	buf[1] = '\0';
X	for (i = 0; i != 256; i++) {
X	    buf[0] = i;
X	    putchar('\"');
X	    printbind(buf, 1);
X	    if (i < 254 && tab[i] == tab[i + 1] && tab[i] == tab[i + 2]) {
X		printf("\" to \"");
X		while (tab[i] == tab[i + 1])
X		    i++;
X		buf[0] = i;
X		printbind(buf, 1);
X	    }
X	    printf("\"\t%s\n", zlecmds[tab[i]].name);
X	}
X	listhtable(xbindtab, (HFunc) printbinding);
X	return 0;
X    }
X    while (*argv) {
X	Key ky = NULL, cur = NULL;
X	char *s;
X	int func, len, firstzero = 0;
X
X	s = getkeystring(*argv++, &len, 2, NULL);
X	if (len > 1) {
X	    if (s[0])
X		firstzero = 0;
X	    else
X		firstzero = 1;
X	    for (i = 0; i < len; i++)
X		if (!s[i])
X		    s[i] = (char)0x80;
X	}
X	if (!*argv || ops['r']) {
X	    if (len == 1)
X		func = tab[(unsigned char)*s];
X	    else
X		func = (ky = (Key) gethnode(s, xbindtab)) ? ky->func
X		    : z_undefinedkey;
X	    if (func == z_undefinedkey) {
X		zerrnam(name, "in-string is not bound", NULL, 0);
X		zfree(s, len);
X		return 1;
X	    }
X	    if (ops['r']) {
X		if (len == 1 && func != z_sequenceleadin) {
X		    tab[(unsigned char)*s] = z_undefinedkey;
X		    if (func == z_sendstring)
X			free(remhnode(s, xbindtab));
X		} else {
X		    if (ky->prefixct) {
X			if (ky->func == z_sendstring)
X			    zfree(ky->str, ky->len);
X			ky->func = z_undefinedkey;
X		    } else
X			free(remhnode(s, xbindtab));
X		    if (len > 1) {
X			s[--len] = '\0';
X			while (len > 1) {
X			    (ky = (Key) gethnode(s, xbindtab))->prefixct--;
X			    if (!ky->prefixct && ky->func == z_undefinedkey)
X				free(remhnode(s, xbindtab));
X			    s[--len] = '\0';
X			}
X			(ky = (Key) gethnode(s, xbindtab))->prefixct--;
X			if (!ky->prefixct) {
X			    tab[(unsigned char)*s] = ky->func;
X			    if (ky->func != z_sendstring)
X				free(remhnode(s, xbindtab));
X			}
X		    }
X		}
X		zfree(s, len);
X		continue;
X	    }
X	    if (func == z_sendstring) {
X		if (len == 1)
X		    ky = (Key) gethnode(s, xbindtab);
X		printbind(ky->str, ky->len);
X		putchar('\n');
X	    } else
X		printf("%s\n", zlecmds[func].name);
X	    zfree(s, len);
X	    return 0;
X	}
X	if (!ops['s']) {
X	    for (i = 0; i != ZLECMDCOUNT; i++)
X		if (!strcmp(*argv, zlecmds[i].name))
X		    break;
X	    if (i == ZLECMDCOUNT) {
X		zerr("undefined function: %s", *argv, 0);
X		zfree(s, len);
X		return 1;
X	    }
X	    func = i;
X	} else
X	    func = z_sendstring;
X
X	if (len == 1 && tab[(unsigned char)*s] != z_sequenceleadin) {
X	    if (ops['s']) {
X		addhnode(ztrdup(s), cur = makefunckey(z_sendstring),
X			 xbindtab, freekey);
X	    } else if (tab[(unsigned char)*s] == z_sendstring)
X		free(remhnode(s, xbindtab));
X	    tab[(unsigned char)*s] = func;
X	} else {
X	    if (!(cur = (Key) gethnode(s, xbindtab))
X		|| (cur->func == z_undefinedkey))
X		for (i = len - 1; i > 0; i--) {
X		    char sav;
X
X		    sav = s[i];
X		    s[i] = '\0';
X		    if (i == 1 && firstzero)
X			*s = '\0';
X		    if (!(ky = (Key) gethnode(s, xbindtab)))
X			addhnode(ztrdup(s), ky = makefunckey(z_undefinedkey),
X				 xbindtab, freekey);
X		    ky->prefixct++;
X		    s[i] = sav;
X		    if (i == 1 && firstzero)
X			*s = (char)0x80;
X		}
X	    if (cur) {
X		cur->func = func;
X		zfree(cur->str, cur->len);
X	    } else
X		addhnode(ztrdup(s), cur = makefunckey(func), xbindtab, freekey);
X	    if (firstzero)
X		*s = 0;
X	    if (tab[(unsigned char)*s] != z_sequenceleadin) {
X		cur->func = tab[(unsigned char)*s];
X		tab[(unsigned char)*s] = z_sequenceleadin;
X	    }
X	}
X	if (ops['s']) {
X	    cur->str = getkeystring(*argv, &cur->len, 2, NULL);
X	    cur->str = (char *)realloc(cur->str, cur->len);
X	}
X	argv++;
X	zfree(s, len);
X    }
X    return 0;
X}
X
Xvoid freekey(x)			/**/
Xvptr x;
X{
X    Key k = (Key) x;
X
X    if (k->str)
X	zsfree(k->str);
X    zfree(k, sizeof(struct key));
X}
X
Xextern int clearflag;
X
Xvoid trashzle()
X{				/**/
X    if (zleactive) {
X	refresh();
X	moveto(nlnct, 0);
X	if (clearflag && tccan(TCCLEAREOD)) {
X	    tcout(TCCLEAREOD);
X	    clearflag = 0;
X	}
X	printf("%s", postedit);
X	fflush(stdout);
X	resetneeded = 1;
X	settyinfo(&shttyinfo);
X    }
X    if (errflag)
X	kungetct = 0;
X}
END_OF_FILE
  if test 23103 -ne `wc -c <'zsh-2.5.0/src/zle_main.c'`; then
    echo shar: \"'zsh-2.5.0/src/zle_main.c'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/src/zle_main.c'
fi
echo shar: End of archive 8 \(of 18\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
