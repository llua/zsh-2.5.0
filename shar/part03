Path: news.csc.fi!news.eunet.fi!EU.net!uunet!sparky!not-for-mail
From: zsh-list@sterling.com (Bas de Bakker)
Newsgroups: comp.sources.misc
Subject: v43i092:  zsh - The Z shell, version 2.5.0, Part03/18
Followup-To: comp.sources.d
Date: 13 Jul 1994 23:02:00 -0500
Organization: Sterling Software
Lines: 3034
Sender: kent@sparky.sterling.com
Approved: kent@sparky.sterling.com
Message-ID: <302dbo$squ@sparky.sterling.com>
References: <csm-v43i089=zsh.230017@sparky.sterling.com>
NNTP-Posting-Host: sparky.sterling.com
X-Md4-Signature: 60d9e7e5109c9e98ad1eb40085388320

Submitted-by: zsh-list@sterling.com (Bas de Bakker)
Posting-number: Volume 43, Issue 92
Archive-name: zsh/part03
Environment: UNIX
Supersedes: zsh: Volume 35, Issue 51-72

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  zsh-2.5.0/man/zsh.1.A zsh-2.5.0/src/config/bz.config.h
# Wrapped by kent@sparky on Tue Jul 12 16:47:17 1994
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 3 (of 18)."'
if test -f 'zsh-2.5.0/man/zsh.1.A' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/man/zsh.1.A'\"
else
  echo shar: Extracting \"'zsh-2.5.0/man/zsh.1.A'\" \(71886 characters\)
  sed "s/^X//" >'zsh-2.5.0/man/zsh.1.A' <<'END_OF_FILE'
X.\"
X.TH ZSH 1 "3 June 1994" "zsh version 2.5.0"
X.SH NAME
Xzsh \- the Z shell
X.SH SYNOPSIS
X\fBzsh\fP [ \(+-\fIoptions\fP ] [ \(+-\fBo\fP \fIoption\fP ] ...  [ \-\fBc\fP \fIstring\fP ] [ \fIarg\fP ... ]
X.SH "SHELL GRAMMAR"
XA \fIsimple command\fP is a sequence of optional parameter
Xassignments followed by blank-separated words,
Xwith optional redirections interspersed.
XThe first word is the command to be executed, and the remaining
Xwords, if any, are arguments to the command.
XIf a command name is given, the parameter assignments modify
Xthe environment of the command when it is executed.
XThe value of a simple command is its exit status,
Xor 128 plus the signal number if terminated by a signal.
X.PP
XIf a simple command is preceded by the word \fBexec\fP,
Xit is executed in the parent shell without forking.
XIf preceded by \fBcommand\fP, the command word is taken
Xto be the name of an external command, rather than a
Xshell function or builtin.
XIf preceded by \fBnoglob\fP, filename generation is not performed
Xon any of the words.  If preceded by a \-, the command
Xis executed with a \- prepended to its \fBargv[0]\fP string.
XIf preceded by \fBnocorrect\fP, spelling correction is not
Xdone on any of the words.
X.PP
XA \fIpipeline\fP is a sequence of one or more commands
Xseparated by \fB|\fP or \fB|&\fP.  \fB|&\fP is shorthand
Xfor \fB2>&1 |\fP.  The standard output of each command is
Xconnected to the standard input of the next command in the
Xpipeline.
X.PP
XThe value of a pipeline is the value of the last command.
XIf a pipeline is preceded by a \fB!\fP, the value
Xof that pipeline is the logical NOT of the value of the last
Xcommand.
X.PP
XIf a pipeline is preceded by \fBcoproc\fP, it is
Xexecuted as a coprocess; a two-way pipe is established
Xbetween it and the parent shell.  The shell can read from or write to
Xthe coprocess by means of the \fB>&p\fP and \fB<&p\fP
Xredirection operators.
X.PP
XA \fIsublist\fP is a sequence of one or more pipelines
Xseparated by \fB&&\fP or \fB|\||\fP.  If two pipelines
Xare separated by \fB&&\fP, the second pipeline is executed
Xonly if the first is successful (returns a zero value).
XIf two pipelines are separated by \fB|\||\fP, the second is executed
Xonly if the first is unsuccessful (returns a nonzero value).  Both
Xoperators have equal precedence and are left associative.
X.PP
XA \fIlist\fP is a sequence of one or more sublists
Xseparated by, and optionally terminated by, \fB;\fP, \fB&\fP,
Xor a newline.
XNormally the shell waits for each list to finish before executing
Xthe next one.
XIf a list is terminated by a \fB&\fP, the shell executes
Xit in the background, and does not wait for it to finish.
X.PP
XA \fIcomplex command\fP is one of the following:
X.PP
X.RS
X.PD 0
X.TP
X\fBfor\fP \fIname\fP [ \fBin\fP \fIword\fP ... ]
X.TP
X\fBdo\fP \fIlist\fP
X.TP
X\fBdone\fP
X.PD
XExpand the list of \fIword\fPs, and set the parameter
X\fIname\fP to each of them in turn, executing
X\fIlist\fP each time.  If the \fBin\fP \fIword\fP is omitted,
Xuse the positional parameters instead of the \fIword\fPs.
X.TP
X\fBfor\fP \fIname\fP [ \fBin\fP \fIword\fP ... ] ; \fIsublist\fP
XThis is a shorthand for \fBfor\fP.
XThough it may cause confusion, it is included for convenience;
Xits use in scripts is discouraged,
Xunless \fIsublist\fP is a command of the form { \fIlist\fP }.
X.PP
X.PD 0
X.TP
X\fBforeach\fP \fIname\fP \fB(\fP \fIword\fP ... \fB)\fP
X.TP
X\fIlist\fP
X.TP
X\fBend\fP
X.PD
XAnother form of \fBfor\fP.
X.PP
X.PD 0
X.TP
X\fBfor\fP \fIname\fP \fBin\fP \fIword\fP ...
X.TP
X\fB{\fP
X.TP
X\fIlist\fP
X.TP
X\fB}\fP
X.PD
XAnother form of \fBfor\fP.
X.PP
X.PD 0
X.TP
X\fBfor\fP \fIname\fP \fB(\fP \fIword\fP ... \fB) {\fP
X.TP
X\fIlist\fP
X.TP
X\fB}\fP
X.PD
XAnother form of \fBfor\fP:  this requires the option \fBCSH_JUNKIE_PAREN\fP.
X.PP
X.PD 0
X.TP
X\fBfor\fP \fIname\fP \fB(\fP \fIword\fP ... \fB) \fIsublist\fP
X.PD
XAnother form of \fBfor\fP:  this also requires \fBCSH_JUNKIE_PAREN\fP.
X.PP
X.PD 0
X.TP
X\fBselect\fP \fIname\fP [ \fBin\fP \fIword\fP ... ]
X.TP
X\fBdo\fP \fIlist\fP
X.TP
X\fBdone\fP
X.PD
XPrint the set of \fIword\fPs, each preceded by a number.
XIf the \fBin\fP \fIword\fP is omitted, use the positional parameters.
XThe \fBPROMPT3\fP prompt is printed and a line is read from standard
Xinput.  If this line consists of the number of one of the listed
X\fIword\fPs, then the parameter \fIname\fP
Xis set to the \fIword\fP corresponding to this number.
XIf this line is empty, the selection list is printed again.
XOtherwise, the value of the parameter \fIname\fP is set to null.
XThe contents of the line read from standard input is saved
Xin the parameter \fBREPLY\fP.  \fIlist\fP is executed
Xfor each selection until a break or end-of-file is encountered.
X.TP
X\fBselect\fP \fIname\fP [ \fBin\fP \fIword\fP ] ; \fIsublist\fP
XA short form of \fBselect\fP.
X.TP
X\fBcase\fP \fIword\fP \fBin\fP [ \fIpattern\fP ) \fIlist\fP ;; ] ...  \fBesac\fP
XExecute the \fIlist\fP associated with the first \fIpattern\fP
Xthat matches \fIword\fP, if any.  The form of the patterns
Xis the same as that used for filename generation.  See
X\fIFilename Generation\fP below.
X.TP
X\fBcase\fP \fIword\fP \fB{\fP [ \fIpattern\fP ) \fIlist\fP ;; ] ...  \fB}\fP
XAnother form of \fBcase\fP.
X.TP
X.PD 0
X\fBif\fP \fIlist\fP
X.TP
X\fBthen\fP \fIlist\fP
X.TP
X[ \fBelif\fP \fIlist\fP ; \fBthen\fP \fIlist\fP ] ...
X.TP
X[ \fBelse\fP \fIlist\fP ]
X.TP
X\fBfi\fP
X.PD
XThe \fBif\fP \fIlist\fP is executed, and,
Xif it returns a zero exit status,
Xthe \fBthen\fP \fIlist\fP is executed.
XOtherwise, the \fBelif\fP \fIlist\fP is
Xexecuted and, if its value is zero,
Xthe \fBthen\fP \fIlist\fP is executed.
XIf each \fBelif\fP \fIlist\fP returns
Xnonzero, the \fBelse\fP \fIlist\fP is executed.
X.TP
X\fBif (\fP \fIlist\fP \fB)\fP \fIsublist\fP
XA short form of \fBif\fP:  this requires the option \fBCSH_JUNKIE_PAREN\fP.
X.PP
X.PD 0
X.TP
X\fBif\fP \fB(\fP \fIlist\fP \fB) {\fP
X.TP
X\fIlist\fP
X.TP
X\fB} elif (\fP \fIlist\fP \fB) {\fP
X.TP
X\fIlist\fP
X.TP
X\fB} ... else {\fP
X.TP
X\fIlist\fP
X.TP
X\fB}\fP
X.PD
XAn alternative form of \fBif\fP. The parentheses surrounding
X\fIlist\fP can be omitted if the only command in the list is a
Xconditional expression of the form [[ exp ]] (see below).  This form
Xalso requires \fBCSH_JUNKIE_PAREN\fP.
X.TP
X.PD 0
X\fBwhile\fP \fIlist\fP
X.TP
X\fBdo\fP \fIlist\fP
X.TP
X\fBdone\fP
X.PD
XExecute the \fBdo\fP \fIlist\fP as long as the \fBwhile\fP \fIlist\fP
Xreturns a zero exit status.
X.PP
X.PD 0
X.TP
X\fBwhile (\fP \fIlist\fP \fB) {\fP
X.TP
X\fIlist\fP
X.TP
X\fB}\fP
X.PD
XAn alternative form of \fBwhile\fP:  this requires the option
X\fBCSH_JUNKIE_PAREN\fP.
X.TP
X.PD 0
X\fBuntil\fP \fIlist\fP
X.TP
X\fBdo\fP \fIlist\fP
X.TP
X\fBdone\fP
X.PD
XExecute the \fBdo\fP \fIlist\fP as long as \fBuntil\fP \fIlist\fP
Xreturns a nonzero exit status.
X.TP
X.PD 0
X\fBrepeat\fP \fIword\fP
X.TP
X\fBdo\fP \fIlist\fP
X.TP
X\fBdone\fP
X.PD
X\fIword\fP is expanded and treated as an arithmetic expression,
Xwhich must evaluate to a number \fIn\fP.
X\fIlist\fP is then executed \fBn\fP times.
X.TP
X\fBrepeat\fP \fIword\fP \fIsublist\fP
XThis is a short form of \fBrepeat\fP.
X.TP
X( \fIlist\fP )
XExecute \fIlist\fP in a subshell.
X.TP
X{ \fIlist\fP }
XExecute \fIlist\fP.
X.TP
X.PD 0
X\fBfunction\fP \fIword\fP [ (\|) ] ... { \fIlist\fP }
X.TP
X\fIword\fP ... (\|) { \fIlist\fP }
X.TP
X\fIword\fP ... (\|) \fIsublist\fP
X.PD
XDefine a function which is referenced by any one of \fIword\fP.
XNormally, only one \fIword\fP is provided; multiple \fIword\fPs
Xare usually only useful for setting traps.
XThe body of the function is the \fIlist\fP between
Xthe { and }.
XSee \fBFUNCTIONS\fP below.
X.TP
X\fBtime\fP [ \fIpipeline\fP ]
XThe \fIpipeline\fP is executed, and timing statistics are
Xreported on the standard error in the form specified
Xby the \fBTIMEFMT\fP parameter.
XIf \fIpipeline\fP is omitted, print statistics about the
Xshell process and its children.
X.TP
X[[ \fIexp\fP ]]
XEvaluates the conditional expression \fIexp\fP
Xand return a zero exit status if it is true.
XSee \fBConditional Expressions\fP below for a description
Xof \fIexp\fP.
X.SH "RESERVED WORDS"
XThe following words are recognized as reserved words when used 
Xas the first word of a command
Xunless quoted or removed using the \fBunalias\fP builtin:
X.RS
X.PP
X\fBdo done esac then elif else fi for case
Xif while function repeat time until exec command
Xselect coproc noglob \- nocorrect foreach end\fP
X.RE
X.SH COMMENTS
XIn noninteractive shells, or in interactive shells with the
X\fBINTERACTIVE_COMMENTS\fP option set, a word beginning
Xwith the third character of the \fBHISTCHARS\fP parameter
X(`#' by default) causes that word and all the following
Xcharacters up to a newline to be ignored.
X.SH ALIASING
XEvery token in the shell input is checked to see if there
Xis an alias defined for it.
XIf so, it is replaced by the text of the alias if it is in command
Xposition (if it could be the first word of a simple command),
Xor if the alias is global.
XIf the text ends with a space, the next word in the shell input
Xis treated as though it were in command position for purposes of alias
Xexpansion.
XAn alias is defined using the \fBalias\fP builtin; global aliases
Xmay be defined using the \-\fBg\fP option to that builtin.
X.PP
XAlias substitution is done on the shell input before any
Xother substitution except history substitution.  Therefore,
Xif an alias is defined for the word \fBfoo\fP, alias substitution
Xmay be avoided by quoting part of the word, e.g. \fB\efoo\fP.
XBut there is nothing to prevent an alias being defined
Xfor \fB\efoo\fP as well.
X.SH QUOTING
XA character may be \fIquoted\fP (that is, made
Xto stand for itself) by preceding it with a \e\|.
X\e followed by a newline is ignored.
XAll characters enclosed between a pair of single quotes ('')
Xare quoted, except the first character of HISTCHARS ( `!' by default).
XA single quote cannot appear within single quotes.
XInside double quotes (""), parameter and command substitution
Xoccurs, and \e quotes the characters \e\|, `, ", and $.
X.SH EXPANSION
XExpansion is performed on the command line after it has been
Xparsed.  The types of expansions performed are
X\fIfilename expansion\fP, 
X\fIprocess substitution\fP,
X\fIparameter expansion\fP,
X\fIcommand substitution\fP,
X\fIarithmetic expansion\fP,
X\fIbrace expansion\fP,
Xand \fIfilename generation\fP.
X.SS Filename Expansion
XEach word is checked to see if it begins with an unquoted ~.
XIf it does, then the word up to a / is checked to see if it matches
Xthe name of a named directory.  If so, then the ~ and the matched portion
Xare replaced with the value of the named directory.
XA ~ by itself or followed by a / is replaced by the value of the
X\fBHOME\fP parameter.
XA ~ followed by a + or a \- is replaced by the value of 
X\fBPWD\fP or \fBOLDPWD\fP, respectively.
X.PP
XNamed directories are typically login directories for users on the system.
XThey may also be defined if the text after the ~ is the name
Xof a string shell parameter whose value begins with a /.
XIn certain circumstances (in prompts, for instance), when the shell
Xprints a path, the path is checked to see if it has a named
Xdirectory as its prefix.  If so, then the prefix portion
Xis replaced with a ~ followed by the name of the directory.
XThe longest match is preferred.
X.PP
XIf a word begins with an unquoted \fB=\fP and the
X\fBNO_EQUALS\fP option is not set,
Xthe remainder of the word is taken as the
Xname of a command or alias.  If a command
Xexists by that name, the word is replaced
Xby the full pathname of the command.
XIf an alias exists by that name, the word
Xis replaced with the text of the alias.
XOtherwise the word is checked up to a /
Xto see if it is a number or a \-.  If so,
Xthe matched portion is replaced with
Xthe \fIn\fPth directory in the directory stack,
Xwhere \fIn\fP is the number matched, or
Xthe last directory in the directory stack
Xif a \- is matched.
X.PP
XFilename expansion is performed on the right hand side of a parameter
Xassignment, including those appearing after commands of the
X\fBtypeset\fR family.  In this case, the right hand side will be treated
Xas a colon-separated list in the manner of \fBPATH\fR so that a ~ or an
X= following a : is eligible for expansion.  All such behavior can be
Xdisabled by quoting the ~, the =, or the whole expression (but not
Xsimply the colon); the \fBNO_EQUALS\fP option is also respected.
X.PP
XIf the option \fBMAGIC_EQUAL_SUBST\fP is set, any unquoted shell
Xargument in the form \fIidentifier\fP=\fIexpression\fP becomes eligible
Xfor file expansion as described in the previous paragraph.  Quoting the
Xfirst = also inhibits this.
X.SS Process Substitution
XEach command argument of the form
X\fB<(\fIlist\^\fB)\fR
Xor
X\fB>(\fIlist\^\fB)\fR
Xor
X\fB=(\fIlist\^\fB)\fR
Xis subject to process substitution.
XIn the case of the
X.B <
Xor
X.B >
Xforms, the shell will run process
X.I list
Xasynchronously connected to a named pipe (FIFO).
XThe name of this pipe will become the argument to the command.
XIf the form with
X.B >
Xis selected then writing on this file will provide input for
X.IR list .
XIf
X.B <
Xis used,
Xthen the file passed as an argument will
Xbe a named pipe connected to the output of the
X.I list
Xprocess.
XFor example,
X.RS
X.PP
X\fBpaste <(cut \-f1\fP \fIfile1\fB) <(cut \-f3\fP \fIfile2\fB) | tee >(\fIprocess1\fB) >(\fIprocess2\fB)\fR >/dev/null
X.RE
X.PP
X.BR cut s
Xfields 1 and 3 from
Xthe files
X.I file1
Xand
X.I file2
Xrespectively,
X.BR paste s
Xthe results together, and sends it to the processes
X.I process1
Xand
X.IR process2 .
XNote that the file, which is passed as an argument to the command,
Xis a system
Xpipe 
Xso programs that expect to
X.BR lseek (2)
Xon the file will not work.
XAlso note that the previous example can be more compactly and
Xefficiently written as:
X.RS
X.PP
X\fBpaste <(cut \-f1\fP \fIfile1\fB) <(cut \-f3\fP \fIfile2\fB) > >(\fIprocess1\fB) > >(\fIprocess2\fB)\fR
X.RE
X.PP
XThe shell uses pipes instead of FIFOs to implement the latter
Xtwo process substitutions in the above example.
X.PP
XIf
X.B =
Xis used,
Xthen the file passed as an argument will be the name
Xof a temporary file containing
Xthe output of the
X.I list
Xprocess.  This may be used instead of the
X.B <
Xform for a program that expects to \fBlseek\fP(2) on the input file.
X.SS Parameter Expansion
XThe character \fB$\fP is used to introduce parameter expansions.
XSee \fBPARAMETERS\fP below for a description of parameters.
X.PD
X.RS
X.TP
X\fB${\fIname\fB}\fR
XThe value, if any, of the parameter \fIname\fP is substituted.
XThe braces are required if \fIname\fP is followed by
Xa letter, digit, or underscore that is not to be interpreted
Xas part of its name.
XIf \fIname\fP is an array parameter, then the values of each
Xelement of \fIname\fP is substituted, one element per word.
XOtherwise, the expansion results in one word only; no
Xword splitting is done on the result.
X.TP
X\fB${+\fIname\fB}\fR
XIf \fIname\fP is the name of a set parameter `1' is substituted,
Xotherwise `0' is substituted.
X.TP
X\fB${\fIname\fB:\-\fIword\fB}\fR
XIf \fIname\fP is set and is non-null then substitute its
Xvalue; otherwise substitute \fIword\fP.
X.TP
X\fB${\fIname\fB:=\fIword\fB}\fR
XIf \fIname\fP is unset or is null then
Xset it to \fIword\fP; the value of the parameter is then
Xsubstituted.
X.TP
X\fB${\fIname\fB:?\fIword\fB}\fR
XIf \fIname\fP is set and is non-null, then substitute
Xits value; otherwise, print \fIword\fP and exit from the shell.
XIf \fIword\fP is omitted, then a standard message is printed.
X.TP
X\fB${\fIname\fB:+\fIword\fB}\fR
XIf \fIname\fP is set and is non-null then substitute
X\fIword\fP; otherwise substitute nothing.
X.PD 0
X.TP
X\fB${\fIname\fB#\fIpattern\fB}\fR
X.TP
X\fB${\fIname\fB##\fIpattern\fB}\fR
X.PD
XIf the \fIpattern\fP matches the beginning of the value of
X\fIname\fP, then substitute the value of \fIname\fP with
Xthe matched portion deleted; otherwise, just
Xsubstitute the value of \fIname\fP.  In the first
Xform, the smallest matching pattern is preferred;
Xin the second form, the largest matching pattern is preferred.
X.PD 0
X.TP
X${\fIname\fB%\fIpattern\fR}
X.TP
X${\fIname\fB%%\fIpattern\fR}
X.PD
XIf the \fIpattern\fP matches the end of the value of
X\fIname\fP, then substitute the value of \fIname\fP with
Xthe matched portion deleted; otherwise, just
Xsubstitute the value of \fIname\fP.  In the first
Xform, the smallest matching pattern is preferred;
Xin the second form, the largest matching pattern is preferred.
X.TP
X${\fB#\fIspec\fR}
XIf \fIspec\fP is one of the above substitutions, substitute
Xthe length in characters of the result instead of
Xthe result itself.  If \fIspec\fP is an array expression,
Xsubstitute the number of elements of the result.
X.TP
X${\fB^\fIspec\fR}
XToggle the value of the \fBRC_EXPAND_PARAM\fP option for the
Xevaluation of \fIspec\fP.
XWhen this option is set, array expansions of the form
X\fIfoo\fB${\fIxx\fB}\fIbar\fR, where the parameter
X\fIxx\fP is set to (\fIa b c\fP), are substituted with
X\fIfooabar foobbar foocbar\fP instead of the default
X\fIfooa b cbar\fP.
X.TP
X${\fB=\fIspec\fR}
XToggle the value of the \fBSH_WORD_SPLIT\fP option for the
Xevaluation of \fIspec\fP.
XWhen this option is set, parameter values are split into
Xseparate words using \fBIFS\fP as a delimiter
Xbefore substitution.
XThis is done by default in most other shells.
X.TP
X${\fB~\fIspec\fR}
XToggle the value of the \fBGLOB_SUBST\fP option for the evaluation of
X\fIspec\fP.  When this option is set, any pattern characters resulting
Xfrom the substitution become eligible for file expansion and filename
Xgeneration.
X.PD
X.RE
X.PP
XIf the colon is omitted from one of the above expressions
Xcontaining a colon, then the shell only checks whether
X\fIname\fP is set or not, not whether it is null.
X.PP
XIf the opening brace is directly followed by an opening parentheses
Xthe string up to the matching closing parentheses will be taken as a
Xlist of flags.  Where arguments are valid, any character, or the
Xmatching pairs `(...)', `{...}', `[...]', or `<...>',  may be used
Xin place of the colon as delimiters.  The following flags are supported:
X.PD
X.RS
X.TP
X.B o
XSort the resulting words in ascending order.
X.TP
X.B O
XSort the resulting words in descending order.
X.TP
X.B i
XWith \fBo\fP or \fBO\fP, sort case-independently.
X.TP
X.B L
XConvert all letters in the result to lower case.
X.TP
X.B U
XConvert all letters in the result to upper case.
X.TP
X.B C
XCapitalize the resulting words.
X.TP
X.B c
XWith ${#\fIname\fP}, count the total number of characters in an array,
Xas if the elements were concatenated with spaces between them.
X.TP
X.B w
XWith ${#\fIname\fP}, count words in arrays or strings; the \fIs\fP
Xflag may be used to set a word delimiter.
X.TP
X.B l:\fIexpr\fB::\fIstring1\fB::\fIstring2\fB:
XPad the resulting words on the left.  Each word will be truncated if
Xrequired and placed in a field \fIexpr\fP characters wide.  The space
Xto the left will be filled with \fIstring1\fP (concatenated as often
Xas needed) or spaces if \fIstring1\fP is not given.  If both
X\fIstring1\fP and \fIstring2\fP are given, this string will be placed
Xexactly once directly to the left of the resulting word.
X.TP
X.B r:\fIexpr\fB::\fIstring1\fB::\fIstring2\fB:
XAs \fBl...\fP, but pad the words on the right.
X.TP
X.B j:\fIstring\fB:
XJoin the words of arrays together using \fIstring\fP as a separator.
XNote that this occurs before word splitting by the \fBSH_WORD_SPLIT\fP
Xoption.
X.TP
X.B s:\fIstring\fB:
XForce word splitting (see the option \fBSH_WORD_SPLIT\fP) at the
Xseparator \fIstring\fP.  Splitting only occurs in places where an
Xarray value is valid.
X.TP
X.B S
X(This and all remaining flags are used with the \fB${...#...}\fP or
X\fB${...%...}\fP forms):
Xsearch substrings as well as beginnings or ends.
X.TP
X.B I:\fIexpr\fB:
XSearch the \fIexpr\fP'th match (where \fIexpr\fP evaluates to a number).
X.TP
X.B M
XInclude the matched portion in the result.
X.TP
X.B R
XInclude the unmatched portion in the result (the \fIR\fPest).
X.TP
X.B B
XInclude the index of the beginning of the match in the result.
X.TP
X.B E
XInclude the index of the end of the match in the result.
X.TP
X.B N
XInclude the length of the match in the result.
X.PD
X.RE
X.PP
X.SS Command Substitution
XA command enclosed in parentheses
Xpreceded by a dollar sign, like so: $(...) or quoted with grave
Xaccents: `...` is replaced with its standard output.
XIf the substitution is not enclosed in double quotes, the
Xoutput is broken into words using the \fBIFS\fP parameter.
XThe substitution \fB$(cat foo)\fP may be replaced
Xby the equivalent but faster \fB$(<foo)\fP.  In either case, if the
Xoption \fBGLOB_SUBST\fP is set the output is eligible for filename
Xgeneration.
X.SS Arithmetic Expansion
XA string of the form \fB$[\fIexp\fB]\fR is substituted
Xwith the value of the arithmetic expression \fIexp\fP.
XSee \fBARITHMETIC EVALUATION\fP below.
X.SS Brace Expansion
XA string of the form
X\fIfoo\fB{\fIxx\fB,\fIyy\fB,\fIzz\fB}\fIbar\fR
Xis expanded to the individual words
X\fIfooxxbar\fP, \fIfooyybar\fP, and \fIfoozzbar\fP.
XLeft-to-right order is preserved.  This construct
Xmay be nested.  Malformed brace expansion expressions,
Xincluding expressions without a comma, are left unchanged
Xby the shell.
X.PP
XAn expression of the form
X\fB{\fIx\fB\-\fIy\fB}\fR,
Xwhere \fIx\fP and \fIy\fP are single characters,
Xis expanded to every character between
X\fIx\fP and \fIy\fP, inclusive.
X.SS Filename Generation
XIf a word contains an unquoted instance of one of the characters
X*, |, <, [, or ?, it is regarded
Xas a pattern for filename generation, unless the \fBNO_GLOB\fP option is set.
XIf the \fBEXTENDED_GLOB\fP option is set, the
X^,  ~ and # characters also denote a pattern; otherwise
X(except for an initial ~, see \fBFilename Expansion\fP above)
Xthey are not treated specially by the shell.
XThe word is replaced with a list of sorted filenames that match
Xthe pattern.  If no matching pattern is found, the shell gives
Xan error message, unless the \fBNULL_GLOB\fP option is set,
Xin which case the word is deleted; or unless the \fBNO_NOMATCH\fP
Xoption is set, in which case the word is left unchanged.
XIn filename generation,
Xthe character / must be matched explicitly; also, a . must be matched
Xexplicitly at the beginning of a pattern or after a /, unless the
X\fBGLOB_DOTS\fP option is set.  No filename generation pattern
Xmatches the files "." or "..".  In other instances of pattern
Xmatching, the / and . are not treated specially.
X.PP
X.RS
X.PD 0
X.TP
X.B *
Xmatches any string, including the null string.
X.TP
X.B ?
Xmatches any character.
X.TP
X\fB[ ... ]\fP
Xmatches any of the enclosed characters.
X.TP
X\fB[^ ... ]\fP
Xmatches any character except the enclosed characters.
X\fB[! ... ]\fP
Xis the same as the above.
X.TP
X\fB<x\-y>\fP
Xmatches any number in the range x to y, inclusive.
XIf x is omitted, the number must be less than or equal to y.
XIf y is omitted, the number must be greater than or equal to x.
XA pattern of the form \fB<\->\fP or
Xsimply \fB<>\fP matches any number.
X.TP
X\fB^x\fP
Xmatches anything except the pattern x.
X.TP
X\fBx|y\fP
Xmatches either x or y.
X.TP
X\fBx#\fP
Xmatches zero or more occurrences of the pattern x.
X.TP
X\fBx##\fP
Xmatches one or more occurrences of the pattern x.
X.RE
X.PD
X.PP
XParentheses may be used for grouping.  Note that the \fB|\fP character
Xmust be within parentheses, so that the lexical analyzer does
Xnot think it is a pipe character.  Also note that "/" has a
Xhigher precedence than "^"; that is:
X.RS
X.PP
Xls
X.BI ^ foo / bar
X.RE
X.PP
Xwill search directories in "." except "./foo" for a file named bar.
X.PP
XA pathname component of the form
X.BI ( foo /)#
Xmatches a path consisting of zero or more directories
Xmatching the pattern foo.
XAs a shorthand,
X.B **/
Xis equivalent to
X.BR (*/)# .
XThus:
X.RS
X.PP
Xls
X.BI (*/)# bar
X.RE
X.PP
Xor
X.RS
X.PP
Xls
X.BI **/ bar
X.RE
X.PP
Xdoes a recursive directory search for files named bar.
X.PP
XIf used for filename generation, a pattern may contain an exclusion
Xspecifier.  Such patterns are of the form \fIpat1\fB~\fIpat2\fR.
XThis pattern will generate all files matching \fIpat1\fP, but which
Xdo not match \fIpat2\fP.  For example, \fB*.c~lex.c\fP will match
Xall files ending in .c, except the file \fBlex.c\fP.  This may appear
Xinside parentheses.  Note that "~" has a higher precedence than "|",
Xso that \fIpat1\fB|\fIpat2\fB~\fIpat3\fR matches any time that
X\fIpat1\fR matches, or if \fIpat2\fR matches while \fIpat3\fR does
Xnot.  Note also that "/" characters are not treated specially in the
Xexclusion specifier so that a "*" will match multiple path segments if
Xthey appear in the pattern to the left of the "~".
X.PP
XPatterns used for filename generation may also end in a
Xlist of qualifiers enclosed in parentheses.
XThe qualifiers
Xspecify which filenames that otherwise match the given pattern
Xwill be inserted in the argument list.
XA qualifier may be any one of the following:
X.PD 0
X.RS
X.TP
X.B /
Xdirectories
X.TP
X.B .
Xplain files
X.TP
X.B @
Xsymbolic links
X.TP
X.B =
Xsockets
X.TP
X.B p
Xnamed pipes (FIFOs)
X.TP
X.B *
Xexecutable plain files (0100)
X.TP
X.B %
Xdevice files (character or block special)
X.TP
X.B %b
Xblock special files
X.TP
X.B %c
Xcharacter special files
X.TP
X.B r
Xreadable files (0400)
X.TP
X.B w
Xwritable files (0200)
X.TP
X.B x
Xexecutable files (0100)
X.TP
X.B R
Xworld-readable files (0004)
X.TP
X.B W
Xworld-writable files (0002)
X.TP
X.B X
Xworld-executable files (0001)
X.TP
X.B s
Xsetuid files (04000)
X.TP
X.B S
Xsetgid files (02000)
X.TP
X\fBd\fIdev\fR
Xfiles on the device \fIdev\fP
X.TP
X\fBl\fI[-|+]ct\fR
Xfiles having a link count less than \fIct\fP (-), greater than
X\fIct\fP (+), or is equal to \fIct\fP
X.TP
X\fBU\fP
Xfiles owned by the effective user id
X.TP
X\fBG\fP
Xfiles owned by the effective group id
X.TP
X\fBu\fIid\fR
Xfiles owned by user id \fIid\fP if it is a number, if not, than the
Xcharacter after the \fBu\fP will be used as a separator and the string
Xbetween it and the next matching separator (`(', `[', `{', and `<'
Xmatch `)', `]', `}', and `>' respectively, any other character matches
Xitself) will be taken as a user name and the user id of this user will
Xbe taken (e.g. \fBu:foo:\fP or \fBu[foo]\fP for user \fBfoo\fP)
X.TP
X\fBg\fIid\fR
Xlike \fBu\fIid\fR but with group ids or names
X.TP
X\fBa\fI[-|+]n\fR
Xfiles accessed within last \fIn\fP days (-), more than \fIn\fP days
Xago (+), or \fIn\fP days ago\fP
X.TP
X\fBm\fI[-|+]n\fR
Xfiles modified within last \fIn\fP days (-), more than \fIn\fP days
Xago (+), or \fIn\fP days ago\fP
X.TP
X\fBc\fI[-|+]n\fR
Xfiles whose inode changed within last \fIn\fP days (-), more than
X\fIn\fP days ago (+), or \fIn\fP days ago.
XIf any of the flags \fBa\fP, \fBm\fP, or \fBc\fP is directly followed by a
X\fBM\fP, \fBw\fP, \fBh\fP, or \fBm\fP (e.g. \fBmh+5\fP) the check is
Xperformed with months (of 30 days), weeks, hours, or minutes instead
Xof days, respectively.
X.TP
X\fBL\fI[+|-]n\fR
Xfiles less than n bytes (-), more than n bytes (+), or
Xexactly n bytes in length.
X.TP
X\fB^\fP
Xnegates all qualifiers following it
X.TP
X\fB\-\fP
Xtoggles between making the qualifiers work on symbolic links (the
Xdefault) and the files they point to
X.TP
X\fBM\fP
Xsets the \fBMARK_DIRS\fP option for the current pattern
X.TP
X\fBT\fP
Xappends a traling qualifier mark to the file names, analogous to the
X\fBLIST_TYPES\fP option, for the current pattern (overrides \fBM\fP)
X.TP
X\fBN\fP
Xsets the \fBNULL_GLOB\fP option for the current pattern
X.TP
X\fBD\fP
Xsets the \fBGLOB_DOTS\fP option for the current pattern
X.PD
X.RE
X.PP
XMore than one of these lists can be combined, separated by commas. The
Xwhole list matches if at least one of the sublists matches (they are
X`or'ed', the qualifiers in the sublists are `and'ed').
X.PP
XIf a : appears in a qualifier list, the remainder of the expression in
Xparenthesis is interpreted as a modifier (see the subsection
X\fBModifiers\fR of the section \fBHISTORY\fR).  Note that each modifier
Xmust be introduced by a separate :.  Note also that the result after
Xmodification does not have to be an existing file.  The name of any
Xexisting file can be followed by a modifier of the form (:..) even if no
Xfilename generation is performed.
X.PP
XThus:
X.RS
X.PP
Xls
X.B *(\-/)
X.RE
X.PP
Xlists all directories and symbolic links that point to directories,
Xand
X.RS
X.PP
Xls
X.B *(%W)
X.RE
X.PP
Xlists all world-writable device files in the current directory,
Xand
X.RS
X.PP
Xls
X.B *(W,X)
X.RE
X.PP
Xlists all files in the current directory that are 
Xworld-writable or world-executable, and
X.RS
X.PP
Xecho
X.B /tmp/foo*(u0^@:t)
X.RE
X.PP
Xoutputs the basename of all root-owned files beginning with the string
X"foo" in /tmp, ignoring symlinks, and
X.RS
X.PP
Xls
X.B *.*~(lex|parse).[ch](^D^l1)
X.RE
X.PP
Xlists all files having a link count of one whose names contain a dot
X(but not those starting with a dot, since \fBGLOB_DOTS\fP is explicitly
Xswitched off) except for lex.c, lex.h, parse.c, and parse.h.
XA "/" at the end of a pattern
Xis equivalent to "(\|/\|)".
X.SH REDIRECTION
XBefore a command is executed, its input and output
Xmay be redirected.
XThe following may appear anywhere in a simple command
Xor may precede or follow a complex command.
XSubstitution occurs before
X.I word
Xis used except as noted below.
XIf the result of substitution on
X.I word
Xproduces more than one filename,
Xredirection occurs for each
Xseparate filename in turn.
X.TP
X.BI < word
XOpen file
X.I word
Xas standard input.
X.TP
X.BI > word
XOpen file
X.I word
Xas standard output.
XIf the file does not exist then it is created.
XIf the file exists, and the
X.B NO_CLOBBER
Xoption is set,
Xthis causes an error;
Xotherwise, it is truncated to zero length.
X.TP
X.BI >! " word"
XSame as
X.BR > ,
Xexcept that the file is truncated to zero length
Xif it exists, even if
X.B NO_CLOBBER
Xis set.
X.TP
X.BI >> word
XOpen file
X.I word
Xas standard output.
XIf the file exists then output is appended to it.
XIf the file does not exist, and the
X.B NO_CLOBBER
Xoption is set,
Xthis causes an error;
Xotherwise, the file is created.
X.TP
X.BI >>! " word"
XSame as
X.BR >> ,
Xexcept that the file is created if it does not
Xexist, even if
X.B NO_CLOBBER
Xis set.
X.TP
X\fB<<\fP[\-] \fIword\fP
XThe shell input is read up to a line that is the same as
X.IR word ,
Xor to an end-of-file.
XNo parameter substitution, command substitution or
Xfilename generation is performed on
X.IR word .
XThe resulting document,
Xcalled a
X.IR here-document ,
Xbecomes
Xthe standard input.
XIf any character of \fIword\fP is quoted with
Xsingle or double quotes or a \e,
Xno interpretation
Xis placed upon the characters of the document.
XOtherwise, parameter and command substitution
Xoccurs, \e followed by a newline is removed,
Xand \e must be used to quote the characters
X\e, $, `, and the first character of \fIword\fP.
XIf <<\- is used, then all leading
Xtabs are stripped from \fIword\fP and from the document.
X.TP
X.BI <<< word
XOpen a file containing \fIword\fP, after expansion,
Xas standard input.
X.TP
X.BI <& digit
XThe standard input
Xis duplicated from file descriptor
X.I digit
X(see
X.IR dup (2)).
XSimilarly for standard output using
X\fB>&\fIdigit\fP.
X.TP
X.BI >& word
XSame as
X.BI > word
X\fB2>&\fP1.
X.TP
X.BI >>& word
XSame as
X.BI >> word
X\fB2>&\fP1.
X.TP
X.BI <&\-
XClose the standard input.
X.TP
X.BI >&\-
XClose the standard output.
X.TP
X.BI <&p
XThe input from the coprocess is moved to the standard input.
X.TP
X.BI >&p
XThe output to the coprocess is moved to the standard output.
X.PP
XIf one of the above is preceded by a digit, then the file
Xdescriptor referred to is that specified by the digit
X(instead of the default 0 or 1).
XThe order in which redirections are specified is significant.
XThe shell evaluates each redirection in terms of the
X.RI ( "file descriptor" ", " file )
Xassociation at the time of evaluation.
XFor example:
X.RS
X.PP
X\&.\|.\|. \|1>\fIfname\^\fP 2>&1
X.RE
X.PP
Xfirst associates file descriptor 1 with file
X.IR fname .
XIt then associates file descriptor 2 with the file associated with file
Xdescriptor 1 (that is,
X.IR fname ).
XIf the order of redirections were reversed, file descriptor 2 would be associated
Xwith the terminal (assuming file descriptor 1 had been) and then file descriptor
X1 would be associated with file
X.IR fname .
X.PP
XIf the user tries to open a file descriptor for writing more than once,
Xthe shell opens the file descriptor as a pipe to a process that copies
Xits input to all the specified outputs, similar to tee(1).  Thus:
X.RS
X.PP
X.B date >foo >bar
X.RE
X.PP
Xwrites the date to two files, named "foo" and "bar".
XNote that a pipe is an implicit indirection; thus
X.RS
X.PP
X.B date >foo | cat
X.RE
X.PP
Xwrites the date to the file "foo", and also pipes it to cat.
X.PP
XIf the user tries to open a file descriptor for reading more than once,
Xthe shell opens the file descriptor as a pipe to a process that copies
Xall the specified inputs to its output in the order
Xspecified, similar to cat(1).  Thus
X.RS
X.PP
X.B sort <foo <fubar
X.RE
X.PP
Xor even
X.RS
X.PP
X.B sort <f{oo,ubar}
X.RE
X.PP
Xis equivalent to "cat foo bar | sort".  Similarly, you can do
X.RS
X.PP
X.B echo exit 0 >> *.sh
X.RE
X.PP
XNote that a pipe is in implicit indirection; thus
X.RS
X.PP
X.B cat bar | sort <foo
X.RE
X.PP
Xis equivalent to "cat bar foo | sort" (note the order of the inputs).
X.PP
XIf a simple command consists of one or more redirection operators
Xand zero or more parameter assignments, but no command name,
Xthe command \fBcat\fP is assumed.  Thus
X.RS
X.PP
X.B < file
X.RE
X.PP
Xprints the contents of \fBfile\fP.
X.PP
XIf a command is followed by
X.B &
Xand job control is not active,
Xthen the default standard input
Xfor the command
Xis the empty file
X.BR /dev/null .
XOtherwise, the environment for the execution of a command contains the
Xfile descriptors of the invoking shell as modified by
Xinput/output specifications.
X.SH "COMMAND EXECUTION"
XIf a command name contains no slashes, the shell attempts to locate
Xit.  If there exists a shell function by that name, the function
Xis invoked as described below in \fBFUNCTIONS\fP.  If there exists
Xa shell builtin by that name, the builtin is invoked.
X.PP
XOtherwise, the shell searches each element of \fBpath\fP for a
Xdirectory containing an executable file by that name.  If the
Xsearch is unsuccessful, the shell prints an error message and returns
Xa nonzero exit status.
X.PP
XIf execution fails because the file is not in executable format,
Xand the file is not a directory, it is assumed to be a shell
Xscript.  /bin/sh is spawned to execute it.  If the program
Xis a file beginning with \fB#!\fP, the remainder of the first line
Xspecifies an interpreter for the program.  The shell will
Xexecute the specified interpreter on operating systems that do
Xnot handle this executable format in the kernel.
X.SH FUNCTIONS
X.PP
XThe
X.B function
Xreserved word is used to define shell functions.
XShell functions are read in and stored internally.
XAlias names are resolved when the function is read.
XFunctions are executed like commands with the arguments
Xpassed as positional parameters.
X(See
X.I Execution
Xbelow).
X.PP
XFunctions execute in the same process as the caller and
Xshare all files
Xand present working directory with the
Xcaller.
XA trap on
X.B EXIT
Xset inside a function
Xis executed after the function completes in the environment
Xof the caller.
X.PP
XThe
X.B return
Xbuiltin is used to return
Xfrom function calls.
X.PP
XFunction identifiers
Xcan be listed with the
X.B functions
Xbuiltin.
XFunctions can be undefined with the
X.B unfunction
Xbuiltin.
X.PP
XThe following functions, if defined, have special meaning to
Xthe shell:
X.PP
X.PD 0
X.TP
X\fBchpwd\fP
XExecuted whenever the current working directory is changed.
X.TP
X\fBprecmd\fP
XExecuted before each prompt.
X.TP
X\fBperiodic\fP
XIf the parameter
X.B PERIOD
Xis set, this function is executed every
X.B PERIOD
Xseconds, just before a prompt.
X.TP
X\fBTRAPxxx\fP
XIf defined and non-null,
Xthis function will be executed whenever the shell
Xcatches a signal \fBSIGxxx\fP, where \fBxxx\fP is a signal
Xname as specified for the \fBkill\fP builtin (see below).
XThe signal number will be passed as the first parameter to the function.
XIn addition, \fBTRAPZERR\fP is executed whenever a command has a non-zero
Xexit status, \fBTRAPDEBUG\fP is executed after each command, and
X\fBTRAPEXIT\fP
Xis executed when the shell exits,
Xor when the current function exits if defined
Xinside a function.
XIf a function of this form is defined and null,
Xthe shell and processes spawned by it will ignore \fBSIGxxx\fP.
X.PD
X.SH JOBS
X.PP
XIf the
X.B MONITOR
Xoption is set,
Xan interactive shell associates a \fIjob\fR with each pipeline.
XIt keeps
Xa table of current jobs, printed by the
X.B jobs
Xcommand, and assigns them small integer numbers.
XWhen a job is started asynchronously with
X.BR & ,
Xthe shell prints a line which looks
Xlike:
X.PP
X.DT
X	[1] 1234
X.PP
Xindicating that the job which was started asynchronously was job number
X1 and had one (top-level) process, whose process id was 1234.
X.PP
XIf you are running a job and wish to do something else you may hit the key
X\fB^Z\fR (control-Z) which sends a TSTP signal to the current job.
XThe shell will then normally indicate that the job has been `suspended',
Xand print another prompt.
XYou can then manipulate the state of this job,
Xputting it in the background with the
X.B bg
Xcommand, or run some other
Xcommands and then eventually bring the job back into the foreground with
Xthe foreground command
X.BR fg .
XA \fB^Z\fR takes effect immediately and
Xis like an interrupt in that pending output and unread input are discarded
Xwhen it is typed.
X.PP
XA job being run in the background will suspend if it tries to read
Xfrom the terminal.
XBackground jobs are normally allowed to produce output,
Xbut this can be disabled by giving the command ``stty tostop''.
XIf you set this
Xtty option, then background jobs will suspend when they try to produce
Xoutput like they do when they try to read input.
X.PP
XThere are several ways to refer to jobs in the shell.
XA job can be referred to by the process id of any process of the job
Xor by one of the following:
X.PD 0
X.TP
X.BI % number
XThe job with the given number.
X.TP
X.BI % string
XAny job whose command line begins with
X.IR string .
X.TP
X.BI %? string
XAny job whose command line contains
X.IR string .
X.TP
X.BI %%
XCurrent job.
X.TP
X.BI %+
XEquivalent to
X.BR %% .
X.TP
X.BI %\-
XPrevious job.
X.PD
X.PP
XThe shell learns immediately whenever a process changes state.
XIt normally informs you whenever a job becomes blocked so that
Xno further progress is possible.  If
X.B notify
Xis not set, it waits until
Xjust before it prints
Xa prompt before it informs you.
X.PP
XWhen the monitor mode is on, each background job that completes
Xtriggers any trap set for
X.BR CHLD .
X.PP
XWhen you try to leave the shell while jobs are running or suspended, you will
Xbe warned that `You have suspended (running) jobs.'
XYou may use the
X.B jobs
Xcommand to see what they are.
XIf you do this or immediately try to
Xexit again, the shell will not warn you a second time; the suspended
Xjobs will be terminated, and the running jobs will be sent
Xa \fBSIGHUP\fP signal.
XTo avoid having the shell terminate the running jobs, either
Xuse the \fBnohup\fP(1) command or the \fBdisown\fP builtin (see below).
X.SH SIGNALS
XThe INT and QUIT signals for an invoked
Xcommand are ignored if the command is followed by
X.B &
Xand the job
X.B MONITOR
Xoption is not active.
XOtherwise, signals have the values
Xinherited by the shell from its parent
X(but see the \fBTRAPxxx\fP special function above).
X.SH HISTORY
XHistory substitution allows you to use words from previous command
Xlines in the command line you are typing.  This simplifies spelling
Xcorrections and the repetition of complicated commands or arguments.
XCommand lines are saved in the history list, the size of which
Xis controlled by the
X.B HISTSIZE
Xvariable.  The most recent command is retained in any case.
XA history substitution begins with a
X.B !
Xand may occur anywhere on the command line; history
Xsubstitutions do not nest.  The
X.B !
Xcan be escaped with
X.B \e
Xto suppress its special meaning.
XSingle or double quotes will \fInot\fP work for this.
X.PP
XInput lines containing history substitutions are echoed on the
Xterminal after being expanded, but before any other
Xsubstitutions take place or the command gets executed.
X.SS Event Designators
X.PP
XAn event designator is a reference to a command-line entry in
Xthe history list.
X.RS
X.PD 0
X.TP
X.B !
XStart a history substitution, except when followed by a blank, newline,
X.BR = ,
Xor
X.BR ( .
X.TP
X.B !!
XRefer to the previous command. 
XBy itself, this substitution
Xrepeats the previous command.
X.TP
X.BI ! n
XRefer to command-line
X.IR n .
X.TP
X.BI ! \-n
XRefer to the current command-line minus
X.IR n .
X.TP
X.BI  ! str
XRefer to the most recent command starting with
X.IR str .
X.TP
X.BI  !? str\fR[\fP ? \fR]\fP
XRefer to the most recent command containing
X.IR str .
X.TP
X.B !#
XRefer to the current command line typed in so far.
X.TP
X.BR !{ .\|.\|. }
XInsulate a history reference from adjacent characters (if necessary).
X.PD
X.RE
X.SS Word Designators
X.PP
XA word designator indicates which word or words of a given command line will
Xbe included in a history reference.  A
X.RB ` : '
Xseparates the event specification from the word designator. 
XIt can be omitted if the word designator begins with a
X.BR ^ ,
X.BR $ ,
X.BR * ,
X.B \-
Xor
X.BR % .
XWord designators include:
X.RS
X.PD 0
X.TP
X.B 0
XThe first input word (command).
X.TP
X.I n
XThe
X.IR n 'th
Xargument.
X.TP
X.B ^
XThe first argument, that is,
X.BR 1 .
X.TP
X.B $
XThe last argument.
X.TP
X.B %
XThe word matched by (the most recent)
X.BI ? str
Xsearch.
X.TP
X.IB x \- y
XA range of words;
X.BI \- y
Xabbreviates
X.BI 0\- y\fR.
X.TP
X.B *
XAll the arguments, or a null value if there is just
Xone word in the event.
X.TP
X.IB x *
XAbbreviates
X.IB x \-$ .
X.TP
X.IB x \-
XLike
X.I x*
Xbut omitting word
X.BR $ .
X.PD
X.RE
XNote that a
X.RB ` % '
Xword designator will only work when used as
X.B !%,
X.B !:%,
X.BI !? str ?:%
Xand only when used after a !? substitution.  Anything else will result
Xin an error, although the error may not be the most obvious one.
X.PP
X.SS Modifiers
X.PP
XAfter the optional word designator, you can add
Xa sequence of one or more of the following modifiers,
Xeach preceded by a
X.BR : .
XThese modifiers also work on the result
Xof filename and parameter expansion.
X.RS
X.TP
X.B h
XRemove a trailing pathname component, leaving the head.
X.PD 0
X.TP
X.B r
XRemove a trailing suffix of the form
X.RB ` "\&.\fIxxx" ',
Xleaving the basename.
X.TP
X.B e
XRemove all but the suffix.
X.TP
X.B t
XRemove all leading pathname components, leaving the tail.
X.TP
X.B &
XRepeat the previous substitution.
X.TP
X.B g
XApply the change to the first occurrence of a match in each word,
Xby prefixing the above (for example,
X.BR g& ).
X.TP
X.B p
XPrint the new command but do not execute it.
X.TP
X.B q
XQuote the substituted words, escaping further substitutions.
X.TP
X.B x
XLike
X.BR q ,
Xbut break into words at each blank.
X.TP
X.B l
XConvert the words to all lowercase.
X.TP
X.B u
XConvert the words to all uppercase.
X.TP
X.B f
XRepeats the immediately (without a colon) following modifier until the
Xresulting word doesn't change any more. This one and the following
Xfour only work with parameter and filename expansion.
X.TP
X.B F:\fIexpr\fB:
XLike \fBf\fP, but repeats only \fIn\fP times if the expression
X\fIexpr\fP evaluates to \fIn\fP. Any character can be used instead of
Xthe `:', if any of `(', `[', or `{' is used as the opening delimiter
Xthe second one has to be ')', `]', or `}' respectively.
X.TP
X.B w
XMakes the immediately following modifier work on each word in the
Xstring.
X.TP
X.B W:\fIsep\fB:
XLike \fBw\fP but words are considered to be the parts of the string
Xthat are separated by \fIsep\fP. Any character can be used instead of
Xthe `:', opening parentheses are handled specially, see above.
X.TP
X.BI s/ l / r\fR[\fP / \fR]\fP
XSubstitute
X.I r
Xfor
X.IR l .
X.PD
X.RE
X.PP
XUnless preceded by a
X.BR g ,
Xthe substitution is done only for the
Xfirst string that matches
X.IR l .
X.PP
XThe left-hand side of substitutions are not regular expressions,
Xbut character strings.
XAny character can be used as the delimiter in place of
X.BR / .
XA backslash quotes the delimiter character.
XThe character
X.BR & ,
Xin the right hand side, is replaced by the text
Xfrom the left-hand-side. 
XThe
X.B &
Xcan be quoted with a backslash. 
XA null
X.I l
Xuses the previous string either from a
X.I l
Xor from a contextual scan string
X.I s
Xfrom
X.BI !? s\fR.
XYou can omit the rightmost delimiter if a newline
Ximmediately follows
X.IR r ;
Xthe rightmost
X.B ?
Xin a context scan can similarly be omitted.
X.PP
XBy default, a history reference with no event specification refers to the same
Xline as the last history reference on that command line, unless it is the
Xfirst history reference in a command.  In that case, a history reference
Xwith no event specification always refers to the previous command.  However,
Xif the option \fBCSH_JUNKIE_HISTORY\fP is set, then history reference with no
Xevent specification will \fIalways\fP refer to the previous command.
XFor example,
X.B !!:1
Xwill always refer to the first word of the previous command and
X.B !!$
Xwill always refer to the last word of the previous command.  And with
X\fBCSH_JUNKIE_HISTORY\fP set, then
X.B !:1
Xand
X.B !$
Xwill function in the same manner as
X.B !!:1
Xand
X.B !!$,
Xrespectively.  However, if \fBCSH_JUNKIE_HISTORY\fP is unset, then
X.B !:1 
Xand
X.B !$
Xwill refer to the first and last words respectively, of the last command
Xreferenced on the current command line.  However, if they are the first history
Xreference on the command line, then they refer to the previous command.
X.PP
XThe character sequence
X.BI ^ foo ^ bar
Xrepeats the last command, replacing the string "foo" with the
Xstring "bar".
X.PP
XIf the shell encounters the character sequence
X\fB!"\fP
Xin the input, the history mechanism is temporarily disabled until
Xthe current list is fully parsed.  The
X\fB!"\fP
Xis removed from the input, and any subsequent
X.B !
Xcharacters have no special significance.
X.PP
XA less convenient but more comprehensible
Xform of command history support
Xis provided by the
X.B fc
Xbuiltin (see below).
X.SH "ARITHMETIC EVALUATION"
XAn ability to perform integer arithmetic
Xis provided with the builtin
X.BR let .
XEvaluations are performed using
X.I long
Xarithmetic.
XConstants are of the form
X[\fIbase\fB#\^\fR]\fIn\^\fP
Xwhere
X.I base
Xis a decimal number between two and thirty-six
Xrepresenting the arithmetic base
Xand
X.I n
Xis a number in that base (for example, `16#ff' is 255 in hexadecimal).
XIf
X.I base
Xis omitted
Xthen base 10 is used.  For backwards compatibility the form `[16]ff'
Xis also accepted.
X.PP
XAn arithmetic expression uses nearly the same syntax, precedence, and
Xassociativity of
Xexpressions in C.
XThe following operators are supported (listed in decreasing order
Xof precedence):
X.PP
X.PD 0
X.RS
X.TP
X.B + \- ! \(ap ++ \-\|\-
Xunary plus/minus, logical NOT, complement, {pre,post}{in,de}crement
X.TP
X.B &
Xlogical AND
X.TP
X.B ^
Xlogical XOR
X.TP
X.B |
Xlogical OR
X.TP
X.B * / % **
Xmultiplication, division, remainder, exponentiation
X.TP
X.B + \-
Xaddition, subtraction
X.TP
X.B << >>
Xlogical shift left, shift right
X.TP
X.B < > <= >=
Xcomparison
X.TP
X.B == !=
Xequality and inequality
X.TP
X.B &&
Xboolean AND
X.TP
X.B |\|| ^^
Xboolean OR, XOR
X.TP
X.B ? :
Xternary operator
X.TP
X.B
X= += \-= *= /= %= &= ^= |= <<= >>= &&= |\||= ^^= **=
Xassignment
X.TP
X.B ,
Xcomma operator
X.PD
X.RE
X.PP
XThe operators &&, |\||, &&=, and |\||= are short-circuiting,
Xand only one of the latter two expressions in a ternary operator
Xis evaluated.  Note the precedence of the logical AND, OR,
Xand XOR operators.
X.PP
XAn expression of the form \fB#\\x\fP where \fBx\fP is any character
Xgives the ascii value of this character and an expression of the form
X\fB#foo\fP gives the ascii value of the first character of the value
Xof the parameter \fBfoo\fP.
X.PP
XNamed parameters can be referenced by name within an arithmetic expression
Xwithout using the parameter substitution syntax, but if it is an array
Xwith a subscript the leading \fB$\fP is needed.
X.PP
XAn internal integer representation of a named parameter
Xcan be specified with the
X.B integer
Xbuiltin.
XArithmetic evaluation is performed on the value of each
Xassignment to a named parameter declared integer
Xin this manner.
X.PP
XSince many of the arithmetic operators require
Xquoting, an alternative form of the
X.B let
Xcommand is provided.
XFor any command which begins with a
X.BR (( ,
Xall the characters until a matching
X.B ))
Xare treated as a quoted expression.
XMore precisely,
X.BR (( ... ))
Xis equivalent to
X.B let
X\fB"\fP...\fB"\fP.
X.SH "CONDITIONAL EXPRESSIONS"
XA \fIconditional expression\fP is used with the
X.B [[
Xcompound command to test attributes of files and to compare strings.
XEach expression can be constructed from one or more
Xof the following unary or binary expressions:
X.PD 0
X.TP
X\fB\-a\fP \fIfile\fP
Xtrue if
X.I file
Xexists.
X.TP
X\fB\-b\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is a block special file.
X.TP
X\fB\-c\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is a character special file.
X.TP
X\fB\-d\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is a directory.
X.TP
X\fB\-e\fP \fIfile\fP
Xtrue if
X.I file
Xexists.
X.TP
X\fB\-f\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is an ordinary file.
X.TP
X\fB\-g\fP \fIfile\fP
Xtrue if
X.I file
Xexists and has its setgid bit set.
X.TP
X\fB\-h\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is a symbolic link.
X.TP
X\fB\-k\fP \fIfile\fP
Xtrue if
X.I file
Xexists and has its sticky bit set.
X.TP
X\fB\-n\fP \fIstring\fP
Xtrue if length of
X.I string
Xis non-zero.
X.TP
X\fB\-o\fP \fIoption\fP
Xtrue if option named
X.I option
Xis on.
X.TP
X\fB\-p\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is a fifo special file or a pipe.
X.TP
X\fB\-r\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is readable by current process.
X.TP
X\fB\-s\fP \fIfile\fP
Xtrue if
X.I file
Xexists and has size greater than zero.
X.TP
X\fB\-t\fP \fIfd\fP
Xtrue if file descriptor number
X.I fd
Xis open and associated with a terminal device.
X(note: \fIfd\fP is not optional)
X.TP
X\fB\-u\fP \fIfile\fP
Xtrue if
X.I file
Xexists and has its setuid bit set.
X.TP
X\fB\-w\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is writable by current process.
X.TP
X\fB\-x\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is executable by current process.
XIf
X.I file
Xexists and is a directory, then the current process
Xhas permission to search in the directory.
X.TP
X\fB\-z\fP \fIstring\fP
Xtrue if length of
X.I string
Xis zero.
X.TP
X\fB\-L\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is a symbolic link.
X.TP
X\fB\-O\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is owned by the effective user id of this process.
X.TP
X\fB\-G\fP \fIfile\fP
Xtrue if
X.I file
Xexists and its group matches the effective group id of this process.
X.TP
X\fB\-S\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is a socket.
X.TP
X\fIfile1\fP \fB\-nt\fP \fIfile2\fP
Xtrue if
X.I file1
Xexists and is newer than
X.IR file2 .
X.TP
X\fIfile1\fP \fB\-ot\fP \fIfile2\fP
Xtrue if
X.I file1
Xexists and is older than
X.IR file2 .
X.TP
X\fIfile1\fP \fB\-ef\fP \fIfile2\fP
Xtrue if
X.I file1
Xand 
X.I file2
Xexist and refer to the same file.
X.TP
X\fIstring\fP \fB=\fP \fIpattern\fP
Xtrue if
X.I string
Xmatches
X.IR pattern .
X.TP
X\fIstring\fP \fB!=\fP \fIpattern\fP
Xtrue if
X.I string
Xdoes not match
X.IR pattern .
X.TP
X\fIstring1\fP \fB<\fP \fIstring2\fP
Xtrue if
X.I string1
Xcomes before
X.I string2
Xbased on ASCII value of their characters.
X.TP
X\fIstring1\fP \fB>\fP \fIstring2\fP
Xtrue if
X.I string1
Xcomes after
X.I string2
Xbased on ASCII value of their characters.
X.TP
X\fIexp1\fP \fB\-eq\fP \fIexp2\fP
Xtrue if
X.I exp1
Xis equal to
X.IR exp2.
X.TP
X\fIexp1\fP \fB\-ne\fP \fIexp2\fP
Xtrue if
X.I exp1
Xis not equal to
X.IR exp2.
X.TP
X\fIexp1\fP \fB\-lt\fP \fIexp2\fP
Xtrue if
X.I exp1
Xis less than
X.IR exp2.
X.TP
X\fIexp1\fP \fB\-gt\fP \fIexp2\fP
Xtrue if
X.I exp1
Xis greater than
X.IR exp2.
X.TP
X\fIexp1\fP \fB\-le\fP \fIexp2\fP
Xtrue if
X.I exp1
Xis less than or equal to
X.IR exp2.
X.TP
X\fIexp1\fP \fB\-ge\fP \fIexp2\fP
Xtrue if
X.I exp1
Xis greater than or equal to
X.IR exp2.
X.TP
X\fB(\fP \fIexp\fP \fB)\fP
Xtrue if \fIexp\fP is true.
X.TP
X\fB!\fP \fIexp\fP
Xtrue if \fIexp\fP is false.
X.TP
X\fIexp1\fP \fB&&\fP \fIexp2\fP
Xtrue if \fIexp1\fP and \fIexp2\fP are both true.
X.TP
X\fIexp1\fP \fB|\||\fP \fIexp2\fP
Xtrue if either \fIexp1\fP or \fIexp2\fP is true.
X.PD
X.PP
XIn each of the above expressions, if
X.I file
Xis of the form
X\fB/dev/fd/\fP\fIn\fR,
Xwhere
X.I n
Xis an integer,
Xthen the test applied to the open file whose
Xdescriptor number is
X.IR n ,
Xeven if the underlying system does not support
Xthe \fB/dev/fd\fP directory.
X.PD
X.SH "ZSH LINE EDITOR"
XIf the \fBZLE\fP option is set (it is by default)
Xand the shell input is attached to the terminal, the user
Xis allowed to edit command lines.
X.PP
XThere are two display modes.  The first, multiline mode, is the
Xdefault.  It only works if the \fBTERM\fP parameter is set to a valid
Xterminal type that can move the cursor up.  The second, single line
Xmode, is used if \fBTERM\fP is invalid or incapable of moving the
Xcursor up, or if the \fBSINGLE_LINE_ZLE\fP option is set.  This mode
Xis similar to ksh, and uses no termcap sequences.  If \fBTERM\fP is
X"emacs", the \fBZLE\fP option will be unset by the shell.
X.SS Bindings
XCommand bindings may be set using the \fBbindkey\fP builtin.
XThere are two keymaps\-the main keymap and the alternate keymap.
XThe alternate keymap is bound to vi command mode.
XThe main keymap is bound to emacs mode by default.
XTo bind the main keymap to vi insert mode, use 
X\fBbindkey \-v\fP. However, if one of the \fBVISUAL\fP or
X\fBEDITOR\fP environment variables contain the string \fBvi\fP when the shell
Xstarts up the main keymap will be bound to vi insert mode by default.
X.PP
XThe following is a list of all the key commands
Xand their default bindings in emacs and vi command mode.
X.SS Movement
X.TP
X\fBvi-backward-blank-word\fP (unbound) (B)
XMove backward one word, where a word is defined as a series of
Xnon-blank characters.
X.TP
X\fBbackward-char\fP (^B ESC-[D) (\|)
XMove backward one character.
X.TP
X\fBvi-backward-char\fP (\|) (h)
XMove backward one character, without changing lines.
X.TP
X\fBbackward-word\fP (ESC-B ESC-b) (unbound)
XMove to the beginning of the previous word.
X.TP
X\fBemacs-backward-word\fP
XMove to the beginning of the previous word.
X.TP
X\fBvi-backward-word\fP (unbound) (b)
XMove to the beginning of the previous word, vi-style.
X.TP
X\fBbeginning-of-line\fP (^A) (0)
XMove to the beginning of the line.  If already at the beginning
Xof the line, move to the beginning of the previous line, if any.
X.TP
X\fBvi-beginning-of-line\fP
XMove to the beginning of the line, without changing lines.
X.TP
X\fBend-of-line\fP (^E)
XMove to the end of the line.  If already at the end 
Xof the line, move to the end of the next line, if any.
X.TP
X\fBvi-end-of-line\fP (unbound) ($)
XMove to the end of the line.
X.TP
X\fBvi-forward-blank-word\fP (unbound) (W)
XMove forward one word, where a word is defined as a series of
Xnon-blank characters.
X.TP
X\fBvi-forward-blank-word-end\fP (unbound) (E)
XMove to the end of the current word,
Xor, if at the end of the current word,
Xto the end of the next word,
Xwhere a word is defined as a series of
Xnon-blank characters.
X.TP
X\fBforward-char\fP (^F ESC-[C)
XMove forward one character.
X.TP
X\fBvi-forward-char\fP (unbound) (space l)
XMove forward one character.
X.TP
X\fBvi-find-next-char\fP (^X^F) (f)
XRead a character from the keyboard, and move to
Xthe next occurrence of it in the line.
X.TP
X\fBvi-find-next-char-skip\fP (unbound) (t)
XRead a character from the keyboard, and move to
Xthe position just before the next occurrence of it in the line.
X.TP
X\fBvi-find-prev-char\fP (unbound) (F)
XRead a character from the keyboard, and move to
Xthe previous occurrence of it in the line.
X.TP
X\fBvi-find-prev-char-skip\fP (unbound) (T)
XRead a character from the keyboard, and move to
Xthe position just after the previous occurrence of it in the line.
X.TP
X\fBvi-first-non-blank\fP (unbound) (^)
XMove to the first non-blank character in the line.
X.TP
X\fBvi-forward-word\fP (unbound) (w)
XMove forward one word, vi-style.
X.TP
X\fBforward-word\fP (ESC-F ESC-f) (unbound)
XMove to the beginning of the next word.
XThe editor's idea of a word is specified with the \fBWORDCHARS\fP
Xparameter.
X.TP
X\fBemacs-forward-word\fP
XMove to the end of the next word.
X.TP
X\fBvi-forward-word-end\fP (unbound) (e)
XMove to the end of the next word.
X.TP
X\fBvi-goto-column\fP (ESC-|) (|)
XMove to the column specified by the numeric argument.
X.TP
X\fBvi-goto-mark\fP (unbound) (`)
XMove to the specified mark.
X.TP
X\fBvi-goto-mark-line\fP (unbound) (')
XMove to beginning of the line containing the specified mark.
X.TP
X\fBvi-repeat-find\fP (unbound) (;)
XRepeat the last \fBvi-find\fP command.
X.TP
X\fBvi-rev-repeat-find\fP (unbound) (,)
XRepeat the last \fBvi-find\fP command in the opposite direction.
X.SS History
X.TP
X\fBbeginning-of-buffer-or-history\fP (ESC-<)
XMove to the beginning of the buffer, or if already there,
Xmove to the first event in the history list.
X.TP
X\fBbeginning-of-line-hist\fP
XMove to the beginning of the line.  If already at the
Xbeginning of the buffer, move to the previous history line.
X.TP
X\fBbeginning-of-history\fP
XMove to the first event in the history list.
X.TP
X\fBdown-line-or-history\fP (^N ESC-[B) (+ j)
XMove down a line in the buffer, or if already at the bottom line,
Xmove to the next event in the history list.
X.TP
X\fBdown-line-or-search\fP
XMove down a line in the buffer, or if already at the bottom line,
Xsearch forward in the history for a line beginning with the first
Xword in the buffer.
X.TP
X\fBdown-history\fP (unbound) (^N)
XMove to the next event in the history list.
X.TP
X\fBhistory-beginning-search-backward\fP (unbound)
XSearch backward in the history for a line beginning with the current
Xline up to the cursor.
XThis leaves the cursor in its original position.
X.TP
X\fBend-of-buffer-or-history\fP (ESC->)
XMove to the end of the buffer, or if already there,
Xmove to the last event in the history list.
X.TP
X\fBend-of-line-hist\fP
XMove to the end of the line.  If already at the end of
Xthe buffer, move to the next history line.
X.TP
X\fBend-of-history\fP
XMove to the last event in the history list.
X.TP
X\fBvi-fetch-history\fP (unbound) (G)
XFetch the history line specified by the numeric argument.
X.TP
X\fBhistory-incremental-search-backward\fP (^R ^Xr)
XSearch backward incrementally for a specified string.
XThe string may begin with `^' to anchor the search to the
Xbeginning of the line. A restricted set of editing functions is available in
Xthe mini-buffer. An interrupt signal, as defined by the stty setting,  will
Xstop the search and go back to the original line. An undefined key will have
Xthe same effect. The supported functions are: backward-delete-char,
Xquoted-insert, accept-and-hold, accept-and-infer-next-history, accept-line and
Xaccept-line-and-down-history; magic-space just inserts a space. Any string
Xthat is bound to an out-string (via bindkey -s) will behave as if out-string
Xwere typed directly.
XTyping the binding of \fBhistory-incremental-search-backward\fP will get the
Xnext occurrence of the contents of the mini-buffer. Typing the binding of
X\fBhistory-incremental-search-forward\fP inverts the sense of the search. The
Xdirection of the search is indicated in the mini-buffer. Any multi-character
Xstring 
Xthat is not bound to one of the above functions will beep and interrupt the
Xsearch, leaving the last found line in the buffer. Any single character that
Xis not bound to one of the above functions, or self-insert or
Xself-insert-unmeta, will have the same effect but the function will be
Xexecuted.
X.TP
X\fBhistory-incremental-search-forward\fP (^Xs)
XSearch forward incrementally for a specified string.
XThe string may begin with `^' to anchor the search to the
Xbeginning of the line. The functions available in the mini-buffer are the same
Xas for \fBhistory-incremental-search-backward\fP.
X.TP
X\fBhistory-search-backward\fP (ESC-P ESC-p) (K)
XSearch backward in the history for a line beginning with the first
Xword in the buffer.
X.TP
X\fBvi-history-search-backward\fP (unbound) (/)
XSearch backward in the history for a specified string.
XThe string may begin with `^' to anchor the search to the
Xbeginning of the line. A restricted set of editing functions is available in
Xthe mini-buffer. An interrupt signal, as defined by the stty setting,  will
Xstop the search, as will a character bound to vi-cmd-mode. The functions
Xavailable in the mini-buffer are: accept-line, backward-delete-char,
Xvi-backward-delete-char and quoted-insert. Any string
Xthat is bound to an out-string (via bindkey -s) will behave as if out-string
Xwere typed directly. Any other character that is not bound to self-insert or
Xself-insert-unmeta will beep and be ignored. If the function is called from vi
Xcommand mode, the bindings of vi insert mode will be used.
X.TP
X\fBhistory-search-forward\fP (ESC-N ESC-n) (J)
XSearch forward in the history for a line beginning with the first
Xword in the buffer.
X.TP
X\fBvi-history-search-forward\fP (unbound) (?)
XSearch forward in the history for a specified string.
XThe string may begin with `^' to anchor the search to the
Xbeginning of the line. The functions available in the mini-buffer are the same
Xas for \fBvi-history-search-backward\fP.
X.TP
X\fBinfer-next-history\fP (^X^N)
XSearch in the history list for a line matching the current one and
Xfetch the event following it.
X.TP
X\fBinsert-last-word\fP (ESC-_ ESC-.)
XInsert the last word from the previous history event at the
Xcursor position.
X.TP
X\fBvi-repeat-search\fP (unbound) (n)
XRepeat the last vi history search.
X.TP
X\fBvi-rev-repeat-search\fP (unbound) (N)
XRepeat the last vi history search, but in reverse.
X.TP
X\fBtoggle-literal-history\fP (ESC-R ESC-r)
XToggle between literal and lexical history.  The default is
Xlexical history unless the \fBHISTLIT\fP option is set.
X.TP
X\fBup-line-or-history\fP (^P ESC-[A) (- k)
XMove up a line in the buffer, or if already at the top line,
Xmove to the previous event in the history list.
X.TP
X\fBup-line-or-search\fP
XMove up a line in the buffer, or if already at the top line,
Xsearch backward in the history for a line beginning with the
Xfirst word in the buffer.
X.TP
X\fBup-history\fP (unbound) (^P)
XMove to the previous event in the history list.
X.TP
X\fBhistory-beginning-search-forward\fP (unbound)
XSearch forward in the history for a line beginning with the current
Xline up to the cursor.
XThis leaves the cursor in its original position.
X.SS Modifying Text
X.TP
X\fBvi-add-eol\fP (unbound) (A)
XMove to the end of the line and enter insert mode.
X.TP
X\fBvi-add-next\fP (unbound) (a)
XMove forward one character and enter insert mode.
X.TP
X\fBbackward-delete-char\fP (^H ^?) (^?)
XDelete the character behind the cursor.
X.TP
X\fBvi-backward-delete-char\fP (unbound) (X)
XDelete the character behind the cursor, without changing lines.
X.TP
X\fBbackward-delete-word\fP
XDelete the word behind the cursor.
X.TP
X\fBbackward-kill-line\fP
XKill from the beginning of the line to the cursor position.
X.TP
X\fBbackward-kill-word\fP (^W ESC-^H ESC-^?)
XKill the word behind the cursor.
X.TP
X\fBvi-backward-kill-word\fP (unbound) (^W)
XKill the word behind the cursor.
X.TP
X\fBcapitalize-word\fP (ESC-C ESC-c)
XCapitalize the current word and move past it.
X.TP
X\fBvi-change\fP (unbound) (c)
XRead a movement command from the keyboard, and kill
Xfrom the cursor position to the endpoint of the movement.
XThen enter insert mode.
XIf the command is \fBvi-change\fP, kill the current line.
X.TP
X\fBvi-change-eol\fP (unbound) (C)
XKill to the end of the line and enter insert mode.
X.TP
X\fBvi-change-whole-line\fP (unbound) (S s)
XKill the current line and enter insert mode.
X.TP
X\fBcopy-region-as-kill\fP (ESC-W ESC-w)
XCopy the area from the cursor to the mark to the kill buffer.
X.TP
X\fBcopy-prev-word\fP (ESC-^_)
XDuplicate the word behind the cursor.
X.TP
X\fBvi-delete\fP (unbound) (d)
XRead a movement command from the keyboard, and kill 
Xfrom the cursor position to the endpoint of the movement.
XIf the command is \fBvi-delete\fP, kill the current line.
X.TP
X\fBdelete-char\fP (unbound) (x)
XDelete the character under the cursor.
X.TP
X\fBvi-delete-char\fP (unbound) (x)
XDelete the character under the cursor.
X.TP
X\fBdelete-word\fP (ESC-D ESC-d)
XDelete the current word.
X.TP
X\fBdown-case-word\fP (ESC-L ESC-l)
XConvert the current word to all lowercase and move past it.
X.TP
X\fBkill-word\fP
XKill the current word.
X.TP
X\fBgosmacs-transpose-chars\fP
XExchange the two characters behind the cursor.
X.TP
X\fBvi-indent\fP (unbound) (>)
XIndent a number of lines.
X.TP
X\fBvi-insert\fP (unbound) (i)
XEnter insert mode.
X.TP
X\fBvi-insert-bol\fP (unbound) (I)
XMove to the beginning of the line and enter insert mode.\fP
X.TP
X\fBvi-join\fP (^X^J)
XJoin the current line with the next one.
X.TP
X\fBkill-line\fP (^K) (D)
XKill from the cursor to the end of the line.
X.TP
X\fBvi-kill-line
XKill from the cursor to the beginning of the line.
X.TP
X\fBkill-region\fP
XKill from the cursor to the mark.
X.TP
X\fBkill-buffer\fP (^X^K) (^U)
XKill the entire buffer.
X.TP
X\fBkill-whole-line\fP (^U) (unbound)
XKill the current line.
X.TP
X\fBvi-match-bracket\fP (^X^B) (%)
XMove to the bracket character (one of {\|}, (\|), or [\|]) that
Xmatches the one under the cursor.
X.TP
X\fBvi-open-line-above\fP (unbound) (O)
XOpen a line above the cursor and enter insert mode.
X.TP
X\fBvi-open-line-below\fP (unbound) (o)
XOpen a line below the cursor and enter insert mode.
X.TP
X\fBvi-oper-swap-case\fP
XRead a movement command from the keyboard, and swap
Xthe case of all characters
Xfrom the cursor position to the endpoint of the movement.
XIf the movement command is \fBvi-oper-swap-case\fP,
Xswap the case of all characters on the current line.
X.TP
X\fBoverwrite-mode\fP (^X^O)
XToggle between overwrite mode and insert mode.
X.TP
X\fBvi-put-after\fP (unbound) (p)
XInsert the contents of the kill buffer after the cursor.
X.TP
X\fBquoted-insert\fP (^V)
XInsert the next character typed into the buffer literally.
X.TP
X\fBquote-line\fP (ESC-')
XQuote the current line; that is, put a ' character at the
Xbeginning and the end, and convert all ' characters
Xto '\e''.
X.TP
X\fBquote-region\fP (ESC-")
XQuote the region from the cursor to the mark.
X.TP
X\fBvi-replace\fP (unbound) (R)
XEnter overwrite mode.
X.TP
X\fBvi-repeat-change\fP (unbound) (.)
XRepeat the last vi mode text modification.
X.TP
X\fBvi-replace-chars\fP (unbound) (r)
XReplace the character under the cursor with a character
Xread from the keyboard.
X.TP
X\fBself-insert\fP (printable characters)
XPut a character in the buffer at the cursor position.
X.TP
X\fBself-insert-unmeta\fP (ESC-^I ESC-^J ESC-^M)
XPut a character in the buffer after stripping the meta bit
Xand converting \fB^M\fP to \fB^J\fP.
X.TP
X\fBvi-substitute\fP (unbound) (s)
XSubstitute the next character(s).
X.TP
X\fBvi-swap-case\fP (unbound) (~)
XSwap the case of the character under the cursor and move past it.
X.TP
X\fBtranspose-chars\fP (^T)
XExchange the two characters to the left of the
Xcursor if at end of line, else exchange the
Xcharacter under the cursor with the character
Xto the left.
X.TP
X\fBtranspose-words\fP (ESC-T ESC-t)
XExchange the current word with the one before it.
X.TP
X\fBvi-unindent\fP (unbound) (<)
XUnindent a number of lines.
X.TP
X\fBup-case-word\fP (ESC-U ESC-u)
XConvert the current word to all caps and move past it.
X.TP
X\fByank\fP (^Y) (P)
XInsert the contents of the kill buffer at the cursor position.
X.TP
X\fByank-pop\fP (ESC-y) (unbound)
XRemove the text just yanked, rotate the kill\-ring,
Xand yank the new top.  Only works following
X\fByank\fP or \fByank-pop\fP.
X.TP
X\fBvi-yank\fP (unbound) (y)
XRead a movement command from the keyboard, and copy the region
Xfrom the cursor position to the endpoint of the movement
Xinto the kill buffer.
XIf the command is \fBvi-yank\fP, copy the current line.
X.TP
X\fBvi-yank-eol\fP (unbound) (Y)
XCopy the region from the cursor position to the end of the line
Xinto the kill buffer.
X.SS Arguments
X.TP
X\fBdigit-argument\fP (ESC-0..ESC-9) (0-9)
XStart a new numeric argument, or add to the current one.
X.TP
X\fBneg-argument\fP (ESC-- unbound)
XChanges the sign of the following argument.
X.TP
X\fBuniversal-argument\fP
XMultiply the argument of the next command by 4.
X.SS Completion
X.TP
X\fBaccept-and-menu-complete\fP
XIn a menu completion, insert the current completion into the buffer,
Xand advance to the next possible completion.
X.TP
X\fBcomplete-word\fP (unbound) (\|\e\|)
XAttempt completion on the current word.
X.TP
X\fBdelete-char-or-list\fP (^D)
XDelete the character under the cursor.  If the cursor
Xis at the end of the line, list possible completions for the
Xcurrent word.
X.TP
X\fBexecute-named-cmd\fP (ESC-x) Read the name of a editor command and
Xexecute it. A restricted set of editing functions is available in the
Xmini-buffer. An interrupt signal, as defined by the stty setting, will
Xabort the function. The allowed functions are: backward-delete-char,
Xvi-backward-delete-char, kill-region (kills the last word),
Xbackward-kill-word, vi-backward-kill-word, kill-whole-line,
Xvi-kill-line, backward-kill-line, list-choices, delete-char-or-list
Xand accept-line. The space and tab characters, if not bound to one of
Xthese functions, will complete the name and then list the
Xpossibilities if the autolist option is set.
X.TP
X\fBexecute-last-named-cmd\fP (ESC-z)
XRedo the last function executed with \fBexecute-named-cmd\fP.
X.TP
X\fBexpand-cmd-path\fP
XExpand the current command to its full pathname.
X.TP
X\fBexpand-or-complete\fP (TAB) (TAB ^X)
XAttempt shell expansion on the current word.
XIf that fails,
Xattempt completion.
X.TP
X\fBexpand-or-complete-prefix\fP (unbound)
XAttempt shell expansion on the current word upto cursor.
X.TP
X\fBexpand-history\fP (ESC-space ESC-!)
XPerform history expansion on the edit buffer.
X.TP
X\fBexpand-word\fP (^X*)
XAttempt shell expansion on the current word.
X.TP
X\fBlist-choices\fP (ESC-^D) (^D =)
XList possible completions for the current word.
X.TP
X\fBlist-expand\fP (^Xg ^XG) (^G)
XList the expansion of the current word.
X.TP
X\fBmagic-space\fP
XPerform history expansion and insert a space into the
Xbuffer.  This is intended to be bound to space.
X.TP
X\fBmenu-complete\fP
XLike \fBcomplete-word\fP, except that menu completion is used.
XSee the \fBMENU_COMPLETE\fP option below.
X.TP
X\fBmenu-expand-or-complete\fP
XLike \fBexpand-or-complete\fP, except that menu completion is used.
X.TP
X\fBreverse-menu-complete\fP
XSee the \fBMENU_COMPLETE\fP option below.
X.SS Miscellaneous
X.TP
X\fBaccept-and-hold\fP (ESC-A ESC-a)
XPush the contents of the buffer on the buffer stack
Xand execute it.
X.TP
X\fBaccept-and-infer-next-history\fP
XExecute the contents of the buffer.
XThen search the history list for a line matching the current one
Xand push the event following onto the buffer stack.
X.TP
X\fBaccept-line\fP (^J ^M)
XExecute the contents of the buffer.
X.TP
X\fBaccept-line-and-down-history\fP (^O)
XExecute the current line, and push the next history
Xevent on the the buffer stack.
X.TP
X\fBvi-cmd-mode\fP (^X^V) (^[)
XEnter command mode; that is, use the alternate keymap.
XYes, this is bound by default in emacs mode.
X.TP
X\fBvi-caps-lock-panic\fP (unbound) (H K)
XHang until any lowercase key is pressed.
XThis is for vi users without the mental capacity to keep
Xtrack of their caps lock key (like the author).
X.TP
X\fBclear-screen\fP (^L ESC-^L)
XClear the screen and redraw the prompt.
X.TP
X\fBexchange-point-and-mark\fP (^X^X)
XExchange the cursor position with the position of the mark.
X.TP
X\fBget-line\fP (ESC-G ESC-g)
XPop the top line off the buffer stack and insert it at the
Xcursor position.
X.TP
X\fBpound-insert\fP (unbound) (#)
XIf there is no # character at the beginning of the current line,
Xadd one.  If there is one, remove it.  In either case, accept the
Xcurrent line.  The \fBINTERACTIVE_COMMENTS\fP option must be set
Xfor this to have any usefulness.
X.TP
X\fBpush-input\fP
XPush the entire current multiline construct onto the buffer stack and
Xreturn to the top-level (\fBPS1\fP) prompt.
XIf the current parser construct is only a single line, this is exactly
Xlike \fBpush-line\fP.
XNext time the editor starts up or is popped with \fBget-line\fP, the
Xconstruct will be popped off the top of the buffer stack and loaded
Xinto the editing buffer.
X.TP
X\fBpush-line\fP (^Q ESC-Q ESC-q)
XPush the current buffer onto the buffer stack and clear
Xthe buffer.
XNext time the editor starts up, the buffer will be popped
Xoff the top of the buffer stack and loaded into the editing
Xbuffer.
X.TP
X\fBpush-line-or-edit\fP
XAt the top-level (\fBPS1\fP) prompt, equivalent to \fBpush-line\fP.
XAt a secondary (\fBPS2\fP) prompt, move the entire current multiline
Xconstruct into the editor buffer.
XThe latter is equivalent to \fBpush-input\fP followed by \fBget-line\fP.
X.TP
X\fBredisplay\fP (unbound) (^R)
XRedisplays the edit buffer.
END_OF_FILE
  if test 71886 -ne `wc -c <'zsh-2.5.0/man/zsh.1.A'`; then
    echo shar: \"'zsh-2.5.0/man/zsh.1.A'\" unpacked with wrong size!
  elif test -f 'zsh-2.5.0/man/zsh.1.B'; then
    echo shar: Combining  \"'zsh-2.5.0/man/zsh.1'\" \(155263 characters\)
    cat 'zsh-2.5.0/man/zsh.1.A' 'zsh-2.5.0/man/zsh.1.B' > 'zsh-2.5.0/man/zsh.1'
    if test 155263 -ne `wc -c <'zsh-2.5.0/man/zsh.1'`; then
      echo shar: \"'zsh-2.5.0/man/zsh.1'\" combined with wrong size!
    else
      rm zsh-2.5.0/man/zsh.1.A zsh-2.5.0/man/zsh.1.B 
    fi
  fi
  # end of 'zsh-2.5.0/man/zsh.1.A'
fi
if test -f 'zsh-2.5.0/src/config/bz.config.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/src/config/bz.config.h'\"
else
  echo shar: Extracting \"'zsh-2.5.0/src/config/bz.config.h'\" \(11328 characters\)
  sed "s/^X//" >'zsh-2.5.0/src/config/bz.config.h' <<'END_OF_FILE'
X# --- ${C_BLDDIR}config.h
X
Xif test -n "$B_config_h"
Xthen
X
XF_define=yep
XF_using=yep
X
Xecho
Xecho Building ${C_BLDDIR}config.h...
X
X(exec >${C_BLDDIR}config.h
X
X{
Xecho
Xecho '	starting features probing...'
Xecho
X} >&2
X
Xcat <<foo
X/* config.h */
X/* architecture-customized config.h for $VERSION
X * for architecture "$arch",
X * automagically generated by buildzsh -- do not edit */
X
Xfoo
X
Xset elfh elf.h ${headerdir}/sys
X. ./config/bz.walk
X
Xset resourceh resource.h ${headerdir}/sys
X. ./config/bz.walk
X
Xset 'test -n "$elfh" -o -z "$resourceh" -o -n "$SEQUENTPTX"' SYSV 1 'pure SYSV'
X. ./config/bz.ifdef
X
Xif test -n "$_yea"
Xthen
X  PATH=/usr/bin:$PATH
X  export PATH
X  echo '	forcing /usr/bin early in PATH...' >&2
X  if test -n "${elfh}"
X  then
X    echo '#define SYSVR4'
X    echo '	looks like a SYSVR4 system...' >&2
X    force_setpgid=1
X    force_strftime=1
X    if test -n "$SOLARIS"
X    then
X      echo '#define SOLARIS'
X      echo '	looks like a Solaris...' >& 2
X    fi
X    echo
X  fi
Xfi
X
Xecho '/* some environments have broken termios, for example ULTRIX */'
Xset 'test -z "$ULTRIX" -a -z "$APOLLO" -a -z "$BBN" -a -z "$NEXT" -a -f ${headerdir}/termios.h' HAS_TERMIOS 1 'termios'
X. ./config/bz.ifdef
X
Xif test -z "$_nay"
Xthen
X  test -n "$DGUX" && echo '#define CLOBBERS_TYPEAHEAD 1'
Xelse
X
Xset 'test -z "$ULTRIX" -a -z "`grep sgttyb ${headerdir}/sys/ioctl.h 2>/dev/null`"' HAS_TERMIO 1 'termio'
X. ./config/bz.ifdef
Xecho '	using sgttyb...' >&2
X
Xif test -z "$ULTRIX" -a -z "$NEXT"
Xthen
Xcat <<foo
X#define TTY_NEEDS_DRAINING 1
X#define CLOBBERS_TYPEAHEAD 1
X
Xfoo
Xfi
X
Xfi
X
Xtest -n "$IRIX5" && echo '#define IRIX5'
X  
Xset 'test -f ${headerdir}/dirent.h \
X          -a -z "$NEXT" -a -z "$ULTRIX"'\
X    HAS_DIRENT 1 '<dirent.h>'
X. ./config/bz.ifdef
X
Xset 'test -f ${headerdir}/unistd.h' HAS_UNISTD 1 '<unistd.h>'
X. ./config/bz.ifdef
X
Xset stdlibh stdlib.h "/usr/include/ansi ${headerdir}"
X. ./config/bz.walk
X
Xif test -n "$stdlibh"
Xthen
X   set 'grep alloc $stdlibh >/dev/null 2>&1' HAS_STDLIB 1 '<stdlib.h>'
X  . ./config/bz.ifdef
Xfi
X
Xset 'test -f ${headerdir}/string.h' HAS_STRING 1 '<string.h>' '<strings.h>'
X. ./config/bz.ifdef
X
Xif test -f ${headerdir}/strings.h -a -n "${NEXT}" -a Z"${NEXT}" != Z3.x
Xthen
Xcat <<foo
X/* BSD compat */
X#define strchr	index
X#define strrchr	rindex
Xfoo
Xfi
X
Xset 'test -f ${headerdir}/memory.h' HAS_MEMORY 1 '<memory.h>'
X. ./config/bz.ifdef
X
Xif test -n "$_nay"
Xthen
Xset 'grep memset ${headerdir}/string.h >/dev/null 2>&1' '' '' 'memcpy(),memset(),memcmp() from <string.h>' 'redefined memcpy(), memset(), memcmp()' '' '' '
X#define memcpy(dst, src, n)	bcopy(src, dst, n)
X#define memset(dst, ch, n)	do {\
X	char *__DST__ = (char *)(dst);\
X	int __N__ = (int)(n), __CH__ = (int)(ch);\
X	while (__N__--) { __DST__[__N__] = __CH__; } } while(0)
X#define memcmp(s1, s2, n)	bcmp(s1, s2, n)'
X. ./config/bz.ifdef
Xfi
X
Xset 'test -f ${headerdir}/locale.h' HAS_LOCALE 1 '<locale.h>'
X. ./config/bz.ifdef
X
Xif test -f "${headerdir}/utmpx.h"
Xthen
X  _utmp_hs_="${headerdir}/utmpx.h ${headerdir}/utmp.h"
Xelse
X  _utmp_hs_="${headerdir}/utmp.h"
Xfi
X
Xset utmph "utmpx.h utmp.h" ${headerdir}
X. ./config/bz.walk
X
Xset 'test Z$utmph = Z${headerdir}/utmpx.h' HAS_UTMPX 1 '<utmpx.h>' '<utmp.h>'
X. ./config/bz.ifdef
X
Xset 'grep ut_host $utmph >/dev/null 2>&1 && ( test Z"$host" != Zmips || test -n "$OSF1" )' UTMP_HOST 1 'host field in utmp'
X. ./config/bz.ifdef
X
Xset 'test -f ${headerdir}/time.h && (grep timeval ${headerdir}/time.h >/dev/null 2>&1 || test -n "$SCO" )' HAS_TIME 1 '<time.h>' '<sys/time.h>'
X. ./config/bz.ifdef
X
Xset waith wait.h "${headerdir} ${headerdir}/sys" "${headerdir}/sys/wait.h"
X. ./config/bz.walk
X
Xset 'test Z$waith = Z${headerdir}/wait.h' HAS_WAIT 1 '<wait.h>' '<sys/wait.h>'
X. ./config/bz.ifdef
X
Xset 'test -z "$NEXT" && grep "waitpid.*(" $waith >/dev/null 2>&1 || man 2 wait 2>/dev/null | sed "s/_.//g" | grep waitpid >/dev/null' HAS_WAITPID 1 'waitpid()'
X. ./config/bz.ifdef
X
Xset 'grep FD_SET ${headerdir}/sys/types.h >/dev/null 2>&1 || test -f ${headerdir}/sys/select.h || test -n "$LINUX"' HAS_SELECT 1 'select()'
X. ./config/bz.ifdef
X
Xset 'test -f ${headerdir}/sys/select.h \
X     && \
X     grep "struct  *fd_set " ${headerdir}/sys/select.h >/dev/null 2>&1' \
X     HAS_SYS_SELECT 1 \
X     '<sys/select.h>' '' '"struct fd_set" in <sys/select.h>'
X. ./config/bz.ifdef
X
Xcat <<foo
X/* we can't just test for S_IFIFO or check to see if the mknod worked,
X   because the NeXTs sold by a vendor which will remain nameless will
X   happily create the FIFO for you, and then panic when you try to do
X	something weird with them, because they aren't supported by the OS. */
Xfoo
Xset 'test -z "$NEXT" -o Z"$NEXT" != Z2.x' HAS_FIFOS 1 'fifos'
X. ./config/bz.ifdef
X
Xset 'test -n "$force_strftime" -o -n "$MIPS" -o -n "$AIX" -o -n "$LINUX" || \
X     man 3 strftime 2>/dev/null | grep return >/dev/null || \
X     man -s 3c strftime 2>/dev/null | grep return >/dev/null' \
X    HAS_STRFTIME 1 'strftime()'
X. ./config/bz.ifdef
X
Xset 'test -n "$MIPS" -o -n "$AIX" || \
X     grep tcsetpgrp ${headerdir}/unistd.h >/dev/null 2>&1 || \
X     man tcsetpgrp 2>/dev/null | grep process >/dev/null && test -z "$NEXT"' \
X    HAS_TCSETPGRP 1 'tcsetpgrp()'
X. ./config/bz.ifdef
X
X_term_hs_="${headerdir}/termio.h ${headerdir}/sys/termio.h ${headerdir}/termios.h ${headerdir}/sys/termios.h"
X
Xset 'test -z "$NEXT" -a -n "`grep tcgetattr $_term_hs_ 2>/dev/null`"' \
X     HAS_TCCRAP 1 'tcgetattr() and friends'
X. ./config/bz.ifdef
X
Xif test -n "$_nay" -a \( -n "$IRIX" -o -n "$MIPS" \)
Xthen
Xecho '
X/* some environments like IRIX have a broken setpgid()
X * setpgrp() might come to rescue */'
Xfi
Xset 'test -n "$AIX" -o -n "$LINUX" -o -n "$force_setpgid" || \
X     man setpgid 2>/dev/null | grep process >/dev/null && \
X     test -z "$IRIX" -a -z "$MIPS" -a -z "$NEXT"' \
X     HAS_SETPGID 1 'setpgid()' 'setpgrp()'
X. ./config/bz.ifdef
X
Xif test -n "$TITAN"
Xthen
Xecho '
X/* TitanOS has sigrelse(), sighold() and sigset() but it cannot use
X * them simultaneously with -43 */'
Xfi
X
X_signal_hs_="${headerdir}/signal.h ${headerdir}/sys/signal.h ${headerdir}/linux/signal.h"
X
Xset 'test -z "$HPUX" -a -z "$PYR" -a -z "$MIPS" -a -z "$AIX" -a -z "$TITAN" &&
X    (grep SIGRELSE $_signal_hs_ > /dev/null 2>&1 || \
X     man sigrelse 2>/dev/null | grep signal >/dev/null)' \
X    HAS_SIGRELSE 1 'sigrelse()' 'sigblock()'
X. ./config/bz.ifdef
X
Xset 'test -d /../.CONTROL' HAS_RFS 1 RFS
X. ./config/bz.ifdef
X
Xcat <<foo
X/* the stress is on "a working wait3()" because for example HP-UX has
X * sort of working getrusage() but nothing like wait3() */
Xfoo
Xset 'test -f $resourceh -a -z "$HPUX" -a -z "$UNICOS" -a -z "$SOLARIS"' HAS_RUSAGE 1 'getrusage() and wait3()'
X. ./config/bz.ifdef
X
Xif test Z"$host" = Zhp9000s700
Xthen
Xecho '	using hp9000s700 rlimit kludge...' >&2
Xecho '
X/* kludge RLIM code for HPUX s700 - These limits are all readable,and
X * some like coredumpsize are settable by users
X */
X#define RLIMIT_CPU	0		/* cpu time in milliseconds */
X#define RLIMIT_FSIZE	1		/* maximum file size */
X#define RLIMIT_DATA	2		/* data size */
X#define RLIMIT_STACK	3		/* stack size */
X#define RLIMIT_CORE	4		/* core file size */
X#define RLIMIT_RSS	5		/* resident set size */
X
X#define RLIM_INFINITY	0x7fffffff
X'
Xfi
X
XSTD_DUMP="cat /etc/passwd"
XNIS_DUMP="ypcat passwd.byname"
XNI_DUMP="nidump passwd /"
XDUMP_USERS="$STD_DUMP"
X
Xset 'test -f /usr/bin/ypcat && $NIS_DUMP > /dev/null 2>&1' HAS_NIS 1 NIS
X. ./config/bz.ifdef
X
Xif test -n "$_yea"
Xthen
X  DUMP_USERS="$NIS_DUMP"
Xelse
X  test -d /NextApps && $NI_DUMP > /dev/null 2>&1 && DUMP_USERS="$NI_DUMP"
Xfi
X
Xlot_user=`$DUMP_USERS | awk '{if(NR>'$LOTSA_USERS'){print;exit 1}}'`
Xif test -n "$B_query"
Xthen
X{
X  echo
X  echo "Username caching is useful if there are more than $LOTSA_USERS users..."
X} >&2
Xfi
XG_verb2_=use
Xset 'test -n "$lot_user"' CACHE_USERNAMES 1 'username caching'
X. ./config/bz.ifdef
X
Xset 'egrep "SIG_DFL|sighandler_t" $_signal_hs_ 2>/dev/null | grep void > /dev/null && test -z "$IRIX" || test -n "$SCO" ' SIGVOID 1 'signal handlers returning void' 'signal handlers returning int'
X. ./config/bz.ifdef
X
Xset 'test -n "`grep SIGTSTP $_signal_hs_ 2>/dev/null`"' \
X    HAS_AUTORESETHAND 1 'automatically reset signal handlers' \
X    'forced reset signal handlers'
X. ./config/bz.ifdef
X
Xif test -n "$_yea"
Xthen
Xset 'test -z "$HPUX" -a -z "$MIPS" -a -z "$IRIX" -a -z "$TITAN" -a -z "$AIX" \
X   && (man 2 sigset 2>/dev/null | grep handler >/dev/null )' \
X    USE_SIGSET 1 'sigset() to install said signal handlers'
X. ./config/bz.ifdef
Xfi
X
X{
Xecho
Xecho '	finished probing features...'
X} >&2
X
Xcat <<foo
X#if defined(SIGVOID) || defined(IRIX5) || defined(SCO)
X#define HANDTYPE void
X#else
X#define HANDTYPE int
X#define INTHANDTYPE
X#endif
X
X/* a string corresponding to the host type */
X
X#define HOSTTYPE "$host"
X
X/* the default editor for the fc builtin */
X#define DEFFCEDIT "vi"
Xfoo
Xecho
X
Xif test -n "`egrep 'UTMP_FILE|_PATH_UTMP' $_utmp_hs_ 2>/dev/null`"
Xthen :
Xelse 
Xset WTMP wtmp "/etc /usr/etc /var/adm /usr/adm" /dev/null
X. ./config/bz.walk
Xset UTMP utmp "/etc /usr/etc /var/adm /usr/adm" /dev/null
X. ./config/bz.walk
Xcat <<foo
X/* the path of wtmp */
X#define WTMP_FILE "$WTMP"
X
X/* the path of utmp */
X#define UTMP_FILE "$UTMP"
Xfoo
Xfi
X
X{
X  echo
X  echo '	defining installation specifics...'
X  echo
X} >&2
X
Xset DEFTMPPREFIX /tmp/zsh 'default prefix for temporary files' '' '"'
X. ./config/bz.define
X
XETCDIR=$C_ETCDIR
X
Xset GLOBALZSHENV ${ETCDIR}/zshenv \
X"the global file to source absolutely first whenever zsh is run;
Xif undefined, don't source anything" 1 '"'
X. ./config/bz.define
X
Xset GLOBALZSHRC ${ETCDIR}/zshrc \
X"the global file to source whenever zsh is run;
Xif undefined, don't source anything" 1 '"'
X. ./config/bz.define
X
Xset GLOBALZLOGIN ${ETCDIR}/zlogin \
X"the global file to source whenever zsh is run as a login shell;
Xif undefined, don't source anything" 1 '"'
X. ./config/bz.define
X
Xset GLOBALZPROFILE ${ETCDIR}/zprofile \
X"the global file to source whenever zsh is run as a login shell,
Xbefore zshrc is read; if undefined, don't source anything" 1 '"'
X. ./config/bz.define
X
XF_define=yep
X
Xif test -n "$B_query"
Xthen
X{
X  echo
X  echo "The following question is about the text printed by zsh"
X  echo "when a process is suspended/stopped under job control."
X} >&2
Xfi
XG_verb2_=prefer
Xset true USE_SUSPENDED 1 '"suspended" instead of "stopped"' '"stopped" instead of "suspended"'
X. ./config/bz.ifdef
X
Xset DEFAULT_HISTSIZE 30 \
X"the default history buffer size in lines"
X. ./config/bz.define
X
Xcat <<'foo'
X#define _BSD_COMPAT		/* this could be IRIX,  you never know */
X#define _BSD_TYPES		/* this could be IRIX5, you never know */
X#define _BSD			/* this could be HP-UX, you never know */
X#define _BSD_INCLUDES		/* this could be AIX,   you never know */
X#define _BBN_POSIX_SUPPORT	/* this could be nX,    you never know */
X
X/* if your compiler doesn't like void *,
X * change this to char * and ignore all the warnings. */
X
Xtypedef void * vptr;
X
X#define JOB_CONTROL
X
X/* define this if you want to use zsh's own allocator */
X/* #define USE_ZSH_MALLOC */
X
X#ifdef USE_ZSH_MALLOC
X
X/* define this if you want the allocator to store information */
X
X/* #define MEM_DEBUG */
X
X/* define this if you want to get error messages from the allocator */
X
X/* #define MEM_WARNING */
X
X/* define this if you want free() to be really save */
X
X/* #define SECURE_FREE */
X
X#endif /* USE_ZSH_MALLOC */
X
X/* end of config.h */
Xfoo
X
X{
X  echo
X  echo '	defined installation specifics...'
X} >&2
X
X)
Xfi
END_OF_FILE
  if test 11328 -ne `wc -c <'zsh-2.5.0/src/config/bz.config.h'`; then
    echo shar: \"'zsh-2.5.0/src/config/bz.config.h'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/src/config/bz.config.h'
fi
echo shar: End of archive 3 \(of 18\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
