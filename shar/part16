Path: news.csc.fi!news.eunet.fi!EU.net!uunet!sparky!not-for-mail
From: zsh-list@sterling.com (Bas de Bakker)
Newsgroups: comp.sources.misc
Subject: v43i105:  zsh - The Z shell, version 2.5.0, Part16/18
Followup-To: comp.sources.d
Date: 13 Jul 1994 23:07:50 -0500
Organization: Sterling Software
Lines: 3465
Sender: kent@sparky.sterling.com
Approved: kent@sparky.sterling.com
Message-ID: <302dmm$8l@sparky.sterling.com>
References: <csm-v43i089=zsh.230017@sparky.sterling.com>
NNTP-Posting-Host: sparky.sterling.com
X-Md4-Signature: 79d99170e76afbcda48a0e0dccd70948

Submitted-by: zsh-list@sterling.com (Bas de Bakker)
Posting-number: Volume 43, Issue 105
Archive-name: zsh/part16
Environment: UNIX
Supersedes: zsh: Volume 35, Issue 51-72

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  zsh-2.5.0/README zsh-2.5.0/help/fg
#   zsh-2.5.0/scripts/lete2ctl zsh-2.5.0/src/config/bz.Makefile
#   zsh-2.5.0/src/config/bz.help zsh-2.5.0/src/config/config.README
#   zsh-2.5.0/src/table.c zsh-2.5.0/src/text.c zsh-2.5.0/src/watch.c
#   zsh-2.5.0/src/zle.h zsh-2.5.0/src/zle_word.c
# Wrapped by kent@sparky on Tue Jul 12 16:47:27 1994
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 16 (of 18)."'
if test -f 'zsh-2.5.0/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/README'\"
else
  echo shar: Extracting \"'zsh-2.5.0/README'\" \(6375 characters\)
  sed "s/^X//" >'zsh-2.5.0/README' <<'END_OF_FILE'
XThis is zsh version 2.5.0.  Zsh is a shell with lots of features.  For
Xa list of these, see the FEATURES file.  For more details, see the
Xdocumentation.
X
X
XInstalling zsh
X--------------
XTo compile zsh, cd into the src directory and type "./buildzsh".  The
Xbuildzsh script takes various options that are useful if you want to
Xuse a nonstandard compiler, build on several architectures, etc.  Do a
X"./buildzsh help" for details.  If no errors occur, you can install
Xzsh by typing "make install".  This will install the executable and
Xthe manpage.
X
XThe compilation procedure has recently been tested and found to work
Xon the machines listed below.  It might work on others, too,
Xparticularly if they're small variations of these.  If so, please tell
Xus about it.
X
XSunOS 4.1.1 and 4.1.3
XSunOS 5.1 and 5.2
XSolaris 2.3
XLinux (various versions), but can't use USE_ZSH_MALLOC
XAIX 3.2
XHP9000/700, after manually telling buildzsh to use setpgid
XHP9000/827, but only with GCC
XHP9000/847
XHPUX 9.04
XNeXT with NS3.0 and NS3.1
XIRIX 5.1.1.1 and 5.2
XAlpha with OSF/1 1.2, 1.3 and 2.0
XAlpha with Ultrix (unspecified)
XDECstation with Ultrix (unspecified)
XDECstation 5000/240 with Ultrix 4.2A
XDECstation 5000/25 with Mach 3.0
XNetBSD 0.9b
XDYNIX/ptx 1.4 and 2.0.4 with X11
XSony NWS with NEWS-OS 3.3
XMac with MiNT after redefining the zgetwd() function as getwd()
X
XIf you have used zsh before, please be sure to read the section
X"Important changes" below.
X
XIncluded in this release are alternative malloc and associated
Xfunctions which reduce memory usage on some systems.  You can use
Xthese by defining USE_ZSH_MALLOC in config.h.
X
X
XDocumentation
X-------------
XThere are a number of documents about zsh in this distribution:
X
Xman/zsh.1	A manpage in nroff format.  This will be installed in
X		/usr/man/man1 by "make install".
X
Xdoc/intro.ms	An introduction to zsh in troff format using the ms
X		macros.  This document explains many of the features
X		that make zsh more equal than other shells.
X
Xdoc/zsh.texi	Everything the manpage has, but in texinfo format.
X
XIf you do not have the necessary tools to process these documents,
Xpostscript, ascii and info versions are available in a separate file
Xat the distribution sites:
X
Xcarlo.phys.uva.nl:/pub/bas/zsh/zsh-2.5.0doc.tar.gz
Xftp.sterling.com:/zsh/zsh-2.5.0doc.tar.gz
X
XThe distribution also contains a help directory with descriptions of
Xbuiltin commands taken from the manpage.  The example function
Xfunc/run-help will view the appropriate file from the help directory,
Xset in the HELPDIR variable, or run 'man' if such a file is not
Xavailable.
X
X
XImportant changes
X-----------------
XThis is a list of changes in zsh compared to version 2.3.1 which might
Xforce you to change your old initialization files.
X
XThe -h option to compctl for host completion no longer exists.  Define
Xa hosts variable and use compctl -k hosts instead.  Example: change
Xcompctl -h ping
Xto
Xcompctl -k hosts ping
X
XThe hostcmds, bindcmds, optcmds and varcmds special arrays no longer
Xexist.  Use compctl -k hosts, -b, -o and -v respectively.
X
XThe NO_UNSET option applies to the positional parameters (usually the
Xarguments to a script) as well as to all other parameters.
X
XThere is a new option CSH_JUNKIE_PAREN which has to be set to allow
Xthe csh-syntax "if (test) { foo }" to work.  This has been done to
Xenhance sh compatibility, where "if (test)" might be used to run
X"test" in a subshell.
X
X
XFeedback
X--------
XZsh is currently maintained by the members of the zsh mailing list:
X
X	zsh-list@sterling.com
X
XIf you wish to subscribe to the mailing list, send an email message to
X	Majordomo@sterling.com
X(this is an automated server) containing
X	subscribe zsh-list <optional-address>
Xwhere <optional-address> can be blank if you want to subscribe from
Xyour current email address.  Send the message `help' to the same
Xaddress for help on the list server; `unsubscribe zsh-list' also
Xworks. (Don't send this to the list!). The list manager, Rick Ohnemus,
Xcan be reached at
X	owner-zsh-list@sterling.com
X
XYou can send bug reports, compliments and the like to the mailing
Xlist.  If are not a subscriber and would like to receive an answer,
Xplease mention so in your message.
X
X
XAuthors
X-------
XZsh was originally written by Paul Falstad, people who have supplied
Xpatches for this release are (in lexical order):
X
XChris.Moore@src.bae.co.uk (Chris Moore)
XHarald.Eikrem@delab.sintef.no
XIrving_Wolfe@happy-man.com (Irving Wolfe)
XJarkko.Hietaniemi@hut.fi (Jarkko Hietanimi)
XP.Stephenson@swansea.ac.uk (Peter Stephenson)
XRichard.Sharman@software.mitel.com (Richard Sharman)
XTero_Kivinen@hut.FI (Tero Kivinen)
Xarf@maths.nott.ac.uk (Anthony Iano-Fletcher)
Xbas@phys.uva.nl (Bas de Bakker)
Xbenson@odi.com (Benson Margulies)
Xbillb@bedford.progress.com (Bill Burton)
Xbrown@wi.extrel.com (M. Brown)
Xcarlos@snfep1.if.usp.br (Carlos Carvalho)
Xcedman@capitalist.princeton.edu (Carl Edman)
Xchip%fin@myrddin.sybus.com (Chip Salzenberg)
Xchs@apu.fi (Hannu Strang)
Xcross@eng.umd.edu (Chris Ross)
Xdm@cs.brown.edu (Dimitris Michailidis)
Xdmm0t@rincewind.mech.virginia.edu (David M. Meyer)
Xesky@CS.UCLA.EDU (Eskandar Ensafi)
Xfranl@centerline.com (Fran Litterio)
Xgansevle@cs.utwente.nl (Fred Gansevles)
Xgnohmon@ssiny.com (Ralph Betza)
Xguillaum@clipper.ens.fr (Florent Guillaume)
Xguthrie@math.upenn.edu (John Guthrie)
Xhegedus@celeste.eng.yale.edu (Peter Hegedus)
Xhoh@approve.se (Goran Larsson)
Xhooft@chem.ruu.nl (Rob Hooft)
Xhsw1@papa.attmail.com (Stephen Harris)
Xirving@happy-man.com (Irving Wolfe)
Xjch@cs.cmu.edu (Jonathan Hardwick)
Xjhi@dol-guldur.hut.fi (Jarkko Hietaniemi)
Xjos@oce.nl (Jos Backus)
Xliblit@cs.psu.edu (Benjamin Liblit)
Xmarc@cam.org (Marc Boucher)
Xmason@werple.apana.org.au (Geoff Wing)
Xmycroft@gnu.ai.mit.edu (Charles Hannum)
Xmystic@axposf.pa.dec.com (D. Hall)
Xnorbert@i3.informatik.rwth-aachen.de (Norbert Kiesel)
Xoberon@cs.tu-berlin.de (Sven Wischnowsky)
Xpclink@qld.tne.oz.au (Rick)
Xpem@aaii.oz.au (Paul Maisano)
Xper@efd.lth.se (Per Foreby)
Xpf@z-code.com (Paul Falstad)
Xroderick@ibcinc.com (Roderick Schertler)
Xschaefer@z-code.com (Bart Schaefer)
Xschlangm@informatik.uni-muenchen.de (Harald Schlangmann)
Xseniorr@teleport.com (Russell Senior)
Xsinclair@dcs.gla.ac.uk (Duncan Sinclair)
Xsterling@oldcolo.com (Bruce Sterling Woodcock)
Xsuzuki@otsl.oki.co.jp (Hisao Suzuki)
Xtsm@cs.brown.edu (Timothy Miller)
Xwacker@physik.uni-dortmund.de (Klaus Wacker)
Xwacren@cis10.ens-cachan.fr (Laurent Wacrenier)
END_OF_FILE
  if test 6375 -ne `wc -c <'zsh-2.5.0/README'`; then
    echo shar: \"'zsh-2.5.0/README'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/README'
fi
if test -f 'zsh-2.5.0/help/fg' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/help/fg'\"
else
  echo shar: Extracting \"'zsh-2.5.0/help/fg'\" \(156 characters\)
  sed "s/^X//" >'zsh-2.5.0/help/fg' <<'END_OF_FILE'
X       fg [ job ... ]
X       job ...
X              Bring the specified jobs to the foreground.  If  no
X              job is specified, use the current job.
END_OF_FILE
  if test 156 -ne `wc -c <'zsh-2.5.0/help/fg'`; then
    echo shar: \"'zsh-2.5.0/help/fg'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/help/fg'
fi
if test -f 'zsh-2.5.0/scripts/lete2ctl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/scripts/lete2ctl'\"
else
  echo shar: Extracting \"'zsh-2.5.0/scripts/lete2ctl'\" \(9250 characters\)
  sed "s/^X//" >'zsh-2.5.0/scripts/lete2ctl' <<'END_OF_FILE'
X#!/usr/local/bin/perl -- -*-perl-*-
X#
X#   ``Wee have also Shelles, thee Lyke of whych you knowe not, wherein
X#     thee User may with thee merest Presse of thee Tabbe-Keye expande
X#     or compleat al Maner of Wordes and such-like Diversities.''
X#            - Francis Bacon, `New Atlantis' (or not).
X#
X# Convert tcsh "complete" statements to zsh "compctl" statements.
X# Runs as a filter.  Should ignore anything which isn't a "complete".
X# It expects each "complete" statement to be the first thing on a line.
X# All the examples in the tcsh manual give sensible results.
X# Author:  Peter Stephenson <pws@s-a.amtp.liv.ac.uk>
X#
X# Option:
X# -x (exact): only applies in the case of command disambiguation (is
X#    that really a word?)  If you have lines like
X#       complete '-co*' 'p/0/(compress)'
X#    (which makes co<TAB> always complete to `compress') then the
X#    resulting "compctl" statements will produce one of two behaviours:
X#    (1) By default (like tcsh), com<TAB> etc. will also complete to
X#        "compress" and nothing else.
X#    (2) With -x, com<TAB> does ordinary command completion: this is
X#        more flexible.
X#    I don't understand what the hyphen in complete does and I've ignored it.
X#
X# Notes:
X# (1) The -s option is the way to do backquote expansion.  In zsh,
X#     "compctl -s '`users`' talk" works (duplicates are removed).
X# (2) Complicated backquote completions should definitely be rewritten as
X#     shell functions (compctl's "-K func" option).  Although most of
X#     these will be translated correctly, differences in shell syntax
X#     are not handled.
X# (3) Replacement of $:n with the n'th word on the current line with
X#     backquote expansion now works; it is not necessarily the most
X#     efficient way of doing it in any given case, however.
X# (4) I have made use of zsh's more sophisticated globbing to change
X#     things like ^foo.{a,b,c,d} to ^foo.(a|b|c|d), which works better.
X#     It's just possible in some cases you may want to change it back.
X# (5) Make sure all command names with wildcards are processed together --
X#     they need to be lumped into one "compctl -C" or "compctl -D"
X#     statement for zsh.
X
X# Handle options
X($ARGV[0] eq '-x') && shift && ($opt_x = 1);
X($ARGV[0] =~ /^-+$/) && shift;
X
X# Function names used (via magic autoincrement) when cmdline words are needed
X$funcnam = 'compfn001';
X
X# Read next word on command line
Xsub getword {
X    local($word, $word2, $ret);
X    ($_) = /^\s*(.*)$/;
X    while ($_ =~ /^\S/) {
X	if (/^[\']/) {
X	    ($word, $_) = /^\'([^\']*).(.*)$/;
X	} elsif (/^[\"]/) {
X	    ($word, $_) = /^\"([^\"]*).(.*)$/;
X	    while ($word =~ /\\$/) {
X		chop($word);
X		($word2, $_) = /^([^\"]*).(.*)$/;
X		$word .= '"' . $word2;
X	    }
X	} elsif (/\S/) {
X	    ($word, $_) = /^([^\s\\\'\"#;]*)(.*)$/;
X	    # Backslash: literal next character
X	    /^\\(.)/ && (($word .= substr($_,1,1)),
X			 ($_ = substr($_,2)));
X	    # Rest of line quoted or end of command
X	    /^[#;]/ && ($_ = '');
X	} else {
X	    return undef;
X	}
X	length($word) && ($ret = $ret . $word);
X    }
X    $ret;
X}
X
X# Interpret the x and arg in 'x/arg/type/'
Xsub getpat {
X    local($pat,$arg) = @_;
X    local($ret,$i);
X    if ($pat eq 'p') {
X	$ret = "p[$arg]";
X    } elsif ($pat eq 'n' || $pat eq 'N') {
X	$let = ($arg =~ /[*?|]/) ? 'C' : 'c';
X	$num = ($pat eq 'N') ? 2 : 1;
X	$ret = "${let}[-${num},$arg]";
X    } elsif ($pat eq 'c' || $pat eq 'C') {
X	# A few tricks to get zsh to ignore up to the end of
X	# any matched pattern.
X	if (($pat eq 'c' && $arg =~ /^\*([^*?]*)$/)) {
X	    $ret = "n[-1,$1]";
X	} elsif ($arg =~ /[*?]([^*?]*)$/) {
X	    length($1) && ($ret = " n[-1,$1]");
X	    $ret = "C[0,$arg] $ret";
X	} else {
X	    $let = ($pat eq 'c') ? 's' : 'S';
X	    $ret = "${let}[$arg]";
X	}
X    }
X    $ret =~ s/'/'\\''/g;
X    $ret;
X}
X
X# Interpret the type in 'x/arg/type/'
Xsub gettype {
X    local ($_) = @_;
X    local($qual,$c,$glob,$ret,$b,$m,$e,@m);
X    $c = substr($_,0,1);
X    ($c =~ /\w/) && (substr($_,1,1) eq ':') && ($glob = substr($_,2));
X# Nothing (n) can be handled by returning nothing.  (C.f. King Lear, I.i.)
X    if ($c =~ /[abcjuv]/) {
X	$ret = "-$c";
X    } elsif ($c eq 'S') {
X	$ret = '-k signals';
X    } elsif ($c eq 'd') {
X	$qual = '/';
X    } elsif ($c eq 'e') {
X	$ret = '-E';
X    } elsif ($c eq 'f' && !$glob) {
X	$ret = '-f';
X    } elsif ($c eq 'l') {
X	$ret = qq
X-k  '(cputime filesize datasize stacksize coredumpsize resident descriptors)'
X    ;
X    } elsif ($c eq 'p') {
X	# Use globbing, but make sure there's a star at the end
X	($glob =~ /\*$/) || ($glob .= '*');
X    } elsif ($c eq 's') {
X	$ret = '-p';
X    } elsif ($c eq 't') {
X	$qual = '.';
X    } elsif ($c eq 'x') {
X	$glob =~ s/'/'\\''/g;
X	$ret = "-X '$glob'";
X	undef($glob);
X    } elsif ($c eq '$') {     # '{
X	$ret = "-k " . substr($_,1);
X    } elsif ($c eq '(') {
X	s/'/'\\''/g;
X	$ret = "-k '$_'";
X    } elsif ($c eq '`') {
X	# this took some working out...
X	if (s/\$:(\d+)/$foo=$1+1,"\${word[$foo]}"/ge) {
X	    $ret = "-K $funcnam";
X	    $genfunc .= <<"HERE";
Xfunction $funcnam {
X    local word
X    read -cA word
X    reply=($_)
X}
XHERE
X	    $funcnam++;
X	} else {
X	    s/'/'\\''/g;
X	    $ret = "-s '$_'";
X	}
X    }
X
X    # foo{bar,ba,blak,sheap} -> foo(bar|ba|blak|sheap).
X    # This saves a lot of mess, since in zsh brace expansion occurs
X    # before globbing.  I'm sorry, but I don't trust $` and $'.
X    while ((($b,$m,$e) = ($glob =~ /^(.*)\{(.*)\}(.*)$/))
X	   && ($m =~ /,/)) {
X	@m = split(/,/, $m);
X	for ($i = 0; $i < @m; $i++) {
X	    while ($m[$i] =~ /\\$/) {
X		substr($m[$i],-1,1) = "";
X		splice(@m,$i,2,"$m[$i]\\,$m[$i+1]");
X	    }
X	}
X	$glob = $b . "(" . join('|',@m) . ")" . $e;
X    }
X
X    if ($qual) {
X	$glob || ($glob = '*');
X	$glob .= "($qual)";
X    }
X    $glob && (($glob =~ s/'/'\\''/g),($glob = "-g '$glob'"));
X
X    defined($ret) && defined($glob) && ($ret .= " $glob");
X    defined($ret) ? $ret : $glob;
X}
X
X# Quoted array separator for extended completions
X$" = " - ";
X
Xwhile (<>) {
X    if (/^\s*complete\s/) {
X	$wc = 0;
X	undef(@stuff); undef($default);
X	$_ = $';
X	while (/\\$/) {
X	    # Remove backslashed newlines: in principle these should become
X	    # real newlines inside quotes, but what the hell.
X	    ($_) = /^(.*)\\$/;
X	    $_ .= <>;
X	}
X	$command = &getword;
X	if ($command =~ /^-/ || $command =~ /[*?]/) {
X	    # E.g. complete -co* ...
X	    $defmatch = $command;
X	    ($defmatch =~ /^-/) && ($defmatch = substr($defmatch,1));
X	} else {
X	    undef($defmatch);
X	}
X	while (defined($word = &getword)) {
X	    # Loop over remaining arguments to "complete".
X	    $sep = substr($word,1,1);
X	    $sep =~ s/(\W)/\\$1/g;
X	    @split = split(/$sep/,$word);
X	    for ($i = 0; $i < 3; $i++) {
X		while ($split[i] =~ /\\$/) {
X		    substr($split[i],-1,1) = "";
X		    splice(@split,$i,2,"$split[i]\\$sep$split[i+1]");
X		}
X	    }
X	    ($pat,$arg,$type,$suffix,$crap) = @split;
X	    ($suffix =~ /^\s*$/) && undef($suffix);
X	    if (($word =~ /^n${sep}\*${sep}/) &&
X		 (!defined($defmatch))) {
X		 # The "complete" catch-all:  treat this as compctl\'s
X		 # default (requiring no pattern matching).
X		$default .= &gettype($type) . ' ';
X		defined($suffix) && ($defsuf .= $suffix);
X	    } else {
X		$pat = &getpat($pat,$arg);
X		$type = &gettype($type);
X		if (defined($defmatch)) {
X		    # The command is a pattern: use either -C or -D option.
X		    if ($pat eq 'p[0]') {
X			# Command word (-C): 'p[0]' is redundant.
X			if ($defmatch eq '*') {
X			    $defcommand = $type;
X			} else {
X			    ($defmatch =~ /\*$/) && chop($defmatch);
X			    if ($opt_x) {
X				$c = ($defmatch =~ /[*?]/) ? 'C' : c;
X				$pat = "${c}[0,${defmatch}]";
X			    } else {
X				$pat = ($defmatch =~ /[*?]/) ?
X				    "C[0,${defmatch}]" : "S[${defmatch}]";
X			    }
X			    push(@commandword,defined($suffix) ?
X				 "'$pat' $type -S '$suffix'" : "'$pat' $type");
X			}
X		    } elsif ($pat eq "C[-1,*]") {
X			# Not command word completion, but match
X			# command word (only)
X			if ($defmatch eq "*") {
X			    # any word of any command
X			    $defaultdefault .= " $type";
X			} else {
X			    $pat = "W[0,$defmatch]";
X			    push(@defaultword,defined($suffix) ?
X				 "'$pat' $type -S '$suffix'" : "'$pat' $type");
X			}
X		    } else {
X		        # Not command word completion, but still command
X			# word with pattern
X			($defmatch = '*') || ($pat = "W[0,$defmatch] $pat");
X			push(@defaultword,defined($suffix) ?
X			     "'$pat' $type -S '$suffix'" : "'$pat' $type");
X		    }
X		} else {
X		    # Ordinary command
X		    push(@stuff,defined($suffix) ?
X			 "'$pat' $type -S '$suffix'" : "'$pat' $type");
X		}
X	    }
X	}
X        if (!defined($defmatch)) {
X	    # Ordinary commands with no pattern
X	    print("compctl $default");
X	    defined($defsuf) && print("-S '$defsuf' ") && undef($defsuf);
X	    defined(@stuff) && print("-x @stuff -- ");
X	    print("$command\n");
X	}
X	if (defined($genfunc)) {
X	    print $genfunc;
X	    undef($genfunc);
X	}
X    }
X}
X
X(defined(@commandword) || defined($defcommand)) &&
X    print("compctl -C ",
X	  defined($defcommand) ? $defcommand : '-c',
X	  defined(@commandword) ? " -x @commandword\n" : "\n");
X
Xif (defined($defaultdefault) || defined(@defaultword)) {
X    defined($defaultdefault) || ($defaultdefault = "-f");
X    print "compctl -D $defaultdefault";
X    defined(@defaultword) && print(" -x @defaultword");
X    print "\n";
X}
X
X__END__
END_OF_FILE
  if test 9250 -ne `wc -c <'zsh-2.5.0/scripts/lete2ctl'`; then
    echo shar: \"'zsh-2.5.0/scripts/lete2ctl'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/scripts/lete2ctl'
fi
if test -f 'zsh-2.5.0/src/config/bz.Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/src/config/bz.Makefile'\"
else
  echo shar: Extracting \"'zsh-2.5.0/src/config/bz.Makefile'\" \(7495 characters\)
  sed "s/^X//" >'zsh-2.5.0/src/config/bz.Makefile' <<'END_OF_FILE'
X# --- ${C_BLDDIR}Makefile
X
Xif test -n "$B_Makefile"
Xthen
X
XF_define=
XF_using=yep
X
Xcat <<foo
X
XBuilding $MAKEFILE...
X
Xfoo
X
X# configure the needed variables
X
Xtest -z "$make_probe_done" && . ./config/bz.makeprobe
X
X# just build it!
X
X(exec >$MAKEFILE
Xcat <<foo
X#! /bin/make -f
X# Makefile
X# architecture-customized Makefile for $VERSION
X# for architecture "$arch",
X# automagically generated by buildzsh -- do not edit
X
XMAKE=make
X
XAUX=buildzsh
X
XSRC=$SRC
X
XHEADER=$HEADER
X
XPROTO=$PROTO
X
XOBJS=$OBJS
X
XBINDIR=$C_BINDIR
XMANDIR=$C_MANDIR
X
X# Debugging flags
XDFLAGS=$DFLAGS
X
XCC=$CC
X
XCFLAGS=$CFLAGS
X
XCFLAGS_WO_O=$CFLAGS_WO_O
X
XLD=$LD
X
XLDFLAGS=$LDFLAGS
X
XLIBS=$LIBS
X
XZSHPATH=${C_BLDDIR}zsh
X
Xall: \$(PROTO) \$(ZSHPATH)
X
X.SUFFIXES: .c .o .pro
X
Xfoo
X
Xecho '	...possible notes' 1>&2
X
Xecho '	...special rules' 1>&2
X
X# --- notes for various environments (and compilers)
X
X# Past problems: (PLEASE COLLECT PAST PROBLEMS WITH COMPILERS
X# HERE: NOT ERRORS/WARNINGS BUT STUFF ABOUT COMPILER CRASHES AND SUCH)
X#
X# AIX c89 -O -c builtin.c/2.4.60...2.4.2xx used to dump core,
X# AIX 3.2.4 fixes the situation, harass your IBM rep until you get the patches.
X# (the temporary patch is to use cc on builtin.c)
X#
X# IRIX cc -ansiposix -O zle_misc.c/2.4.75..2.4.2xx used to dump core,
X# later zsh patchlevels do not have this problem
X# (the temporary patch was to drop -O on zle_misc.c)
X#
X
Xif test -n "$AIX"
Xthen
Xcat <<foo
X#	--- AIX notes
X#	Note 1:	Pre-3.2.4 AIX c89 -O -c builtin.c dumps core,
X#		the temporary cure is to use cc on builtin.c.
X#
X#	Note 2: 3.2.4-onwards AIX cc -O builtin.c gets stuck (optimizer
X#		tries too hard), the temporary cure is to drop -O.
X#
X# @@@ NOTE: won't work if srcdir != blddir
X${C_BLDDIR}builtin.o:     ${C_SRCDIR}builtin.c
X	cc \$(CFLAGS_WO_O) \$(DFLAGS) -o builtin.o -c builtin.c
X
Xfoo
Xelif test -n "$HPUX"
Xthen
Xcat <<'foo'
X#	--- HPUX notes
X#	With c89 you will get warnings ftom
X#	from zle_tricky.c: warning 530: Casting from loose to strict alignment.
X#	this problem is caused by casting "char *"s to e.g. Cmdnam-
X#	structures and then immediately accessing the elements, like this: 
X#	char *s;
X#	char *cn;
X#	{
X#	    if (((Cmdnam) cn)->type != DISABLED)
X#
Xfoo
Xelif test -n "$CONVEX"
Xthen
Xcat <<'foo'
X#	--- CONVEX notes
X#	cc options NOT used:
X#	-std (strict ANSI + POSIX, non-POSIX not recognized, e.g. long long)
X#	-str (strict ANSI, UNIX functions not recognized)
X#	diagnostics not used (zsh code too "hopeless"):
X#	assign_in_condition metrics_file metrics_off
X#	negative_to_uns pointer_alignment_efficiency skip_to_char skip_to_eof
X#	Note 1: man cc lies that ptr_cvt_truncates is ptr_convert_truncates
X#	Note 2: cc notices that init.c:main() never returns
X#	Note 3: utils.c:intr() and holdintr() sigvec initializations
X#	        are somehow suspicious
X#
Xfoo
Xelif test -n "$SOLARIS"
Xthen
Xcat <<'foo'
X#	--- SOLARIS notes
X#	SunSoft cc assumed (CFLAGS derived from this assumption),
X#	if you want to use gcc, try 'buildzsh gcc'
Xfoo
Xelif test -n "$NEXT"
Xthen
Xcat <<'foo'
X#	--- NEXT notes
X#	You will get two warnings for each file because
X#	/NextDeveloper/Headers/bsd/memory.h:23 contains
X#	ANSI-illegal trash after #endif.
X#
Xfoo
Xelif test -n "$UNICOS"
Xthen
Xcat <<'foo'
X#	--- UNICOS notes
X#	Note 1: you will get five WARNINGs for each file because of
X#	        a) <sys/param.h>, <sys/ioctl.h>:
X#		   there is something else than just newline after
X#		   directives #endif or #else (Cray's fault)
X#	It *is* possible to get more picky by adding '-h port=insx'
X#	to the CFLAGS but then a horde of complaints will jump at you:
X#	Note 2: a) <stdio.h>:
X#		   use bit fields other than signed int or unsigned int
X#	        b) <sys/file.h>:
X#		   union members have different types
X#	        b1) f_uinode and f_udata
X#	        b2) f_unext and f_udata
X#	        (both of these Cray's fault)
X#	Note 3: zsh.h: union members have different types
X#	        a1) nam and binnum	a5) arr and val
X#	        a2) nam and list		a6) str and val
X#	        a3) binnum and list	a7) cfn and ifn
X#	        a4) arr and str		a8) ifn and afn
X#	        b) cond.c:
X#	        pointer is cast to a pointer of another type
X#	Note 4: from most of the zsh source files LOTS of:
X#	        a) an assignment to a shorter integral type may cause truncation
X#	        b) an integral type is cast to  pointer
X#	        c) a character pointer cast may result in improprer alignment
X#	        d) a "char" assigned to a larger "int" may sign-extend incorrectly
X#
Xfoo
X# IRIX5 test before IRIX test because IRIX5 is also IRIX but we
X# want IRIX5-specific stuff here
Xelif test -n "$IRIX5"
Xthen
Xcat <<'foo'
X#	-- IRIX5 notes
X#	Warnings turned off:
X#	799: /usr/include/sgidefs.h, line 141: 'long long' is not standard ANSI. (3.1.1)
X#
Xfoo
Xelif test -n "$IRIX"
Xthen
Xcat <<'foo'
X#	--- IRIX notes
X#	Warnings turned off:
X#	  2: %s redefinition hides earlier one
X#	     (all the static-global c's, sigh...)
X#	183: Previous declaration had prototype, this declaration does not(prototype declaration kept)
X#	     (ANSI *.pro vs K&R *.c)
X#	262: Previous declaration had prototype, this definition does not
X#	     (ditto)
X#	269: Evaluation gives an intermediate result type difference in ANSI versus K&R C;   int  versus   unsigned int
X#	     (all the unsigned staff vs char and int literals, ugh)
X#	302: bodyless for statement
X#	     (not bad at all, just suspicious)
X#	303: bodyless while statement
X#	     (not bad at all, just suspicious)
X#	309: Only int, signed int, unsigned int bit-fields defined in ANSI C. char, short, and long versions are allowed as an extension (ANSI C 3.5.2.1)
X#	     (one of IRIX' own header files is bad in this way...)
X#
Xfoo
Xelif test -n "$TITAN"
Xthen
Xcat <<'foo'
X#	--- TITAN notes
X#	Note 1: lots of (about 125) of "argument xxx is not used"
X#	Note 2: LOTS of (about 420) of "conversion of xxx (0xyy) loses precision
X#	Note 3: couple of (3) of "implied return [blah blah]"
X#		(caused by poor flow analysis, not by poor code)
X#
Xfoo
Xfi
X
Xecho '	...general rules' 1>&2
X
Xif test -n "$ccseparate"
Xthen
X  if test -n "$make_groks_VPATH"
X  then
X    for _b in $BSRC
X    do
Xcat <<foo
X$_b.o:	$_b.c
X	$ccit -c \$?
X
Xfoo
X    done
X  else
X    for _b in $BSRC
X    do
Xcat <<foo
X$_b.o:	$C_SRCDIR/$_b.c
X	$ccit -c \$?
X
Xfoo
X     done
X  fi
Xelse	# the simple case
Xcat <<foo
X.c.o:
X	$ccit $ccdotc
X
Xfoo
Xfi
X
Xif test -z "$make_groks_VPATH"
Xthen
X  for _proto in $PROTO
X  do
X    _c=`basename $_proto|sed 's/pro$/c/`
Xcat <<foo
X$_proto:
X	sed -n -f makepro.sed $_c > $_proto
X
Xfoo
X  done
Xelse
X
Xcat <<foo
X
X.c.pro:
X	sed -n -f makepro.sed ${C_SRCDIR}$< > \`basename ${C_BLDDIR}\$@\`
X
Xfoo
Xfi
X
Xcat <<foo
X\$(ZSHPATH): \$(OBJS)
X	\$(LD) \$(LDFLAGS) -o \$(ZSHPATH) \$(OBJS) \$(LIBS)
X	
X\$(PROTO): ${C_SRCDIR}makepro.sed
X
Xtags: /tmp
Xfoo
Xtest -z "$F_bld_eq_src" -a -n "$C_SRCDIR" && echo "	cd $C_SRCDIR"
Xcat <<foo
X	ctags *.[cy]
X
X# I hate this next line
X\$(OBJS): ${C_BLDDIR}config.h ${C_BLDDIR}signals.h ${C_SRCDIR}zsh.h ${C_SRCDIR}zle.h ${C_SRCDIR}ztype.h ${C_SRCDIR}funcs.h
X
X${C_BLDDIR}params.o: ${C_SRCDIR}version.h
X
X${C_SRCDIR}makepro.sed:
X	\$(CO) \$(COFLAGS) ${C_SRCDIR}makepro.sed
X
Xclean:
Xfoo
Xtest $C_SRCDIR && echo "	cd $C_SRCDIR"
Xcat <<'foo'
X	rm -f $(OBJS) $(ZSHPATH) core
X
Xspotless:	clean
Xfoo
Xtest -z "$F_bld_eq_src" -a -n "$C_SRCDIR" && echo "	cd $C_SRCDIR"
Xcat <<foo
X	rm -f \$(PROTO) Makefile ${C_BLDDIR}signals.h ${C_BLDDIR}config.h
X
Xinstall: ${C_BLDDIR}zsh
Xfoo
Xtest -z "$F_bld_eq_src" -a -n "$C_SRCDIR" && echo "	cd $C_SRCDIR"
Xcat <<foo
X	cp ${C_BLDDIR}zsh \$(BINDIR)
X	chmod 755 \$(BINDIR)/zsh
X	cp ${C_SRCDIR}../man/zsh.1 \$(MANDIR)
X	chmod 644 \$(MANDIR)/zsh.1
Xfoo
X)
Xfi
X
X###
END_OF_FILE
  if test 7495 -ne `wc -c <'zsh-2.5.0/src/config/bz.Makefile'`; then
    echo shar: \"'zsh-2.5.0/src/config/bz.Makefile'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/src/config/bz.Makefile'
fi
if test -f 'zsh-2.5.0/src/config/bz.help' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/src/config/bz.help'\"
else
  echo shar: Extracting \"'zsh-2.5.0/src/config/bz.help'\" \(7059 characters\)
  sed "s/^X//" >'zsh-2.5.0/src/config/bz.help' <<'END_OF_FILE'
Xcat <<EOH | $PAGER
XNAME
X
X	buildzsh -- zsh configuration tool
X
XSYNOPSIS
X
X	buildzsh [parameters]
X
X	buildzsh builds all or some of the files config.h, signals.h,
X	and Makefile.  These files are necessary for building zsh.
X	For more detailed explanation, see FILES below.
X
X	By default it builds them all, this can be done by simply saying
X
X		./buildzsh
X
X	from the shell level while in the same directory with buildzsh.
X	For not building all of the abovementioned files, see note 3)
X	under BOOLEAN PARAMETERS.
X
X	buildzsh supports building zsh for several architectures
X	from the same, untouched, source tree.  See MULTIARCHITECTURE
X	SUPPORT below.
X
XPARAMETERS
X
X	buildzsh knows about two kinds of parameters:
X
X	CONFIGURABLE and BOOLEAN
X
XCONFIGURABLE PARAMETERS
X
X	configurable might also be called assignable: they can be
X	assigned some value by using the form
X
X		param=value
X
X	For example
X
X		./buildzsh LIBS=-ltermcap
X
X	sets the configurable parameters "LIBS" to the value "-ltermcap"
X
X	param		explanation			default
X	-----		-----------			-------
X	CC		C compiler			$DEFAULT_C_CC
X	CFLAGS		C compiler flags    for example	$DEFAULT_C_CFLAGS
X	CFLAGS_D	C preprocessor flags (-Dfoo)	$DEFAULT_C_CFLAGS_D
X	CFLAGS_W	C warning flags	     (-ansi)	$DEFAULT_C_CFLAGS_W
X	CFLAGS_X	C extra flags        (-m486)	$DEFAULT_C_CFLAGS_X
X	CFLAGS_O	C optimizer flags    (-O)	$DEFAULT_C_CFLAGS_O
X	CFLAGS_g	C debugger flags     (-g)	$DEFAULT_C_CFLAGS_g
X	CFLAGS_z	zsh debugging flags  (-DQDEBUG)	$DEFAULT_C_CFLAGS_z
X	LDFLAGS		linking flags	     (-x)	\$(CFLAGS)
X	LIBS		libraries to link with	(-lnet)	$DEFAULT_C_LIBS
X	SRCDIR		source directory		$DEFAULT_C_SRCDIR
X	BLDDIR		building directory		$DEFAULT_C_BLDDIR
X	ARCH		architecture			(zsh HOSTTYPE)
X	ARCHPATT	ARCH pattern 2)			$DEFAULT_C_ARCHPATT
X	INSTDIR		installation directory 3)	$DEFAULT_C_INSTDIR
X	BINDIR		binary INSTDIR			$DEFAULT_C_BINDIR
X	MANDIR		manual page INSTDIR		$DEFAULT_C_MANDIR
X	ETCDIR		global init file directory	$DEFAULT_C_ETCDIR
X	MAKE		the "make" to use		$DEFAULT_C_MAKE
X
X	1) CFLAGS overrides all CFLAGS_... parameters, each CFLAGS_...
X	   overrides any guesses done by buildzsh.
X
X	2) For each instance of ARCHPATT in the parameters
X	   $ARCH_PARMS,
X	   ARCH will be substituted.
X
X	3) If INSTDIR is set, it will be a prefix for BINDIR (=INSTDIR/bin)
X	   and MANDIR (=INSTDIR/man/man1), BINDIR and MANDIR cannot then be
X	   set on their own.
X
XBOOLEAN PARAMETERS
X
X	These parameters are either present or not.
X
X	param		explanation			default
X	-----		-----------			-------
X	config.h	build config.h			$DEFAULT_B_config_h 1)
X	signals.h	build signals.h			$DEFAULT_B_signals_h 1)
X	hs		build config.h and signals.h	$DEFAULT_B_hs 1)
X	Makefile	build Makefile			$DEFAULT_B_mf 1)
X	mf		-"-				$DEFAULT_B_mf 1)
X	gcc		use gcc instead of default cc	$DEFAULT_B_gcc
X	mediumgcc	as "gcc" but with stricter	$DEFAULT_B_mediumgcc
X			flags, requires ANSI clean
X			zsh code _and_ system headers
X	strictgcc	as "gcc" but with very, VERY,	$DEFAULT_B_strictgcc
X			strict flags
X	ksh		run builzsh with ksh		$DEFAULT_B_ksh 2)
X			instead of default sh
X	help		show this help			$DEFAULT_B_help
X	query		ask configurer's judgement	$DEFAULT_B_query
X	auto		do not ask the initial question	$DEFAULT_B_auto 3)
X			about "query", start probing
X			immediately
X	noopt		no optimizing compilation (-O)	$DEFAULT_B_optimize 4)
X	debug		debugging compilation (-g)	$DEFAULT_B_debug 4)
X	zshdebug	zsh internal debugging used	$DEFAULT_B_zshdebug
X	nomake		no make at the end of buildzsh	$DEFAULT_B_nomake
X
X	For example
X
X		./buildzsh gcc
X
X	will customize Makefile so that gcc and the appropriate
X	flags will be used.
X
X	1) Normally all of config.h, signals.h, and Makefile
X	   will be built.  If, however, only certain of these are
X	   specified at the command line, only those specified will
X           be built.  For example "buildzsh mf" will build only the
X	   Makefile.
X
X	2) The default is to use sh.  ksh is needed sometimes if sh
X	   cannot for some reason handle buildzsh (e.g. Cray's UNICOS),
X	   in such cases buildzsh normally runs itself automatically
X	   with ksh and "ksh" option is not needed in the command line.
X
X	3) Meant either for the extremely optimistic first-timers or
X	   for the battle-scarred zsh hackers.
X	
X	4) These can cancel each other out: if both are present
X	   but the C compiler cannot handle both of them, optimization
X	   is turned off and debugging stays.  Only certain compilation
X	   environments support optimization and debugging simultaneously.
X
XMULTIARCHITECTURE SUPPORT
X
X	*** CURRENTLY UNSUPPORTED (=SOMEWHAT BROKEN) FEATURE	***
X	*** FOR DESPERATE USE ONLY				***
X	*** IF IT WORKS FOR YOU, FINE, BUT DON'T RELY ON IT.	***
X	*** IF IT DOESN'T WORK FOR YOU, TOUGH.			***
X	*** IF YOU DO THE BUILDING HONOURING THE TRADITION      ***
X	*** COMPILING AMONG THE SOURCES, EVERYTHING SHOULD GO	***
X	*** JUST FINE, IGNORE THIS FEATURE.			***
X
X	buildzsh understands using a common source code pool
X	for building and installing zsh for several different
X	architectures.   The configurable parameters
X
X		$ARCH_PARMS
X
X	are special: if these contain the pattern
X
X		$DEFAULT_C_ARCHPATT
X
X	this pattern will be replaced with a string describing
X	the particular architecture.  By default this string is
X	determined by buildzsh itself -- but all of these can be
X	changed from the command line, see CONFIGURABLE PARAMETERS above.
X	For example
X
X		./buildzsh BLDDIR=/var/tmp/zsh/hp48sx
X
X	will build Makefile so that by simply saying
X
X		make -f /var/tmp/zsh/hp48sx/Makefile
X
X	the whole zsh building process will happen in the directory
X	"/var/tmp/zsh/hp48sx".
X
XFILES
X
X	buildzsh builds three files:
X
X		config.h and signals.h are normal C source files:
X		config.h contains the definitions that depend on
X		the particular features of the operating system variant,
X		signals.h contains the signal definitions.
X
X		A makefile called Makefile customized for
X		the particular architecture will be built to
X		the building directory (by default the building directory
X		is the current directory).
X
X	There are fail-safe versions of config.h, signals.h and Makefile
X	called config.h.sample, signals.h.sample and Makefile.sample
X	that can be used either as-is or as raw material if buildzsh fails.
X
X	buildzsh itself is just a top-level script that uses the bz.*
X	scripts in the directory src/config.
X
XENVIRONMENT VARIABLES
X
X	All of the configurable parameters (see above) (for example
X	CFLAGS and LIBS) are taken intact from the environment.
X
XBUGS
X
X	Nothing is perfect and buildzsh is bound to have its
X	share of bugs.  If and when modifying buildzsh becomes
X	a necessity, please read the file src/config/config.README.
X	It lists the role of each module of buildzsh and warns about
X	the most common pitfalls.
X
XWARNINGS
X
X	buildzsh is quite large piece of serious shell scripting
X	which is supposed to work under any Bourne shell (sh) AND
X	Korn shell (ksh).  Achieving this goal requires sometimes
X	dirty and/or obscure tricks to for example negotiate past
X	some bugs that appear only in some vendors' environments.
X
X	Fiddling with buildzsh is not for the faint at heart.
XEOH
Xexit 1	
END_OF_FILE
  if test 7059 -ne `wc -c <'zsh-2.5.0/src/config/bz.help'`; then
    echo shar: \"'zsh-2.5.0/src/config/bz.help'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/src/config/bz.help'
fi
if test -f 'zsh-2.5.0/src/config/config.README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/src/config/config.README'\"
else
  echo shar: Extracting \"'zsh-2.5.0/src/config/config.README'\" \(6655 characters\)
  sed "s/^X//" >'zsh-2.5.0/src/config/config.README' <<'END_OF_FILE'
XPURPOSE
X
X	This directory contains shell scripts that are used by
X	src/buildzsh.
X
XFILES
X
X	Hierarchical list	Function of
X	of scripts called by	the particular
X	buildzsh.		script.
X	--------------------	--------------
X
X	bz.init			Initialization...
X		bz.saveargv		saving argv
X		bz.defaults		for parameters
X		bz.ifksh		for ksh-must
X	bz.argh			Argument handling...
X		bz.help			showing help
X	bz.check		Argument checking...
X		bz.doksh		do ksh if necessary
X		bz.sanity		fix up some parameters
X	bz.hs			Header building...
X		bz.config.h		config.h
X		bz.signals.h		signals.h
X	bz.Makefile		Architecture-specific Makefile building...
X	bz.finale		Shall we $MAKE?
X	
XNOTES
X
X	The following notes are meant for buildzsh hackers,
X	for others it will be a healthy example about the
X	problems of writing large and portable shell scripts.
X
X	The notes are indicated by a '*' in the left margin and
X	they are are followed by (some of) the names of the bz.* files
X	that are affected by the particular note.
X
X* all the sh-constructs must be also "Korn-compliant"
X  so that ksh also can munch this script.  This is normally not
X  a big headache because ksh should be superset of Bourne sh.
X
X  some miserable Bourne shells fail for some reason or another
X  while executing buildzsh, we will try for those wrecthes whether
X  ksh comes to rescue.
X
X	bz.ifksh
X	bz.doksh
X	bz.Makefiles
X
X* because the Makefiles are built by <<eof method *inside* buildzsh,
X  they have to be BOTH "Bourne-compliant" AND "Korn-compliant".
X  Therefore, certain measures have to be taken as certain
X  constructs are understood differently amongst sh/ksh/make.
X  These constructs are
X        
X        $@              (sh and make)
X        $(foo)          (ksh and make)
X
X  If these constructs are to be as "make" them understands, they MUST
X  be escaped with a leading backlash as follows
X
X        \$@
X        \$(foo)
X
X  All the "here-document" (<<EOF) situations cannot be handled with
X  <<'quoted-eof' trick, which would cure both the above problems,
X  because the expansion of $bar by sh/ksh is extensively used by
X  for example
X
X        CC=$CC
X
X  where $CC has been resolved by sh/ksh.  Note, however, that when
X  no $bar style expansions are needed during <<, the <<'quoted-eof'
X  method is viable and the \ escaping is not needed.
X
X	bz.Makefiles
X
X* do NOT even think about using the <<trick as
X
X  if test ...
X  then
X  exec >somefile
X  cat <<eof
X  ...
X  eof
X  fi
X  
X  thanks to Sun.  In ScumOS, you will get error messages like
X  buildzsh: /tmp/sh1708429: No such file or directory
X  after each 'cat' for each exec-cat pair.
X  One must resort to the work-around: using subshells
X
X  if test ...
X  then
X  (exec >somefile
X  cat >>eof
X  ...
X  eof
X  )
X  fi
X  
X  Note that one must be careful about the closing (: it can come
X  many lines after the initial cat <<'s eof, in buildzsh normally
X  just before the 'fi' that closes down the building of some file
X
X  if test ...doing-some-file
X  then
X  (exec >some-file
X  ...
X  )
X  fi
X
X	bz.Makefile
X	bz.config.h
X
X* do not use "test -x" because some braindead (but wide-spread)
X  tests do not know such a flag, use "-f" instead, that *should* work
X  everywhere.
X
X	bz.Makefile
X	bz.config.h
X	bz.doksh
X	bz.help
X	bz.hosttype
X
X* do not use "tr -s", either, use sed for that.
X
X* the argument list of the buildzsh is saved by bz.init/bz.saveargv
X  in to a variable called _argv that can be used in constructs like
X
X  for i in $_argv
X  do
X    ...
X
X  Whitespace is correctly saved in _argv.
X  (but exotic quoting might get fatal?)
X
X* there are a couple of subroutinish scripts that are used to automatize
X  the chores of asking/looking for different kinds of questions.
X
X  The calling sequence is as follows
X
X	set arg1 arg2 arg3 arg4 ...
X	. bz.foo
X  
X  Worrying about $@?  Saved in $_argv, see above.
X
X  bz.define:
X
X	Usage:
X
X	set symbol_name default_value description [ empty_ok [ quote_it ] ]
X	. bz.define
X
X	Used to #define FOO, the definition is output to stdout.
X
X	If empty answer is ok, the 4th argument should be non-empty.
X	
X	If the 5th argument is either " or ', the whole answer is
X	quoted with that particular character (on both sides, of course).
X
X  bz.ifdef:
X
X	Usage:
X
X	set test symbol_name default_value yea_feature \
X            [ nay_feature [ feature_name ] ]
X
X	Used to #define but only iff some condition holdsds,
X	the definition is output to stdout.
X
X	In query mode the question is normally paraphrased as
X	"Do you have YEA_FEATURE?".  These can be (and are)
X	customized: Do is G_verb1_, you is G_subj_, have is G_verb2_.
X	See for example the "suspended"/"stopped" question in
X	bz.config.h, there the "have" is changed into "prefer".
X
X	This is the subroutine that says "using foo..." or
X	"not using foo...".  Also the "using" can be customized,
X	it is G_verb3a_ and G_verb3b_, corresponding to the positive
X	and negative senses.
X
X	All the G_{verb,subject}X customizations are temporary:
X	each bz.ifdef call resets the defaults.
X
X	You can test the variables _yea and _nay after the
X	bz.ifdef call to know which alternative was chosen.
X
X  bz.walk:
X
X	set variable_name "file ..." "dir ..." default
X	. bz.walk
X
X  	Searches PATH-like for multiple files from multiple directories.
X  	The first existing dir/file is set as the value of variable_name.
X  	If no such exists, the default is used as the value.
X  	The outer loop steps through files and the inner through directories.
X  	For example:
X
X	set gorp "cc gcc" "/usr/local/bin /usr/bin /bin" /bin/echo
X	. bz.walk
X
X  	This will try /usr/local/bin/cc, /usr/bin/cc, /bin/cc,
X	/usr/local/bin/gcc, /usr/bin/gcc, and /bin/gcc, in that order.
X	If none of these exist, gorp will have the value /bin/echo.
X
X* As soon as you know for certain whether your C compiler groks -c and -o
X  simultaneously or not, add the correct variable to test to
X  either CC_GROK_c_o or CC_LOSE_c_o in bz.defaults, respectively.
X  Neither matching means running $CC *each and every* time buildzsh is run.
X
X	bz.Makefile
X	bz.defaults
X
X* As soon as you know for certain whether your C compiler groks -g and -O
X  simultaneously or not, add the correct variable to test to
X  either CC_GROK_g_O or CC_LOSE_g_O in bz.defaults, respectively.
X  Neither matching means running $CC *each and every* time buildzsh is run.
X  Variables like test:foo:bar mean testing for variable "test",
X  if that succeeds, setting CC_gFLAGS to "foo" and CC_OFLAGS to "bar".
X
X	For example: CC_GROK_g_O="AIX CC_MIPS_STYLE:-g3:-O GCC:-g:-O6"
X
X  Use 'quotes' to protect whitespace.
X
X	bz.Makefile
X	bz.defaults
X
X* if you want to display something to "stdin" while building
X  Makefile, you must "1>&2" it
X
X	bz.Makefile
X
X* the naming of the various sh variables is a total mess.
X
X---
END_OF_FILE
  if test 6655 -ne `wc -c <'zsh-2.5.0/src/config/config.README'`; then
    echo shar: \"'zsh-2.5.0/src/config/config.README'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/src/config/config.README'
fi
if test -f 'zsh-2.5.0/src/table.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/src/table.c'\"
else
  echo shar: Extracting \"'zsh-2.5.0/src/table.c'\" \(7518 characters\)
  sed "s/^X//" >'zsh-2.5.0/src/table.c' <<'END_OF_FILE'
X/*
X *
X * table.c - linked lists and hash tables
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made.
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk.
X *
X */
X
X#define TABLE_C
X#include "zsh.h"
X
X/* get an empty linked list header */
X
XLklist newlist()
X{				/**/
X    Lklist list;
X
X    list = (Lklist) alloc(sizeof *list);
X    list->first = 0;
X    list->last = (Lknode) list;
X    return list;
X}
X
X/* get an empty hash table */
X
XHashtab newhtable(size)		/**/
Xint size;
X{
X    Hashtab ret;
X
X    ret = (Hashtab) zcalloc(sizeof *ret);
X    ret->hsize = size;
X    ret->nodes = (Hashnode *) zcalloc(size * sizeof(Hashnode));
X    return ret;
X}
X
X/* the hash function used by Chris Torek */
X/* The Peter J. Weinberger hash function from the Dragon Book
X * used to be here but it
X * a) was slower than this
X * b) took 32-bit integers for granted
X *    b1) there are other integer widths
X *    b2) integer constant like 0xf0000000 is unsigned in ANSI C,
X *        signed with pcc
X * c) I _believe_ after some testing that this hashes better
X *    Jarkko Hietaniemi <Jarkko.Hietaniemi@hut.fi>
X */
X
Xunsigned hasher(s)		/**/
Xchar *s;
X{
X    unsigned hash;
X
X    for (hash = 0; *s; s++)
X	hash = hash + (hash << 5) + *s;
X /* if hashing counted strings: (size_t, char *) pairs,
X     * "+ 1" should be appended to the above line */
X
X    return hash;
X}
X
X/* add a node to a hash table */
X
Xvoid addhnode(nam, dat, ht, freefunc)	/**/
Xchar *nam;
Xvptr dat;
XHashtab ht;
XFFunc freefunc;
X{
X    int hval = hasher(nam) % ht->hsize;
X    struct hashnode **hp = ht->nodes + hval, *hn;
X
X    for (; *hp; hp = &(*hp)->next)
X	if (!strcmp((*hp)->nam, nam)) {
X	    zsfree((*hp)->nam);
X	    hn = (struct hashnode *)dat;
X	    hn->next = (*hp)->next;
X	    if (!freefunc)
X		zerr("attempt to call NULL freefunc", NULL, 0);
X	    else
X		freefunc(*hp);
X	    *hp = hn;
X	    hn->nam = nam;
X	    return;
X	}
X    hn = (Hashnode) dat;
X    hn->nam = nam;
X    hn->next = ht->nodes[hval];
X    ht->nodes[hval] = hn;
X    if (++ht->ct == ht->hsize * 4)
X	expandhtab(ht);
X}
X
X/* add a node to command hash table */
X
Xvoid addhcmdnode(nam, pnam)	/**/
Xchar *nam;
Xchar **pnam;
X{
X    int hval = hasher(nam) % cmdnamtab->hsize;
X    struct hashnode *hp = cmdnamtab->nodes[hval], *hn;
X    Cmdnam cc;
X
X    for (; hp; hp = hp->next)
X	if (!strcmp(hp->nam, nam))
X	    return;
X    cc = (Cmdnam) zcalloc(sizeof *cc);
X    cc->flags = EXCMD;
X    cc->u.name = pnam;
X    hn = (Hashnode) cc;
X    hn->nam = ztrdup(nam);
X    hn->next = cmdnamtab->nodes[hval];
X    cmdnamtab->nodes[hval] = hn;
X    if (++cmdnamtab->ct == cmdnamtab->hsize * 4)
X	expandhtab(cmdnamtab);
X}
X
X/* expand hash tables when they get too many entries */
X
Xvoid expandhtab(ht)		/**/
XHashtab ht;
X{
X    struct hashnode **arr, **ha, *hn, *hp;
X    int osize = ht->hsize, nsize = osize * 8, os = osize;
X
X    ht->hsize = nsize;
X    arr = ht->nodes;
X    ht->nodes = (Hashnode *) zcalloc(nsize * sizeof(struct hashnode *));
X
X    ht->ct = 0;
X
X    for (ha = arr; osize; osize--, ha++)
X	for (hn = *ha; hn;) {
X	    hp = hn->next;
X	    addhnode(hn->nam, (vptr) hn, ht, (FFunc) 0);
X	    hn = hp;
X	}
X    zfree(arr, os * sizeof(struct hashnode *));
X}
X
X/* get an entry in a hash table */
X
Xvptr gethnode(nam, ht)		/**/
Xchar *nam;
XHashtab ht;
X{
X    int hval = hasher(nam) % ht->hsize;
X    struct hashnode *hn = ht->nodes[hval];
X
X    for (; hn; hn = hn->next)
X	if (!strcmp(hn->nam, nam))
X	    return (vptr) hn;
X    return NULL;
X}
X
Xvoid freehtab(ht, freefunc)	/**/
XHashtab ht;
XFFunc freefunc;
X{
X    int val;
X    struct hashnode *hn, **hp = &ht->nodes[0], *next;
X
X    for (val = ht->hsize; val; val--, hp++)
X	for (hn = *hp; hn;) {
X	    next = hn->next;
X	    zsfree(hn->nam);
X	    freefunc(hn);
X	    hn = next;
X	}
X    zfree(ht->nodes, ht->hsize * sizeof(struct hashnode *));
X    zfree(ht, sizeof(struct hashtab));
X}
X
X/* remove a hash table entry and return a pointer to it */
X
Xvptr remhnode(nam, ht)		/**/
Xchar *nam;
XHashtab ht;
X{
X    int hval = hasher(nam) % ht->hsize;
X    struct hashnode *hn = ht->nodes[hval], *hp;
X
X    if (!hn)
X	return NULL;
X    if (!strcmp(hn->nam, nam)) {
X	ht->nodes[hval] = hn->next;
X	zsfree(hn->nam);
X	ht->ct--;
X	return (vptr) hn;
X    }
X    for (hp = hn, hn = hn->next; hn; hn = (hp = hn)->next)
X	if (!strcmp(hn->nam, nam)) {
X	    hp->next = hn->next;
X	    zsfree(hn->nam);
X	    ht->ct--;
X	    return (vptr) hn;
X	}
X    return NULL;
X}
X
X/* insert a node in a linked list after 'llast' */
X
Xvoid insnode(list, llast, dat)	/**/
XLklist list;
XLknode llast;
Xvptr dat;
X{
X    Lknode tmp;
X
X    tmp = llast->next;
X    llast->next = (Lknode) alloc(sizeof *tmp);
X    llast->next->last = llast;
X    llast->next->dat = dat;
X    llast->next->next = tmp;
X    if (tmp)
X	tmp->last = llast->next;
X    else
X	list->last = llast->next;
X}
X
X/* remove a node from a linked list */
X
Xvptr remnode(list, nd)		/**/
XLklist list;
XLknode nd;
X{
X    vptr dat;
X
X    nd->last->next = nd->next;
X    if (nd->next)
X	nd->next->last = nd->last;
X    else
X	list->last = nd->last;
X    dat = nd->dat;
X    zfree(nd, sizeof(struct lknode));
X
X    return dat;
X}
X
X/* remove a node from a linked list */
X
Xvptr uremnode(list, nd)		/**/
XLklist list;
XLknode nd;
X{
X    vptr dat;
X
X    nd->last->next = nd->next;
X    if (nd->next)
X	nd->next->last = nd->last;
X    else
X	list->last = nd->last;
X    dat = nd->dat;
X    return dat;
X}
X
X/* delete a character in a string */
X
Xvoid chuck(str)			/**/
Xchar *str;
X{
X    while ((str[0] = str[1]))
X	str++;
X}
X
X/* get top node in a linked list */
X
Xvptr getnode(list)		/**/
XLklist list;
X{
X    vptr dat;
X    Lknode node = list->first;
X
X    if (!node)
X	return NULL;
X    dat = node->dat;
X    list->first = node->next;
X    if (node->next)
X	node->next->last = (Lknode) list;
X    else
X	list->last = (Lknode) list;
X    zfree(node, sizeof(struct lknode));
X
X    return dat;
X}
X
X/* get top node in a linked list without freeing */
X
Xvptr ugetnode(list)		/**/
XLklist list;
X{
X    vptr dat;
X    Lknode node = list->first;
X
X    if (!node)
X	return NULL;
X    dat = node->dat;
X    list->first = node->next;
X    if (node->next)
X	node->next->last = (Lknode) list;
X    else
X	list->last = (Lknode) list;
X    return dat;
X}
X
Xvoid freetable(tab, freefunc)	/**/
XLklist tab;
XFFunc freefunc;
X{
X    Lknode node = tab->first, next;
X
X    while (node) {
X	next = node->next;
X	if (freefunc)
X	    freefunc(node->dat);
X	zfree(node, sizeof(struct lknode));
X
X	node = next;
X    }
X    zfree(tab, sizeof(struct lklist));
X}
X
Xchar *ztrstr(s, t)		/**/
Xchar *s;
Xchar *t;
X{
X    char *p1, *p2;
X
X    for (; *s; s++) {
X	for (p1 = s, p2 = t; *p2; p1++, p2++)
X	    if (*p1 != *p2)
X		break;
X	if (!*p2)
X	    return (char *)s;
X    }
X    return NULL;
X}
X
X/* insert a list in another list */
X
Xvoid inslist(l, where, x)	/**/
XLklist l;
XLknode where;
XLklist x;
X{
X    Lknode nx = where->next;
X
X    if (!l->first)
X	return;
X    where->next = l->first;
X    l->last->next = nx;
X    l->first->last = where;
X    if (nx)
X	nx->last = l->last;
X    else
X	x->last = l->last;
X}
X
Xint countnodes(x)		/**/
XLklist x;
X{
X    Lknode y;
X    int ct = 0;
X
X    for (y = firstnode(x); y; incnode(y), ct++);
X    return ct;
X}
END_OF_FILE
  if test 7518 -ne `wc -c <'zsh-2.5.0/src/table.c'`; then
    echo shar: \"'zsh-2.5.0/src/table.c'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/src/table.c'
fi
if test -f 'zsh-2.5.0/src/text.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/src/text.c'\"
else
  echo shar: Extracting \"'zsh-2.5.0/src/text.c'\" \(8918 characters\)
  sed "s/^X//" >'zsh-2.5.0/src/text.c' <<'END_OF_FILE'
X
X/*
X *
X * text.c - textual representations of syntax trees
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made.
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk.
X *
X */
X
X#include "zsh.h"
X
Xstatic char *tptr, *tbuf, *tlim;
Xstatic int tsiz, tindent, tnewlins;
X
X/* add a character to the text buffer */
X
Xvoid taddchr(c)			/**/
Xint c;
X{
X    *tptr++ = c;
X    if (tptr == tlim) {
X	if (!tbuf) {
X	    tptr--;
X	    return;
X	}
X	tbuf = realloc(tbuf, tsiz *= 2);
X	tlim = tbuf + tsiz;
X	tptr = tbuf + tsiz / 2;
X    }
X}
X
X/* add a string to the text buffer */
X
Xvoid taddstr(s)			/**/
Xchar *s;
X{
X    int sl = strlen(s);
X
X    while (tptr + sl >= tlim) {
X	int x = tptr - tbuf;
X
X	if (!tbuf)
X	    return;
X	tbuf = realloc(tbuf, tsiz *= 2);
X	tlim = tbuf + tsiz;
X	tptr = tbuf + x;
X    }
X    strcpy(tptr, s);
X    tptr += sl;
X}
X
X/* add an integer to the text buffer */
X
Xvoid taddint(x)			/**/
Xint x;
X{
X    char buf[10];
X
X    sprintf(buf, "%d", x);
X    taddstr(buf);
X}
X
X/* add a newline, or something equivalent, to the text buffer */
X
Xvoid taddnl()
X{				/**/
X    int t0;
X
X    if (tnewlins) {
X	taddchr('\n');
X	for (t0 = 0; t0 != tindent; t0++)
X	    taddchr('\t');
X    } else
X	taddstr("; ");
X}
X
X/* get a permanent textual representation of n */
X
Xchar *getpermtext(n)		/**/
Xstruct node *n;
X{
X    tnewlins = 1;
X    tbuf = (char *)zalloc(tsiz = 32);
X    tptr = tbuf;
X    tlim = tbuf + tsiz;
X    tindent = 1;
X    gettext2(n);
X    *tptr = '\0';
X    untokenize(tbuf);
X    return tbuf;
X}
X
X/* get a representation of n in a job text buffer */
X
Xchar *getjobtext(n)		/**/
Xstruct node *n;
X{
X    static char jbuf[JOBTEXTSIZE];
X
X    tnewlins = 0;
X    tbuf = NULL;
X    tptr = jbuf;
X    tlim = tptr + JOBTEXTSIZE - 1;
X    tindent = 1;
X    gettext2(n);
X    *tptr = '\0';
X    untokenize(jbuf);
X    return jbuf;
X}
X
X#define gt2(X) gettext2((struct node *) (X))
X
X/*
X	"gettext2" or "type checking and how to avoid it"
X	an epic function by Paul Falstad
X*/
X
X#define _Cond(X) ((Cond) (X))
X#define _Cmd(X) ((Cmd) (X))
X#define _Pline(X) ((Pline) (X))
X#define _Sublist(X) ((Sublist) (X))
X#define _List(X) ((List) (X))
X#define _casecmd(X) ((struct casecmd *) (X))
X#define _ifcmd(X) ((struct ifcmd *) (X))
X#define _whilecmd(X) ((struct whilecmd *) (X))
X
Xvoid gettext2(n)		/**/
Xstruct node *n;
X{
X    Cmd nn;
X    Cond nm;
X
X    if (!n || ((List) n) == &dummy_list)
X	return;
X    switch (NT_TYPE(n->type)) {
X    case N_LIST:
X	gt2(_List(n)->left);
X	if (_List(n)->type == ASYNC)
X	    taddstr(" &");
X	simplifyright(_List(n));
X	if (_List(n)->right) {
X	    if (tnewlins)
X		taddnl();
X	    else
X		taddstr((_List(n)->type == ASYNC) ? " " : "; ");
X	    gt2(_List(n)->right);
X	}
X	break;
X    case N_SUBLIST:
X	if (_Sublist(n)->flags & PFLAG_NOT)
X	    taddstr("! ");
X	if (_Sublist(n)->flags & PFLAG_COPROC)
X	    taddstr("coproc ");
X	gt2(_Sublist(n)->left);
X	if (_Sublist(n)->right) {
X	    taddstr((_Sublist(n)->type == ORNEXT) ? " || " : " && ");
X	    gt2(_Sublist(n)->right);
X	}
X	break;
X    case N_PLINE:
X	gt2(_Pline(n)->left);
X	if (_Pline(n)->type == PIPE) {
X	    taddstr(" | ");
X	    gt2(_Pline(n)->right);
X	}
X	break;
X    case N_CMD:
X	nn = _Cmd(n);
X	if (nn->flags & CFLAG_EXEC)
X	    taddstr("exec ");
X	if (nn->flags & CFLAG_COMMAND)
X	    taddstr("command ");
X	switch (nn->type) {
X	case SIMPLE:
X	    getsimptext(nn);
X	    break;
X	case SUBSH:
X	    taddstr("( ");
X	    tindent++;
X	    gt2(nn->u.list);
X	    tindent--;
X	    taddstr(" )");
X	    break;
X	case ZCTIME:
X	    taddstr("time ");
X	    tindent++;
X	    gt2(nn->u.pline);
X	    tindent--;
X	    break;
X	case FUNCDEF:
X	    taddlist(nn->args);
X	    taddstr(" () {");
X	    tindent++;
X	    taddnl();
X	    gt2(nn->u.list);
X	    tindent--;
X	    taddnl();
X	    taddstr("}");
X	    break;
X	case CURSH:
X	    taddstr("{ ");
X	    tindent++;
X	    gt2(nn->u.list);
X	    tindent--;
X	    taddstr(" }");
X	    break;
X	case CFOR:
X	case CSELECT:
X	    taddstr((nn->type == CFOR) ? "for " : "select ");
X	    taddstr(nn->u.forcmd->name);
X	    if (nn->u.forcmd->inflag) {
X		taddstr(" in ");
X		taddlist(nn->args);
X	    }
X	    taddnl();
X	    taddstr("do");
X	    tindent++;
X	    taddnl();
X	    gt2(nn->u.forcmd->list);
X	    tindent--;
X	    taddnl();
X	    taddstr("done");
X	    break;
X	case CIF:
X	    gt2(nn->u.ifcmd);
X	    taddstr("fi");
X	    break;
X	case CCASE:
X	    taddstr("case ");
X	    taddlist(nn->args);
X	    taddstr(" in");
X	    tindent++;
X	    taddnl();
X	    gt2(nn->u.casecmd);
X	    tindent--;
X	    if (tnewlins)
X		taddnl();
X	    else
X		taddchr(' ');
X	    taddstr("esac");
X	    break;
X	case COND:
X	    taddstr("[[ ");
X	    gt2(nn->u.cond);
X	    taddstr(" ]]");
X	    break;
X	case CREPEAT:
X	    taddstr("repeat ");
X	    taddlist(nn->args);
X	    taddnl();
X	    taddstr("do");
X	    tindent++;
X	    taddnl();
X	    gt2(nn->u.list);
X	    tindent--;
X	    taddnl();
X	    taddstr("done");
X	    break;
X	case CWHILE:
X	    gt2(nn->u.whilecmd);
X	    break;
X	}
X	getredirs(nn);
X	break;
X    case N_COND:
X	nm = _Cond(n);
X	switch (nm->type) {
X	case COND_NOT:
X	    taddstr("! ");
X	    gt2(nm->left);
X	    break;
X	case COND_AND:
X	    taddstr("( ");
X	    gt2(nm->left);
X	    taddstr(" && ");
X	    gt2(nm->right);
X	    taddstr(" )");
X	    break;
X	case COND_OR:
X	    taddstr("( ");
X	    gt2(nm->left);
X	    taddstr(" || ");
X	    gt2(nm->right);
X	    taddstr(" )");
X	    break;
X	default:
X	    {
X		static char *c1[] =
X		{
X		    " = ", " != ", " < ", " > ", " -nt ", " -ot ", " -ef ", " -eq ",
X		    " -ne ", " -lt ", " -gt ", " -le ", " -ge "
X		};
X
X		if (nm->right)
X		    taddstr(nm->left);
X		if (nm->type <= COND_GE)
X		    taddstr(c1[nm->type - COND_STREQ]);
X		else {
X		    char c2[5];
X
X		    c2[0] = ' ';
X		    c2[1] = '-';
X		    c2[2] = nm->type;
X		    c2[3] = ' ';
X		    c2[4] = '\0';
X		    taddstr(c2);
X		}
X		taddstr((nm->right) ? nm->right : nm->left);
X	    }
X	    break;
X	}
X	break;
X    case N_CASE:
X	{
X	    List *l;
X	    char **p;
X
X	    l = _casecmd(n)->lists;
X	    p = _casecmd(n)->pats;
X
X	    for (; *l; p++, l++) {
X		taddstr(*p);
X		taddstr(") ");
X		tindent++;
X		gt2(*l);
X		tindent--;
X		taddstr(";;");
X		if (tnewlins)
X		    taddnl();
X		else
X		    taddchr(' ');
X	    }
X	    break;
X	}
X    case N_IF:
X	{
X	    List *i, *t;
X
X	    taddstr("if ");
X	    for (i = _ifcmd(n)->ifls, t = _ifcmd(n)->thenls; *i; i++, t++) {
X		tindent++;
X		gt2(*i);
X		tindent--;
X		taddnl();
X		taddstr("then");
X		tindent++;
X		taddnl();
X		gt2(*t);
X		tindent--;
X		taddnl();
X		if (i[1]) {
X		    taddstr("elif ");
X		}
X	    }
X	    if (*t) {
X		taddstr("else");
X		tindent++;
X		taddnl();
X		gt2(*t);
X		tindent--;
X		taddnl();
X	    }
X	    break;
X	}
X    case N_WHILE:
X	taddstr((_whilecmd(n)->cond) ? "until " : "while ");
X	tindent++;
X	gt2(_whilecmd(n)->cont);
X	tindent--;
X	taddnl();
X	taddstr("do");
X	tindent++;
X	taddnl();
X	gt2(_whilecmd(n)->loop);
X	tindent--;
X	taddnl();
X	taddstr("done");
X	break;
X    }
X}
X
Xvoid getsimptext(cmd)		/**/
XCmd cmd;
X{
X    Lknode n;
X
X    for (n = firstnode(cmd->vars); n; incnode(n)) {
X	struct varasg *v = (struct varasg *)getdata(n);
X
X	taddstr(v->name);
X	taddchr('=');
X	if ((v->type & PMTYPE) == PMFLAG_A) {
X	    taddchr('(');
X	    taddlist(v->arr);
X	    taddstr(") ");
X	} else {
X	    taddstr(v->str);
X	    taddchr(' ');
X	}
X    }
X    taddlist(cmd->args);
X}
X
Xvoid getredirs(cmd)		/**/
XCmd cmd;
X{
X    Lknode n;
X    static char *fstr[] =
X    {
X	">", ">!", ">>", ">>!", ">&", ">&!", ">>&", ">>&!", "<", "<<",
X	"<<-", "<<<", "<&", ">&-", "..", ".."
X    };
X
X    taddchr(' ');
X    for (n = firstnode(cmd->redir); n; incnode(n)) {
X	struct redir *f = (struct redir *)getdata(n);
X
X	switch (f->type) {
X	case WRITE:
X	case WRITENOW:
X	case APP:
X	case APPNOW:
X	case READ:
X	case HERESTR:
X	    if (f->fd1 != ((f->type == READ) ? 0 : 1))
X		taddchr('0' + f->fd1);
X	    taddstr(fstr[f->type]);
X	    taddchr(' ');
X	    taddstr(f->name);
X	    taddchr(' ');
X	    break;
X	case MERGE:
X	case MERGEOUT:
X	    if (f->fd1 != ((f->type == MERGEOUT) ? 1 : 0))
X		taddchr('0' + f->fd1);
X	    taddstr(fstr[f->type]);
X	    if (f->fd2 == FD_COPROC)
X		taddchr('p');
X	    else
X		taddint(f->fd2);
X	    taddchr(' ');
X	    break;
X	case CLOSE:
X	    taddchr(f->fd1 + '0');
X	    taddstr(">&- ");
X	    break;
X	case INPIPE:
X	case OUTPIPE:
X	    if (f->fd1 != ((f->type == INPIPE) ? 0 : 1))
X		taddchr('0' + f->fd1);
X	    taddstr((f->type == INPIPE) ? "< " : "> ");
X	    taddstr(f->name);
X	    taddchr(' ');
X	    break;
X	}
X    }
X    tptr--;
X}
X
Xvoid taddlist(l)		/**/
XLklist l;
X{
X    Lknode n;
X
X    if (!(n = firstnode(l)))
X	return;
X    for (; n; incnode(n)) {
X	taddstr(getdata(n));
X	taddchr(' ');
X    }
X    tptr--;
X}
END_OF_FILE
  if test 8918 -ne `wc -c <'zsh-2.5.0/src/text.c'`; then
    echo shar: \"'zsh-2.5.0/src/text.c'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/src/text.c'
fi
if test -f 'zsh-2.5.0/src/watch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/src/watch.c'\"
else
  echo shar: Extracting \"'zsh-2.5.0/src/watch.c'\" \(8877 characters\)
  sed "s/^X//" >'zsh-2.5.0/src/watch.c' <<'END_OF_FILE'
X
X/*
X *
X * watch.c - login/logout watching
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made.
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk.
X *
X */
X
X#include "zsh.h"
X
Xstatic int wtabsz;
Xstruct utmp *wtab;
Xstatic time_t lastutmpcheck;
X
X/* get the time of login/logout for WATCH */
X
Xtime_t getlogtime(u, inout)	/**/
Xstruct utmp *u;
Xint inout;
X{
X    FILE *in;
X    struct utmp uu;
X    int first = 1;
X    int srchlimit = 50;		/* max number of wtmp records to search */
X
X    if (inout)
X	return u->ut_time;
X    if (!(in = fopen(WTMP_FILE, "r")))
X	return time(NULL);
X    fseek(in, 0, 2);
X    do {
X	if (fseek(in, ((first) ? -1 : -2) * sizeof(struct utmp), 1)) {
X	    fclose(in);
X	    return time(NULL);
X	}
X	first = 0;
X	if (!fread(&uu, sizeof(struct utmp), 1, in)) {
X	    fclose(in);
X	    return time(NULL);
X	}
X	if (uu.ut_time < lastwatch || !srchlimit--) {
X	    fclose(in);
X	    return time(NULL);
X	}
X    }
X    while (memcmp(&uu, u, sizeof(uu)));
X
X    do
X	if (!fread(&uu, sizeof(struct utmp), 1, in)) {
X	    fclose(in);
X	    return time(NULL);
X	}
X    while (strncmp(uu.ut_line, u->ut_line, sizeof(u->ut_line)));
X    fclose(in);
X    return uu.ut_time;
X}
X
X/* Mutually recursive call to handle ternaries in watchfmt */
X
X#define BEGIN3	'('
X#define END3	')'
X
Xchar *watch3ary(inout, u, fmt, prnt)	/**/
Xint inout;
Xstruct utmp *u;
Xchar *fmt;
Xint prnt;
X{
X    int truth = 1, sep;
X
X    switch (*fmt++) {
X    case 'n':
X	truth = (u->ut_name[0] != 0);
X	break;
X    case 'a':
X	truth = inout;
X	break;
X    case 'l':
X	if (!strncmp(u->ut_line, "tty", 3))
X	    truth = (u->ut_line[3] != 0);
X	else
X	    truth = (u->ut_line[0] != 0);
X	break;
X#ifdef UTMP_HOST
X    case 'm':
X    case 'M':
X	truth = (u->ut_host[0] != 0);
X	break;
X#endif
X    default:
X	prnt = 0;		/* Skip unknown conditionals entirely */
X	break;
X    }
X    sep = *fmt++;
X    fmt = watchlog2(inout, u, fmt, (truth && prnt), sep);
X    return watchlog2(inout, u, fmt, (!truth && prnt), END3);
X}
X
X/* print a login/logout event */
X
Xchar *watchlog2(inout, u, fmt, prnt, fini)	/**/
Xint inout;
Xstruct utmp *u;
Xchar *fmt;
Xint prnt;
Xint fini;
X{
X    char *p, buf[40], *bf;
X    int i;
X    time_t timet;
X    struct tm *tm;
X    char *fm2;
X
X    while (*fmt)
X	if (*fmt == '\\')
X	    if (*++fmt) {
X		if (prnt)
X		    putchar(*fmt);
X		++fmt;
X	    } else if (fini)
X		return fmt;
X	    else
X		break;
X	else if (*fmt == fini)
X	    return ++fmt;
X	else if (*fmt != '%') {
X	    if (prnt)
X		putchar(*fmt);
X	    ++fmt;
X	} else {
X	    if (*++fmt == BEGIN3)
X		fmt = watch3ary(inout, u, ++fmt, prnt);
X	    else if (!prnt)
X		++fmt;
X	    else
X		switch (*(fm2 = fmt++)) {
X		case 'n':
X		    printf("%.*s", (int)sizeof(u->ut_name), u->ut_name);
X		    break;
X		case 'a':
X		    printf("%s", (!inout) ? "logged off" : "logged on");
X		    break;
X		case 'l':
X		    if (!strncmp(u->ut_line, "tty", 3))
X			printf("%.*s", (int)sizeof(u->ut_line) - 3, u->ut_line + 3);
X		    else
X			printf("%.*s", (int)sizeof(u->ut_line), u->ut_line);
X		    break;
X#ifdef UTMP_HOST
X		case 'm':
X		    for (p = u->ut_host, i = sizeof(u->ut_host); i && *p; i--, p++) {
X			if (*p == '.' && !idigit(p[1]))
X			    break;
X			putchar(*p);
X		    }
X		    break;
X		case 'M':
X		    printf("%.*s", (int)sizeof(u->ut_host), u->ut_host);
X		    break;
X#endif
X		case 'T':
X		case 't':
X		case '@':
X		case 'W':
X		case 'w':
X		case 'D':
X		    switch (*fm2) {
X		    case '@':
X		    case 't':
X			fm2 = "%l:%M%p";
X			break;
X		    case 'T':
X			fm2 = "%k:%M";
X			break;
X		    case 'w':
X			fm2 = "%a %e";
X			break;
X		    case 'W':
X			fm2 = "%m/%d/%y";
X			break;
X		    case 'D':
X			fm2 = "%y-%m-%d";
X			break;
X		    }
X		    timet = getlogtime(u, inout);
X		    tm = localtime(&timet);
X		    ztrftime(buf, 40, fm2, tm);
X		    printf("%s", (*buf == ' ') ? buf + 1 : buf);
X		    break;
X		case '%':
X		    putchar('%');
X		    break;
X		case 'S':
X		case 's':
X		case 'B':
X		case 'b':
X		case 'U':
X		case 'u':
X		    switch (*fm2) {
X		    case 'S':
X			fm2 = "so";
X			break;
X		    case 's':
X			fm2 = "se";
X			break;
X		    case 'B':
X			fm2 = "md";
X			break;
X		    case 'b':
X			fm2 = "me";
X			break;
X		    case 'U':
X			fm2 = "us";
X			break;
X		    case 'u':
X			fm2 = "ue";
X			break;
X		    }
X		    bf = buf;
X		    if (tgetstr(fm2, &bf))
X			tputs(buf, 1, putraw);
X		    break;
X		default:
X		    putchar('%');
X		    putchar(*fm2);
X		    break;
X		}
X	}
X    if (prnt)
X	putchar('\n');
X
X    return fmt;
X}
X
X/* check the List for login/logouts */
X
Xvoid watchlog(inout, u, w, fmt)	/**/
Xint inout;
Xstruct utmp *u;
Xchar **w;
Xchar *fmt;
X{
X    char *v, *vv, sav;
X    int bad;
X
X    if (*w && !strcmp(*w, "all")) {
X	(void)watchlog2(inout, u, fmt, 1, 0);
X	return;
X    }
X    if (*w && !strcmp(*w, "notme") &&
X	strncmp(u->ut_name, username, sizeof(u->ut_name))) {
X	(void)watchlog2(inout, u, fmt, 1, 0);
X	return;
X    }
X    for (; *w; w++) {
X	bad = 0;
X	v = *w;
X	if (*v != '@' && *v != '%') {
X	    for (vv = v; *vv && *vv != '@' && *vv != '%'; vv++);
X	    sav = *vv;
X	    *vv = '\0';
X	    if (strncmp(u->ut_name, v, sizeof(u->ut_name)))
X		bad = 1;
X	    *vv = sav;
X	    v = vv;
X	}
X	for (;;)
X	    if (*v == '%') {
X		for (vv = ++v; *vv && *vv != '@'; vv++);
X		sav = *vv;
X		*vv = '\0';
X		if (strncmp(u->ut_line, v, sizeof(u->ut_line)))
X		    bad = 1;
X		*vv = sav;
X		v = vv;
X	    }
X#ifdef UTMP_HOST
X	    else if (*v == '@') {
X		for (vv = ++v; *vv && *vv != '%'; vv++);
X		sav = *vv;
X		*vv = '\0';
X		if (strncmp(u->ut_host, v, strlen(v)))
X		    bad = 1;
X		*vv = sav;
X		v = vv;
X	    }
X#endif
X	    else
X		break;
X	if (!bad) {
X	    (void)watchlog2(inout, u, fmt, 1, 0);
X	    return;
X	}
X    }
X}
X
X/* compare 2 utmp entries */
X
Xint ucmp(u, v)			/**/
Xstruct utmp *u;
Xstruct utmp *v;
X{
X    if (u->ut_time == v->ut_time)
X	return strncmp(u->ut_line, v->ut_line, sizeof(u->ut_line));
X    return u->ut_time - v->ut_time;
X}
X
X/* initialize the user List */
X
Xvoid readwtab()
X{				/**/
X    struct utmp *uptr;
X    int wtabmax = 32;
X    FILE *in;
X
X    wtabsz = 0;
X    if (!(in = fopen(UTMP_FILE, "r")))
X	return;
X    uptr = wtab = (struct utmp *)zalloc(wtabmax * sizeof(struct utmp));
X    while (fread(uptr, sizeof(struct utmp), 1, in))
X#ifdef USER_PROCESS
X	if   (uptr->ut_type == USER_PROCESS)
X#else
X	if   (uptr->ut_name[0])
X#endif
X	{
X	    uptr++;
X	    if (++wtabsz == wtabmax)
X		uptr = (wtab = (struct utmp *)realloc((vptr) wtab, (wtabmax *= 2) *
X						      sizeof(struct utmp))) + wtabsz;
X	}
X    fclose(in);
X
X    if (wtabsz)
X	qsort((vptr) wtab, wtabsz, sizeof(struct utmp),
X	           (int (*)DCLPROTO((const void *, const void *)))ucmp);
X}
X
X/* check for login/logout events; executed before each prompt
X	if WATCH is set */
X
Xvoid dowatch()
X{				/**/
X    char **s = watch;
X    char *fmt = (watchfmt) ? watchfmt : DEFWATCHFMT;
X    FILE *in;
X    int utabsz = 0, utabmax = wtabsz + 4, uct, wct;
X    struct utmp *utab, *uptr, *wptr;
X    struct stat st;
X
X    holdintr();
X    if (!fmt)
X	fmt = "%n has %a %l from %m.";
X    if (!wtab) {
X	readwtab();
X	noholdintr();
X	return;
X    }
X    if ((stat(UTMP_FILE, &st) == -1) || (st.st_mtime <= lastutmpcheck)) {
X	noholdintr();
X	return;
X    }
X    lastutmpcheck = st.st_mtime;
X    uptr = utab = (struct utmp *)zalloc(utabmax * sizeof(struct utmp));
X
X    if (!(in = fopen(UTMP_FILE, "r"))) {
X	free(utab);
X	noholdintr();
X	return;
X    }
X    while (fread(uptr, sizeof *uptr, 1, in))
X#ifdef USER_PROCESS
X	if (uptr->ut_type == USER_PROCESS)
X#else
X	if (uptr->ut_name[0])
X#endif
X	{
X	    uptr++;
X	    if (++utabsz == utabmax)
X		uptr = (utab = (struct utmp *)realloc((vptr) utab, (utabmax *= 2) *
X						      sizeof(struct utmp))) + utabsz;
X	}
X    fclose(in);
X    noholdintr();
X    if (errflag) {
X	free(utab);
X	return;
X    }
X    if (utabsz)
X	qsort((vptr) utab, utabsz, sizeof(struct utmp),
X	           (int (*)DCLPROTO((const void *, const void *)))ucmp);
X
X    wct = wtabsz;
X    uct = utabsz;
X    uptr = utab;
X    wptr = wtab;
X    if (errflag) {
X	free(utab);
X	return;
X    }
X    while ((uct || wct) && !errflag)
X	if (!uct || (wct && ucmp(uptr, wptr) > 0))
X	    wct--, watchlog(0, wptr++, s, fmt);
X	else if (!wct || (uct && ucmp(uptr, wptr) < 0))
X	    uct--, watchlog(1, uptr++, s, fmt);
X	else
X	    uptr++, wptr++, wct--, uct--;
X    free(wtab);
X    wtab = utab;
X    wtabsz = utabsz;
X    fflush(stdout);
X}
X
Xint bin_log(nam, argv, ops, func)	/**/
Xchar *nam;
Xchar **argv;
Xchar *ops;
Xint func;
X{
X    if (!watch)
X	return 1;
X    if (wtab)
X	free(wtab);
X    wtab = (struct utmp *)zalloc(1);
X    wtabsz = 0;
X    lastutmpcheck = 0;
X    dowatch();
X    return 0;
X}
END_OF_FILE
  if test 8877 -ne `wc -c <'zsh-2.5.0/src/watch.c'`; then
    echo shar: \"'zsh-2.5.0/src/watch.c'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/src/watch.c'
fi
if test -f 'zsh-2.5.0/src/zle.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/src/zle.h'\"
else
  echo shar: Extracting \"'zsh-2.5.0/src/zle.h'\" \(8927 characters\)
  sed "s/^X//" >'zsh-2.5.0/src/zle.h' <<'END_OF_FILE'
X/*
X *
X * zle.h - header file for line editor
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made.
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk.
X *
X */
X
X#ifdef ZLEGLOBALS
X#define ZLEXTERN
X#else
X#define ZLEXTERN extern
X#endif
X
X#ifdef ZLE
X
X/* cursor position */
XZLEXTERN int cs;
X
X/* line length */
XZLEXTERN int ll;
X
X/* size of line buffer */
XZLEXTERN int linesz;
X
X/* location of mark */
XZLEXTERN int mark;
X
X/* last character pressed */
XZLEXTERN int c;
X
X/* the z_ binding id for this key */
XZLEXTERN int bindk;
X
X/* command argument */
XZLEXTERN int mult;
X
X/* insert mode/overwrite mode flag */
XZLEXTERN int insmode;
X
X/* cost of last update */
X#ifdef HAS_SELECT
XZLEXTERN int cost;
X
X#endif
X
X/* number of lines displayed */
XZLEXTERN int nlnct;
X
X/* flags associated with last command */
XZLEXTERN int lastcmd;
X
X/* column position before last LINEMOVE movement */
XZLEXTERN int lastcol;
X
X/* != 0 if we're getting a vi range */
XZLEXTERN int virangeflag;
X
X/* kludge to get cw and dw to work right */
XZLEXTERN int wordflag;
X
X#endif
X
X/* last named command done */
XZLEXTERN int lastnamed;
X
X/* != 0 if we're done editing */
XZLEXTERN int done;
X
X/* length of prompt, rprompt on screen */
XZLEXTERN int pptlen, ppt2len;
X
X/* current history line number */
XZLEXTERN int histline;
X
X/* != 0 if we need to call resetvideo() */
XZLEXTERN int resetneeded;
X
X/* != 0 if the line editor is active */
XZLEXTERN int zleactive;
X
X/* the line buffer */
XZLEXTERN unsigned char *line;
X
X/* the cut buffer */
XZLEXTERN char *cutbuf;
X
X/* prompt and rprompt */
XZLEXTERN char *pmpt, *pmpt2;
X
X/* the last line in the history (the current one) */
XZLEXTERN char *curhistline;
X
X/* the status line */
XZLEXTERN char *statusline;
X
X/* !=0 if a complete added a suffix at the end of a completion */
XZLEXTERN int addedsuffix;
X
X/* 1 if we expect special keys after completing a parameter name */
XZLEXTERN int complexpect;
X
X/*
X	the current history line and cursor position for the top line
X	on the buffer stack
X*/
X
XZLEXTERN int stackhist, stackcs;
X
X/* != 0 if we are in the middle of a menu completion */
XZLEXTERN int menucmp;
X
X/* != 0 if we are making undo records */
XZLEXTERN int undoing;
X
X/* != 0 if executing a shell function called from zle */
XZLEXTERN int inzlefunc;
X
X/* last vi change buffer */
XZLEXTERN int vichgbufsz, vichgbufptr, vichgflag;
XZLEXTERN char *vichgbuf;
X
XZLEXTERN int viinsbegin;
X
Xtypedef void bindfunc DCLPROTO((void));
Xtypedef bindfunc *F;
X
Xstruct key {
X    struct hashnode *next;
X    char *nam;			/* hash data */
X    int func;			/* function code for this key */
X    char *str;			/* string corresponding to this key,
X			   if func = z_sendstring */
X    int len;			/* length of string */
X    int prefixct;		/* number of strings for which this is a prefix */
X};
X
Xstruct zlecmd {
X    char *name;			/* name of function */
X    F func;			/* handler function */
X    int flags;
X};
X
X/* undo event */
X
Xstruct undoent {
X    int pref;			/* number of initial chars unchanged */
X    int suff;			/* number of trailing chars unchanged */
X    int len;			/* length of changed chars */
X    int cs;			/* cursor pos before change */
X    char *change;		/* NOT null terminated */
X};
X
X#define UNDOCT 64
X
XZLEXTERN struct undoent undos[UNDOCT];
X
X/* the line before last mod (for undo purposes) */
XZLEXTERN unsigned char *lastline;
X
X/* buffer specified with "x */
XZLEXTERN int vibufspec;
X
XZLEXTERN int undoct, lastcs;
X
XZLEXTERN char *visrchstr;
XZLEXTERN int visrchsense;
X
X#define ZLE_MOVEMENT  	 1
X#define ZLE_MENUCMP  	 2
X#define ZLE_UNDO      	 4
X#define ZLE_YANK     	 8
X#define ZLE_LINEMOVE 	 16
X#define ZLE_ARG      	 32
X#define ZLE_NAMEDBUFFER 128
X#define ZLE_KILL        (64|ZLE_NAMEDBUFFER)
X#define ZLE_HISTSEARCH  256
X#define ZLE_NEGARG      512
X#define ZLE_INSERT     1024
X#define ZLE_DELETE     2048
X
Xtypedef struct key *Key;
X
XZLEXTERN int *bindtab, *mainbindtab;
Xextern int emacsbind[], viinsbind[], vicmdbind[];
XZLEXTERN int altbindtab[256];
X
X#define KRINGCT 8
XZLEXTERN char *kring[KRINGCT];
XZLEXTERN int kringnum;
XZLEXTERN char *vibuf[36];
X
X#define z_acceptandhold 0
X#define z_acceptandinfernexthistory 1
X#define z_acceptandmenucomplete 2
X#define z_acceptline 3
X#define z_acceptlineanddownhistory 4
X#define z_backwardchar 5
X#define z_backwarddeletechar 6
X#define z_backwarddeleteword 7
X#define z_backwardkillline 8
X#define z_backwardkillword 9
X#define z_backwardword 10
X#define z_beginningofbufferorhistory 11
X#define z_beginningofhistory 12
X#define z_beginningofline 13
X#define z_beginningoflinehist 14
X#define z_capitalizeword 15
X#define z_clearscreen 16
X#define z_completeword 17
X#define z_copyprevword 18
X#define z_copyregionaskill 19
X#define z_deletechar 20
X#define z_deletecharorlist 21
X#define z_deleteword 22
X#define z_digitargument 23
X#define z_downcaseword 24
X#define z_downhistory 25
X#define z_downlineorhistory 26
X#define z_endofbufferorhistory 27
X#define z_endofhistory 28
X#define z_endofline 29
X#define z_endoflinehist 30
X#define z_exchangepointandmark 31
X#define z_executelastnamedcmd 32
X#define z_executenamedcmd 33
X#define z_expandhistory 34
X#define z_expandorcomplete 35
X#define z_expandword 36
X#define z_forwardchar 37
X#define z_forwardword 38
X#define z_getline 39
X#define z_gosmacstransposechars 40
X#define z_historyincrementalsearchbackward 41
X#define z_historyincrementalsearchforward 42
X#define z_historysearchbackward 43
X#define z_historysearchforward 44
X#define z_infernexthistory 45
X#define z_insertlastword 46
X#define z_killbuffer 47
X#define z_killline 48
X#define z_killregion 49
X#define z_killwholeline 50
X#define z_listchoices 51
X#define z_listexpand 52
X#define z_magicspace 53
X#define z_menucompleteword 54
X#define z_menuexpandorcomplete 55
X#define z_overwritemode 56
X#define z_pushline 57
X#define z_quotedinsert 58
X#define z_quoteline 59
X#define z_quoteregion 60
X#define z_redisplay 61
X#define z_reversemenucomplete 62
X#define z_runhelp 63
X#define z_selfinsert 64
X#define z_selfinsertunmeta 65
X#define z_sendbreak 66
X#define z_sendstring 67
X#define z_sequenceleadin 68
X#define z_setmarkcommand 69
X#define z_spellword 70
X#define z_toggleliteralhistory 71
X#define z_transposechars 72
X#define z_transposewords 73
X#define z_undefinedkey 74
X#define z_undo 75
X#define z_universalargument 76
X#define z_upcaseword 77
X#define z_uphistory 78
X#define z_uplineorhistory 79
X#define z_viaddeol 80
X#define z_viaddnext 81
X#define z_vibackwardblankword 82
X#define z_vibackwardchar 83
X#define z_vibackwarddeletechar 84
X#define z_vibeginningofline 85
X#define z_vicapslockpanic 86
X#define z_vichange 87
X#define z_vichangeeol 88
X#define z_vichangewholeline 89
X#define z_vicmdmode 90
X#define z_videlete 91
X#define z_videletechar 92
X#define z_vidigitorbeginningofline 93
X#define z_viendofline 94
X#define z_vifetchhistory 95
X#define z_vifindnextchar 96
X#define z_vifindnextcharskip 97
X#define z_vifindprevchar 98
X#define z_vifindprevcharskip 99
X#define z_vifirstnonblank 100
X#define z_viforwardblankword 101
X#define z_viforwardblankwordend 102
X#define z_viforwardchar 103
X#define z_viforwardwordend 104
X#define z_vigotocolumn 105
X#define z_vigotomark 106
X#define z_vigotomarkline 107
X#define z_vihistorysearchbackward 108
X#define z_vihistorysearchforward 109
X#define z_viindent 110
X#define z_viinsert 111
X#define z_viinsertbol 112
X#define z_vijoin 113
X#define z_vimatchbracket 114
X#define z_viopenlineabove 115
X#define z_viopenlinebelow 116
X#define z_vioperswapcases 117
X#define z_viputafter 118
X#define z_virepeatchange 119
X#define z_virepeatfind 120
X#define z_virepeatsearch 121
X#define z_vireplace 122
X#define z_vireplacechars 123
X#define z_virevrepeatfind 124
X#define z_virevrepeatsearch 125
X#define z_visetbuffer 126
X#define z_visetmark 127
X#define z_visubstitute 128
X#define z_viswapcase 129
X#define z_viundochange 130
X#define z_viunindent 131
X#define z_viyank 132
X#define z_viyankeol 133
X#define z_whichcommand 134
X#define z_yank 135
X#define z_yankpop 136
X#define z_emacsbackwardword 137
X#define z_emacsforwardword 138
X#define z_killword 139
X#define z_vikillline 140
X#define z_vibackwardkillword 141
X#define z_expandcmdpath 142
X#define z_negargument 143
X#define z_poundinsert 144
X#define z_viforwardword 145
X#define z_vibackwardword 146
X#define z_uplineorsearch 147
X#define z_downlineorsearch 148
X#define z_pushinput 149
X#define z_pushpopinput 150
X#define z_historybeginningsearchbackward 151
X#define z_historybeginningsearchforward 152
X#define z_expandorcompleteprefix 153
X#define ZLECMDCOUNT 154
X
Xextern struct zlecmd zlecmds[];
END_OF_FILE
  if test 8927 -ne `wc -c <'zsh-2.5.0/src/zle.h'`; then
    echo shar: \"'zsh-2.5.0/src/zle.h'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/src/zle.h'
fi
if test -f 'zsh-2.5.0/src/zle_word.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/src/zle_word.c'\"
else
  echo shar: Extracting \"'zsh-2.5.0/src/zle_word.c'\" \(7099 characters\)
  sed "s/^X//" >'zsh-2.5.0/src/zle_word.c' <<'END_OF_FILE'
X
X/*
X *
X * zle_word.c - word-related editor functions
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made.
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk.
X *
X */
X
X#define ZLE
X#include "zsh.h"
X
Xvoid forwardword()
X{				/**/
X    if (mult < 0) {
X	mult = -mult;
X	backwardword();
X	return;
X    }
X    while (mult--) {
X	while (cs != ll && iword(line[cs]))
X	    cs++;
X	if (wordflag && !mult)
X	    return;
X	while (cs != ll && !iword(line[cs]))
X	    cs++;
X    }
X}
X
Xvoid viforwardword()
X{				/**/
X    if (mult < 0) {
X	mult = -mult;
X	backwardword();
X	return;
X    }
X    while (mult--) {
X	if (iident(line[cs]))
X	    while (cs != ll && iident(line[cs]))
X		cs++;
X	else
X	    while (cs != ll && !iident(line[cs]) && !iblank(line[cs]))
X		cs++;
X	if (wordflag && !mult)
X	    return;
X	while (cs != ll && iblank(line[cs]))
X	    cs++;
X    }
X}
X
Xvoid viforwardblankword()
X{				/**/
X    if (mult < 0) {
X	mult = -mult;
X	vibackwardblankword();
X	return;
X    }
X    while (mult--) {
X	while (cs != ll && !iblank(line[cs]))
X	    cs++;
X	if (wordflag && !mult)
X	    return;
X	while (cs != ll && iblank(line[cs]))
X	    cs++;
X    }
X}
X
Xvoid emacsforwardword()
X{				/**/
X    if (mult < 0) {
X	mult = -mult;
X	emacsbackwardword();
X	return;
X    }
X    while (mult--) {
X	while (cs != ll && !iword(line[cs]))
X	    cs++;
X	if (wordflag && !mult)
X	    return;
X	while (cs != ll && iword(line[cs]))
X	    cs++;
X    }
X}
X
Xvoid viforwardblankwordend()
X{				/**/
X    if (mult < 0)
X	return;
X    while (mult--) {
X	while (cs != ll && iblank(line[cs + 1]))
X	    cs++;
X	while (cs != ll && !iblank(line[cs + 1]))
X	    cs++;
X    }
X    if (cs != ll && virangeflag)
X	cs++;
X}
X
Xvoid viforwardwordend()
X{				/**/
X    if (mult < 0) {
X	mult = -mult;
X	backwardword();
X	return;
X    }
X    while (mult--) {
X	if (iblank(line[cs + 1]))
X	    while (cs != ll && iblank(line[cs + 1]))
X		cs++;
X	if (iident(line[cs + 1]))
X	    while (cs != ll && iident(line[cs + 1]))
X		cs++;
X	else
X	    while (cs != ll && !iident(line[cs + 1]) && !iblank(line[cs + 1]))
X		cs++;
X    }
X    if (cs != ll && virangeflag)
X	cs++;
X}
X
Xvoid backwardword()
X{				/**/
X    if (mult < 0) {
X	mult = -mult;
X	forwardword();
X	return;
X    }
X    while (mult--) {
X	while (cs && !iword(line[cs - 1]))
X	    cs--;
X	while (cs && iword(line[cs - 1]))
X	    cs--;
X    }
X}
X
Xvoid vibackwardword()
X{				/**/
X    if (mult < 0) {
X	mult = -mult;
X	backwardword();
X	return;
X    }
X    while (mult--) {
X	while (cs && iblank(line[cs - 1]))
X	    cs--;
X	if (iident(line[cs - 1]))
X	    while (cs && iident(line[cs - 1]))
X		cs--;
X	else
X	    while (cs && !iident(line[cs - 1]) && !iblank(line[cs - 1]))
X		cs--;
X    }
X}
X
Xvoid vibackwardblankword()
X{				/**/
X    if (mult < 0) {
X	mult = -mult;
X	viforwardblankword();
X	return;
X    }
X    while (mult--) {
X	while (cs && iblank(line[cs - 1]))
X	    cs--;
X	while (cs && !iblank(line[cs - 1]))
X	    cs--;
X    }
X}
X
Xvoid emacsbackwardword()
X{				/**/
X    if (mult < 0) {
X	mult = -mult;
X	emacsforwardword();
X	return;
X    }
X    while (mult--) {
X	while (cs && !iword(line[cs - 1]))
X	    cs--;
X	while (cs && iword(line[cs - 1]))
X	    cs--;
X    }
X}
X
Xvoid backwarddeleteword()
X{				/**/
X    int x = cs;
X
X    if (mult < 0) {
X	mult = -mult;
X	deleteword();
X	return;
X    }
X    while (mult--) {
X	while (x && !iword(line[x - 1]))
X	    x--;
X	while (x && iword(line[x - 1]))
X	    x--;
X    }
X    backdel(cs - x);
X}
X
Xvoid vibackwardkillword()
X{				/**/
X    int x = cs;
X
X    if (mult < 0) {
X	feep();
X	return;
X    }
X/* this taken from "vibackwardword" */
X    while (mult--) {
X	while ((x > viinsbegin) && iblank(line[x - 1]))
X	    x--;
X	if (iident(line[x - 1]))
X	    while ((x > viinsbegin) && iident(line[x - 1]))
X		x--;
X	else
X	    while ((x > viinsbegin) && !iident(line[x - 1]) && !iblank(line[x - 1]))
X		x--;
X    }
X/*
X        while (mult--) {
X                while ( (x > viinsbegin) && (iwordsep(line[x-1]))) x--;
X                while ( (x > viinsbegin) && (!iwordsep(line[x-1]))) x--;
X        }
X        */
X    backkill(cs - x, 1);
X}
X
Xvoid backwardkillword()
X{				/**/
X    int x = cs;
X
X    if (mult < 0) {
X	mult = -mult;
X	killword();
X	return;
X    }
X    while (mult--) {
X	while (x && !iword(line[x - 1]))
X	    x--;
X	while (x && iword(line[x - 1]))
X	    x--;
X    }
X    backkill(cs - x, 1);
X}
X
Xvoid upcaseword()
X{				/**/
X    int neg = mult < 0, ocs = cs;
X
X    if (neg)
X	mult = -mult;
X    while (mult--) {
X	while (cs != ll && !iword(line[cs]))
X	    cs++;
X	while (cs != ll && iword(line[cs])) {
X	    line[cs] = tuupper(line[cs]);
X	    cs++;
X	}
X    }
X    if (neg)
X	cs = ocs;
X}
X
Xvoid downcaseword()
X{				/**/
X    int neg = mult < 0, ocs = cs;
X
X    if (neg)
X	mult = -mult;
X    while (mult--) {
X	while (cs != ll && !iword(line[cs]))
X	    cs++;
X	while (cs != ll && iword(line[cs])) {
X	    line[cs] = tulower(line[cs]);
X	    cs++;
X	}
X    }
X    if (neg)
X	cs = ocs;
X}
X
Xvoid capitalizeword()
X{				/**/
X    int first;
X    int neg = mult < 0, ocs = cs;
X
X    if (neg)
X	mult = -mult;
X    while (mult--) {
X	first = 1;
X	while (cs != ll && !iword(line[cs]))
X	    cs++;
X	while (cs != ll && iword(line[cs])) {
X	    line[cs] = (first) ? tuupper(line[cs]) : tulower(line[cs]);
X	    first = 0;
X	    cs++;
X	}
X    }
X    if (neg)
X	cs = ocs;
X}
X
Xvoid deleteword()
X{				/**/
X    int x = cs;
X
X    if (mult < 0) {
X	mult = -mult;
X	backwarddeleteword();
X	return;
X    }
X    while (mult--) {
X	while (x != ll && !iword(line[x]))
X	    x++;
X	while (x != ll && iword(line[x]))
X	    x++;
X    }
X    foredel(x - cs);
X}
X
Xvoid killword()
X{				/**/
X    int x = cs;
X
X    if (mult < 0) {
X	mult = -mult;
X	backwardkillword();
X	return;
X    }
X    while (mult--) {
X	while (x != ll && !iword(line[x]))
X	    x++;
X	while (x != ll && iword(line[x]))
X	    x++;
X    }
X    forekill(x - cs, 0);
X}
X
Xvoid transposewords()
X{				/**/
X    int p1, p2, p3, p4, x = cs;
X    char *temp, *pp;
X    int neg = mult < 0, ocs = cs;
X
X    if (neg)
X	mult = -mult;
X    while (mult--) {
X	while (x != ll && line[x] != '\n' && !iword(line[x]))
X	    x++;
X	if (x == ll || line[x] == '\n') {
X	    x = cs;
X	    while (x && line[x - 1] != '\n' && !iword(line[x]))
X		x--;
X	    if (!x || line[x - 1] == '\n') {
X		feep();
X		return;
X	    }
X	}
X	for (p4 = x; p4 != ll && iword(line[p4]); p4++);
X	for (p3 = p4; p3 && iword(line[p3 - 1]); p3--);
X	if (!p3) {
X	    feep();
X	    return;
X	}
X	for (p2 = p3; p2 && !iword(line[p2 - 1]); p2--);
X	if (!p2) {
X	    feep();
X	    return;
X	}
X	for (p1 = p2; p1 && iword(line[p1 - 1]); p1--);
X	pp = temp = (char *)halloc(p4 - p1 + 1);
X	struncpy(&pp, UTOSCP(line + p3), p4 - p3);
X	struncpy(&pp, UTOSCP(line + p2), p3 - p2);
X	struncpy(&pp, UTOSCP(line + p1), p2 - p1);
X	strncpy((char *)line + p1, temp, p4 - p1);
X	cs = p4;
X    }
X    if (neg)
X	cs = ocs;
X}
END_OF_FILE
  if test 7099 -ne `wc -c <'zsh-2.5.0/src/zle_word.c'`; then
    echo shar: \"'zsh-2.5.0/src/zle_word.c'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/src/zle_word.c'
fi
echo shar: End of archive 16 \(of 18\).
cp /dev/null ark16isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
