Path: news.csc.fi!news.eunet.fi!EU.net!uunet!sparky!not-for-mail
From: zsh-list@sterling.com (Bas de Bakker)
Newsgroups: comp.sources.misc
Subject: v43i095:  zsh - The Z shell, version 2.5.0, Part06/18
Followup-To: comp.sources.d
Date: 13 Jul 1994 23:03:46 -0500
Organization: Sterling Software
Lines: 3087
Sender: kent@sparky.sterling.com
Approved: kent@sparky.sterling.com
Message-ID: <302df2$t0a@sparky.sterling.com>
References: <csm-v43i089=zsh.230017@sparky.sterling.com>
NNTP-Posting-Host: sparky.sterling.com
X-Md4-Signature: 6bf1d056737803027a65f70bfc189e32

Submitted-by: zsh-list@sterling.com (Bas de Bakker)
Posting-number: Volume 43, Issue 95
Archive-name: zsh/part06
Environment: UNIX
Supersedes: zsh: Volume 35, Issue 51-72

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  zsh-2.5.0/doc/zsh.texi.A zsh-2.5.0/src/zle_misc.c
# Wrapped by kent@sparky on Tue Jul 12 16:47:19 1994
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 6 (of 18)."'
if test -f 'zsh-2.5.0/doc/zsh.texi.A' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/doc/zsh.texi.A'\"
else
  echo shar: Extracting \"'zsh-2.5.0/doc/zsh.texi.A'\" \(63392 characters\)
  sed "s/^X//" >'zsh-2.5.0/doc/zsh.texi.A' <<'END_OF_FILE'
X\input texinfo.tex @c -*- texinfo -*-
X@c %**start of header
X@setfilename zsh.info
X@settitle    zsh
X@c %**end of header
X
X@setchapternewpage on
X@iftex
X@finalout
X@end iftex
X
X@ifinfo
XThis is a texinfo version of the man page for the Z Shell, originally by Paul
XFalstad.  It was converted from the @code{zsh.1} file
Xdistributed with zsh v2.5.0.  The conversion was done by Jonathan
XHardwick, @code{jch@@cs.cmu.edu}, who would love to hear of any errors
Xhe introduced or texinfo rules he broke.  The text remains the work of
XPaul Falstad.@refill
X@end ifinfo
X
X@titlepage
X@sp 4
X@center @titlefont{The Z Shell}
X@sp 2
X@center Originally by Paul Falstad
X@center pf@@z-code.com
X@sp 2
X@center 30 December 1993
X@page
X@vskip 0pt plus 1filll
XThis is a texinfo version of the man page for the Z Shell, by Paul
XFalstad.  It was converted from the original @code{zsh.1} file
Xdistributed with zsh v2.5.0.  The conversion was done by Jonathan
XHardwick, @code{jch@@cs.cmu.edu}, who would love to hear of any errors
Xhe introduced or texinfo rules he broke.  The text remains the work of
XPaul Falstad.
X@end titlepage
X
X@node Top, Shell Grammar, (dir), (dir)
X@c @top zsh
X
X@menu
X* Shell Grammar::		
X* Expansion::			
X* Redirection::			
X* Command Execution::		
X* Functions::			
X* Jobs & Signals::		
X* History::			
X* Arithmetic Evaluation::	
X* Conditional Expressions::	
X* Zsh Line Editor::		
X* Parameters::			
X* Options::			
X* Shell Builtin Commands::	
X* Invocation::			
X* Wrapping Up::			
X
X --- Indices ---
X
X* Concept Index::		
X* Variables Index::             
X* Options Index::               
X* Functions Index::             
X* Editor Functions Index::      
X* Keystroke Index::             
X
X --- The Detailed Node Listing ---
X
XShell Grammar
X
X* Simple Commands & Pipelines:: 
X* Complex Commands::            
X* Reserved Words::              
X* Comments::                    
X* Aliasing::                    
X* Quoting::                     
X
XExpansion
X
X* Filename Expansion::          
X* Process Substitution::        
X* Parameter Expansion::         
X* Command Substitution::        
X* Arithmetic Expansion::        
X* Brace Expansion::             
X* Filename Generation::         
X
XHistory
X
X* Event Designators::           
X* Word Designators::            
X* Modifiers::                   
X
XZsh Line Editor
X
X* Movement::                    
X* History Control::             
X* Modifying Text::              
X* Arguments::                   
X* Completion::                  
X* Miscellaneous::               
X
XParameters
X
X* Array Parameters::            
X* Positional Parameters::       
X* Parameters Set By The Shell::  
X* Parameters Used By The Shell::  
X
XWrapping Up
X@end menu
X
X@node Shell Grammar, Expansion, Top, Top
X@chapter Shell Grammar
X@cindex shell grammar
X@cindex grammar, shell
X
X@menu
X* Simple Commands & Pipelines::	 
X* Complex Commands::		
X* Reserved Words::		
X* Comments::			
X* Aliasing::			
X* Quoting::			
X@end menu
X
X@node Simple Commands & Pipelines, Complex Commands,  , Shell Grammar
X@section Simple Commands
X@cindex simple commands
X@cindex commands, simple
X
X@noindent
XA @dfn{simple command} is a sequence of optional parameter assignments
Xfollowed by blank-separated words, with optional redirections
Xinterspersed.  The first word is the command to be executed, and the
Xremaining words, if any, are arguments to the command.  If a command
Xname is given, the parameter assignments modify the environment of the
Xcommand when it is executed.  The value of a simple command is its exit
Xstatus, or 128 plus the signal number if terminated by a signal.@refill
X
X@findex exec
X@findex command
X@findex noglob
X@findex nocorrect
X@noindent
XIf a simple command is preceded by the word @code{exec}, it is executed
Xin the parent shell without forking.  If preceded by @code{command}, the
Xcommand word is taken to be the name of an external command, rather than
Xa shell function or builtin.  If preceded by @code{noglob}, filename
Xgeneration is not performed on any of the words.  If preceded by a
X@code{-}, the command is executed with a @code{-} prepended to its
X@code{argv[0]} string.  If preceded by @code{nocorrect}, spelling
Xcorrection is not done on any of the words.@refill
X
X@cindex pipeline
X@noindent
XA @dfn{pipeline} is a sequence of one or more commands separated by
X@code{|} or @code{|&}.  @code{|&} is shorthand for @code{2>&1 |}.  The
Xstandard output of each command is connected to the standard input of
Xthe next command in the pipeline.@refill
X
X@cindex pipeline, value of
X@noindent
XThe value of a pipeline is the value of the last command.  If a pipeline
Xis preceded by a @code{!}, the value of that pipeline is the logical NOT
Xof the value of the last command.@refill
X
X@findex coproc
X@cindex coprocesses
X@noindent
XIf a pipeline is preceded by @code{coproc}, it is executed as a
Xcoprocess; a two-way pipe is established between it and the parent
Xshell.  The shell can read from or write to the coprocess by means of
Xthe @code{>&p} and @code{<&p} redirection operators.@refill
X
X@cindex sublist
X@noindent
XA @dfn{sublist} is a sequence of one or more pipelines separated by
X@code{&&} or @code{||}.  If two pipelines are separated by @code{&&},
Xthe second pipeline is executed only if the first is successful (returns
Xa zero value).  If two pipelines are separated by @code{||}, the second
Xis executed only if the first is unsuccessful (returns a nonzero
Xvalue).  Both operators have equal precedence and are left 
Xassociative.@refill
X
X@cindex list
X@noindent
XA @dfn{list} is a sequence of one or more sublists separated by, and
Xoptionally terminated by, @code{;}, @code{&}, or a newline.  Normally
Xthe shell waits for each list to finish before executing the next one.
XIf a list is terminated by a @code{&}, the shell executes it in the
Xbackground, and does not wait for it to finish.@refill
X
X@node Complex Commands, Reserved Words, Simple Commands & Pipelines, Shell Grammar
X@section Complex Commands
X@cindex complex commands
X@cindex commands, complex
X
X@noindent
XA @dfn{complex command} is one of the following:
X
X@table @code
X@cindex for loops
X@cindex loops, for
X@findex for
X@item for @var{name} [ in @var{word} @dots{} ]
X@itemx do @var{list}
X@itemx done
XExpand the list of @var{word}s, and set the parameter @var{name} to each
Xof them in turn, executing @var{list} each time.  If the @code{in
X@var{word}} is omitted, use the positional parameters instead of the
X@var{word}s.@refill
X
X@item for @var{name} [ in @var{word} @dots{} ] ; @var{sublist}
XThis is a shorthand for @code{for}.  Though it may cause confusion, it
Xis included for convenience; its use in scripts is discouraged, unless
X@var{sublist} is a command of the form @{ @var{list} @}.@refill
X
X@findex foreach
X@item foreach @var{name} ( @var{word} @dots{} )
X@itemx @var{list}
X@itemx end
XAnother form of @code{for}.
X
X@item for @var{name} in @var{word} @dots{}
X@itemx @{
X@itemx @var{list}
X@itemx @}
XAnother form of @code{for}.
X
X@item for @var{name} ( @var{word} @dots{} ) @{
X@itemx @var{list}
X@itemx @}
XAnother form of @code{for}; this requires the option
X@code{CSH_JUNKIE_PAREN}.@refill
X
X@item for @var{name} ( @var{word} @dots{} ) @var{sublist}
XAnother form of @code{for}; this also requires
X@code{CSH_JUNKIE_PAREN}.@refill
X
X@cindex selection, user
X@cindex user selection
X@findex select
X@item select @var{name} [ in @var{word} @dots{} ]
X@itemx do @var{list}
X@itemx done
XPrint the set of @var{word}s, each preceded by a number.  If the
X@code{in @var{word}} is omitted, use the positional parameters.  The
X@code{PROMPT3} prompt is printed and a line is read from standard input.
XIf this line consists of the number of one of the listed @var{word}s,
Xthen the parameter @var{name} is set to the @var{word} corresponding to
Xthis number.  If this line is empty, the selection list is printed
Xagain.  Otherwise, the value of the parameter @var{name} is set to null.
XThe contents of the line read from standard input is saved in the
Xparameter @code{REPLY}.  @var{list} is executed for each selection until
Xa break or end-of-file is encountered.@refill
X
X@item select @var{name} [ in @var{word} ] ; @var{sublist}
XA short form of @code{select}.
X
X@findex case
X@cindex case selection
X@cindex selection, case
X@item case @var{word} in [ @var{pattern} ) @var{list} ;; ] @dots{} esac
XExecute the @var{list} associated with the first @var{pattern} that
Xmatches @var{word}, if any.  The form of the patterns is the same as
Xthat used for filename generation.  @xref{Filename Generation}.@refill
X
X@item case @var{word} @{ [ @var{pattern} ) @var{list} ;; ] @dots{} @}
XAnother form of @code{case}.
X
X@findex if
X@cindex if construct
X@item if @var{list}
X@itemx then @var{list}
X@itemx [ elif @var{list} ; then @var{list} ] @dots{}
X@itemx [ else @var{list} ]
X@itemx fi
XThe @code{if @var{list}} is executed, and, if it returns a zero exit
Xstatus, the @code{then @var{list}} is executed.  Otherwise, the
X@code{elif @var{list}} is executed and, if its value is zero, the
X@code{then @var{list}} is executed.  If each @code{elif @var{list}}
Xreturns nonzero, the @code{else @var{list}} is executed.@refill
X
X@item if ( @var{list} ) @var{sublist}
XA short form of @code{if}; this requires the option
X@code{CSH_JUNKIE_PAREN}.@refill
X
X@item if ( @var{list} ) @{
X@itemx @var{list}
X@itemx @} elif ( @var{list} ) @{
X@itemx @var{list}
X@itemx @} @dots{} else @{
X@itemx @var{list}
X@itemx @}
XAn alternate form of @code{if}.  The parentheses surrounding @var{list}
Xcan be omitted if the only command in the list is a conditional
Xexpression of the form @code{[[ @var{exp} ]]}.  @xref{Conditional
XExpressions}.  This form also requires @code{CSH_JUNKIE_PAREN}.@refill
X
X@findex while
X@cindex while loops
X@cindex loops, while
X@item while @var{list}
X@itemx do @var{list}
X@itemx done
XExecute the @code{do @var{list}} as long as the @code{while @var{list}}
Xreturns a zero exit status.@refill
X
X@item while ( @var{list} ) @{
X@itemx @var{list}
X@itemx @}
XAn alternate form of @code{while}; this requires the option
X@code{CSH_JUNKIE_PAREN}.@refill
X
X@findex until
X@cindex until loops
X@cindex loops, until
X@item until @var{list}
X@itemx do @var{list}
X@itemx done
XExecute the @code{do @var{list}} as long as the @code{until @var{list}}
Xreturns a nonzero exit status.@refill
X
X@findex repeat
X@cindex repeat loops
X@cindex loops, repeat
X@item repeat @var{word}
X@itemx do @var{list}
X@itemx done
X@var{word} is expanded and treated as an arithmetic expression, which
Xmust evaluate to a number @var{n}.  @var{list} is then executed @var{n}
Xtimes.@refill
X
X@item repeat @var{word} @var{sublist}
XThis is a short form of @code{repeat}.
X
X@cindex subshells
X@item ( @var{list} )
XExecute @var{list} in a subshell.
X
X@item @{ @var{list} @}
XExecute @var{list}.
X
X@item function @var{word} [ () ] @dots{} @{ @var{list} @}
X@itemx @var{word} @dots{} () @{ @var{list} @}
X@itemx @var{word} @dots{} () @var{sublist}
XDefine a function which is referenced by any one of @var{word}.
XNormally, only one @var{word} is provided; multiple @var{word}s are
Xusually only useful for setting traps.  The body of the function is the
X@var{list} between the @code{@{} and @code{@}}.
X@xref{Functions}.@refill
X
X@cindex timing
X@item time [ @var{pipeline} ]
XThe @var{pipeline} is executed, and timing statistics are reported on
Xthe standard error in the form specified by the @code{TIMEFMT}
Xparameter.  If @var{pipeline} is omitted, print statistics about the
Xshell process and its children.@refill
X
X@cindex testing conditional expression
X@item [[ @var{exp} ]]
XEvaluates the conditional expression @var{exp} and return a zero exit
Xstatus if it is true.  @xref{Conditional Expressions}, for a description
Xof @var{exp}.@refill
X@end table
X
X@node Reserved Words, Comments, Complex Commands, Shell Grammar
X@section Reserved Words
X@cindex reserved words
X
X@findex unalias, use of
X@noindent
XThe following words are recognized as @dfn{reserved words} when used as
Xthe first word of a command unless quoted or removed using the
X@code{unalias} builtin:@refill
X
X@noindent
X@code{do} @code{done} @code{esac} @code{then} @code{elif} @code{else}
X@code{fi} @code{for} @code{case} @code{if} @code{while} @code{function}
X@code{repeat} @code{time} @code{until} @code{exec} @code{command}
X@code{select} @code{coproc} @code{noglob} @code{-} @code{nocorrect}
X@code{foreach} @code{end} @refill
X
X@node Comments, Aliasing, Reserved Words, Shell Grammar
X@section Comments
X@cindex comments
X
X@vindex HISTCHARS, use of
X@pindex INTERACTIVE_COMMENTS, use of
X@noindent
XIn noninteractive shells, or in interactive shells with the
X@code{INTERACTIVE_COMMENTS} option set, a word beginning with the third
Xcharacter of the @code{HISTCHARS} parameter (@code{#} by default) causes
Xthat word and all the following characters up to a newline to be
Xignored.@refill
X
X@node Aliasing, Quoting, Comments, Shell Grammar
X@section Aliasing
X@cindex aliasing
X
X@findex alias, use of
X@cindex aliases, global
X@noindent
XEvery token in the shell input is checked to see if there is an alias
Xdefined for it.  If so, it is replaced by the text of the alias if it is
Xin command position (if it could be the first word of a simple command),
Xor if the alias is global.  If the text ends with a space, the next word
Xin the shell input is treated as though it were in command position for
Xpurposes of alias expansion.  An alias is defined using the @code{alias}
Xbuiltin; global aliases may be defined using the @code{-g} option to
Xthat builtin.@refill
X
X@noindent
XAlias substitution is done on the shell input before any other
Xsubstitution except history substitution.  Therefore, if an alias is
Xdefined for the word @samp{foo}, alias substitution may be avoided by
Xquoting part of the word, e.g.@: @samp{\foo}.  But there is nothing to
Xprevent an alias being defined for @samp{\foo} as well.@refill
X
X@node Quoting,  , Aliasing, Shell Grammar
X@section Quoting
X@cindex quoting
X
X@noindent
XA character may be @dfn{quoted} (that is, made to stand for itself) by
Xpreceding it with a @code{\}.  @code{\} followed by a newline is
Xignored.  All characters enclosed between a pair of single quotes
X@ifinfo
X(@code{@'@'}) are quoted, except the first character of @code{HISTCHARS}
X@end ifinfo
X@iftex
X(@code{''}) are quoted, except the first character of @code{HISTCHARS}
X@end iftex
X(@code{!} by default).  A single quote cannot appear within single
Xquotes.  Inside double quotes (@code{""}), parameter and command
Xsubstitution occurs, and @code{\} quotes the characters @code{\},
X@code{`}, @code{"}, and @code{$}. @refill
X
X@node Expansion, Redirection, Shell Grammar, Top
X@chapter Expansion
X@cindex expansion
X
X@noindent
XExpansion is performed on the command line after it has been parsed.
XThe types of expansions performed are @dfn{filename expansion},
X@dfn{process substitution}, @dfn{parameter expansion}, @dfn{command
Xsubstitution}, @dfn{arithmetic expansion}, @dfn{brace expansion}, and
X@dfn{filename generation}.@refill
X
X@menu
X* Filename Expansion::		
X* Process Substitution::	
X* Parameter Expansion::		
X* Command Substitution::	
X* Arithmetic Expansion::	
X* Brace Expansion::		
X* Filename Generation::		
X@end menu
X
X@node Filename Expansion, Process Substitution,  , Expansion
X@section Filename Expansion
X@cindex filename expansion
X@cindex expansion, filename
X
X@noindent
XEach word is checked to see if it begins with an unquoted @code{~}.  If
Xit does, then the word up to a @code{/} is checked to see if it matches
Xthe name of a named directory.  If so, then the @code{~} and the matched
Xportion are replaced with the value of the named directory.  A @code{~}
Xby itself or followed by a @code{/} is replaced by the value of the
X@code{HOME} parameter.  A @code{~} followed by a @code{+} or a @code{-}
Xis replaced by the value of @code{PWD} or @code{OLDPWD},
Xrespectively.@refill
X
X@cindex directories, named
X@cindex named directories
X@noindent
XNamed directories are typically login directories for users on the
Xsystem.  They may also be defined if the text after the @code{~} is the
Xname of a string shell parameter whose value begins with a @code{/}.  In
Xcertain circumstances (in prompts, for instance), when the shell prints
Xa path, the path is checked to see if it has a named directory as its
Xprefix.  If so, then the prefix portion is replaced with a @code{~}
Xfollowed by the name of the directory.  The longest match is
Xpreferred.@refill
X
X@noindent
XIf a word begins with an unquoted @code{=} and the @code{NO_EQUALS}
Xoption is not set, the remainder of the word is taken as the name of a
Xcommand or alias.  If a command exists by that name, the word is
Xreplaced by the full pathname of the command.  If an alias exists by
Xthat name, the word is replaced with the text of the alias.  Otherwise
Xthe word is checked up to a @code{/} to see if it is a number or a
X@code{-}.  If so, the matched portion is replaced with the @var{n}'th
Xdirectory in the directory stack, where @var{n} is the number matched,
Xor the last directory in the directory stack if a @code{-} is
Xmatched.@refill
X
X@noindent
XFilename expansion is performed on the right hand side of a parameter
Xassignment, including those appearing after commands of the
X@code{typeset} family.  In this case, the right hand side will be
Xtreated as a colon-separated list in the manner of @code{PATH}, so that
Xa @code{~} or @code{=} following a @code{:} is eligible for expansion.
XAll such behaviour can be disabled by quoting the @code{~}, @code{=}, or
Xthe whole expression (but not simply the colon); the @code{NO_EQUALS}
Xoption is also respected.@refill
X
X@noindent
XIf the option @code{MAGIC_EQUAL_SUBST} is set, any unquoted shell
Xargument of the form @code{@var{identifier}=@var{expression}} becomes
Xeligible for file expansion as described in the previous paragraph.
XQuoting the first @code{=} also inhibits this.@refill
X
X@node Process Substitution, Parameter Expansion, Filename Expansion, Expansion
X@section Process Substitution
X@cindex process substitution
X@cindex substitution, process
X
X@noindent
XEach command argument of the form @code{<(@var{list})},
X@code{>(@var{list})} or @code{=(@var{list})} is subject to process
Xsubstitution.  In the case of the @code{<} and @code{>} forms, the shell
Xwill run process @var{list} asynchronously, connected to a named pipe
X(FIFO).  The name of this pipe will become the argument to the command.
XIf the form with @code{>} is selected then writing to this file will
Xprovide input for @var{list}.  If @code{<} is used, then the file passed
Xas an argument will be a named pipe connected to the output of the
X@var{list} process.  For example,@refill
X
X@code{paste <(cut -f1 @var{file1}) <(cut -f3 @var{file2}) | tee >(@var{process1}) >(@var{process2}) >/dev/null}
X
X@noindent
X@code{cut}s fields 1 and 3 from the files @var{file1} and @var{file2}
Xrespectively, @code{paste}s the results together, and sends it to the
Xprocesses @var{process1} and @var{process2}.  Note that the file, which
Xis passed as an argument to the command, is a system pipe so programs
Xthat expect to @code{lseek(2)} on the file will not work.  Also note
Xthat the previous example can be more compactly and efficiently written
Xas:@refill
X
X@code{paste <(cut -f1 @var{file1}) <(cut -f3 @var{file2}) >>(@var{process1}) >>(@var{process2})}
X
X@noindent
XThe shell uses pipes instead of FIFOs to implement the latter two
Xprocess substitutions in the above example.
X
X@cindex temporary files
X@cindex files, temporary
X@noindent
XIf @code{=} is used, then the file passed as an argument will be the name
Xof a temporary file containing the output of the @var{list} process.
XThis may be used instead of the @code{<} form for a program that expects
Xto @code{lseek(2)} on the input file.@refill
X
X@node Parameter Expansion, Command Substitution, Process Substitution, Expansion
X@section Parameter Expansion
X@cindex parameter expansion
X@cindex expansion, parameter
X
X@noindent
XThe character @code{$} is used to introduce parameter expansions.
X@xref{Parameters}, for a description of parameters.@refill
X
X@table @code
X@item $@{@var{name}@}
XThe value, if any, of the parameter @var{name} is substituted.  The
Xbraces are required if @var{name} is followed by a letter, digit, or
Xunderscore that is not to be interpreted as part of its name.  If
X@var{name} is an array parameter, then the values of each element of
X@var{name} is substituted, one element per word.  Otherwise, the
Xexpansion results in one word only; no word splitting is done on the
Xresult.@refill
X
X@item $@{+@var{name}@}
XIf @var{name} is the name of a set parameter, then substitute 1,
Xotherwise substitute 0.@refill
X
X@item $@{@var{name}:-@var{word}@}
XIf @var{name} is set and is non-null then substitute its value;
Xotherwise substitute @var{word}.@refill
X
X@item $@{@var{name}:=@var{word}@}
XIf @var{name} is unset or is null then set it to @var{word}; the value
Xof the parameter is then substituted.@refill
X
X@item $@{@var{name}:?@var{word}@}
XIf @var{name} is set and is non-null, then substitute its value;
Xotherwise, print @var{word} and exit from the shell.  If @var{word} is
Xomitted, then a standard message is printed.@refill
X
X@item $@{@var{name}:+@var{word}@}
XIf @var{name} is set and is non-null then substitute @var{word};
Xotherwise substitute nothing.@refill
X
X@item $@{@var{name}#@var{pattern}@}
X@itemx $@{@var{name}##@var{pattern}@}
XIf the @var{pattern} matches the beginning of the value of @var{name},
Xthen substitute the value of @var{name} with the matched portion
Xdeleted; otherwise, just substitute the value of @var{name}.  In the
Xfirst form, the smallest matching pattern is preferred; in the second
Xform, the largest matching pattern is preferred.@refill
X
X@item $@{@var{name}%@var{pattern}@}
X@itemx $@{@var{name}%%@var{pattern}@}
XIf the @var{pattern} matches the end of the value of @var{name}, then
Xsubstitute the value of @var{name} with the matched portion deleted;
Xotherwise, just substitute the value of @var{name}.  In the first form,
Xthe smallest matching pattern is preferred; in the second form, the
Xlargest matching pattern is preferred.@refill
X
X@item $@{#@var{spec}@}
XIf @var{spec} is one of the above substitutions, substitute the length
Xin characters of the result instead of the result itself.  If @var{spec}
Xis an array expression, substitute the number of elements of the
Xresult.@refill
X
X@cindex rc, array expansion style
X@cindex array expansion, rc style
X@pindex RC_EXPAND_PARAM, use of
X@item $@{^@var{spec}@}
XToggle the value of the @code{RC_EXPAND_PARAM} option for the evaluation
Xof @var{spec}.  When this option is set, array expansions of the form
X@samp{foo$@{xx@}bar}, where the parameter @samp{xx} is set to @samp{(a b
Xc)}, are substituted with @samp{fooabar foobbar foocbar} instead of the
Xdefault @samp{fooa b cbar}.@refill
X
X@cindex word splitting, sh style
X@cindex sh, word splitting style
X@pindex SH_WORD_SPLIT, use of
X@vindex IFS, use of
X@item $@{=@var{spec}@}
XToggle the value of the @code{SH_WORD_SPLIT} option for the evaluation
Xof @var{spec}.  When this option is set, parameter values are split into
Xseparate words using @code{IFS} as a delimiter before substitution.
XThis is done by default in most other shells.@refill
X
X@cindex csh, tilde expansion
X@cindex tilde expansion, csh
X@pindex CSH_JUNKIE_LOOPS
X@item $@{~@var{spec}@}
XToggle the value of the @code{GLOB_SUBST} option for the evaluation of
X@var{spec}.  When this option is set, any pattern characters resulting
Xfrom the substitution become eligible for file expansion and filename
Xgeneration.@refill
X@end table
X
X@noindent
XIf the colon is omitted from one of the above expressions containing a
Xcolon, then the shell only checks whether @var{name} is set or not, not
Xwhether it is null.@refill
X
X@noindent
XIf the opening brace is directly followed by an opening parenthesis
Xthe string up to the matching closing parenthesis will be taken as a
Xlist of flags.  Where arguments are valid, any character, or the
Xmatching pairs @code{(@dots{})}, @code{@{@dots{}@}}, @code{[@dots{}]},
Xor @code{<@dots{}>}, may be used in place of the colon as delimiters.
XThe following flags are supported:
X
X@table @code
X@item o
XSort the resulting words in ascending order.
X
X@item O
XSort the resulting words in descending order.
X
X@item i
XWith @code{o} or @code{O}, makes the sort case-insensitive.
X
X@item L
XConverts all letters in the result to lowercase.
X
X@item U
XConverts all letters in the result to uppercase.
X
X@item C
XCapitalizes the resulting words
X
X@item c
XWith @code{$@{#@var{name}@}}, count the total number of characters in an
Xarray, as if the elements were concatenated with spaces between
Xthem.@refill
X
X@item w
XWith @code{$@{#@var{name}@}}, count words in arrays or strings; the
X@code{s} flag may be used to set a word delimiter.@refill
X
X@item l:@var{expr}::@var{string1}::@var{string2}:
XPad the resulting words on the left.  Each word will be truncated if
Xrequired and placed in a field @var{expr} characters wide.  The space to
Xthe left will be filled with @var{string1} (concatenated as often as
Xneeded), or spaces if @var{string1} is not given.  If both @var{string1}
Xand @var{string2} are given, this string will be placed exactly once
Xdirectly to the left of the resulting word.@refill
X
X@item r:@var{expr}::@var{string1}::@var{string2}:
XAs @code{l}, but pad the words on the right.
X
X@item j:@var{string}:
XJoin the words or arrays together using @var{string} as a separator.
XNote that this occurs before word splitting by the @code{SH_WORD_SPLIT}
Xoption.@refill
X
X@item s:@var{string}:
XForce word splitting (see the option @code{SH_WORD_SPLIT}) at the
Xseparator @var{string}.  Splitting only occurs in places where an array
Xvalue is valid.
X
X@item S
X(This and all remaining flags are used with the
X@code{$@{@dots{}#@dots{}@}} and @code{$@{@dots{}%@dots{}@}} forms).
XSearch substrings as well as beginnings or ends of strings.@refill
X
X@item I:@var{expr}:
XSearch the @var{expr}'th match (where @var{expr} evaluates to a number).
X
X@item M
XInclude the matched portion in the result.
X
X@item R
XInclude the unmatched portion in the result (the @var{r}est).
X
X@item B
XInclude the index of the beginning of the match in the result.
X
X@item E
XInclude the index of the end of the match in the result.
X
X@item N
XInclude the length of the match in the result.
X@end table
X
X@node Command Substitution, Arithmetic Expansion, Parameter Expansion, Expansion
X@section Command Substitution
X@cindex command substitution
X@cindex substitution, command
X
X@vindex IFS, use of
X@noindent
XA command enclosed in parentheses preceded by a dollar sign, like so:
X@code{$(@dots{})} or quoted with grave accents: @code{`@dots{}`} is
Xreplaced with its standard output.  If the substitution is not enclosed
Xin double quotes, the output is broken into words using the @code{IFS}
Xparameter.  The substitution @code{$(cat foo)} may be replaced by the
Xequivalent but faster @code{$(<foo)}.  In either case, if the option
X@code{GLOB_SUBST} is set the output is eligible for filename
Xgeneration.@refill
X
X@node Arithmetic Expansion, Brace Expansion, Command Substitution, Expansion
X@section Arithmetic Expansion
X@cindex arithmetic expansion
X@cindex expansion, arithmetic
X
X@noindent
XA string of the form @code{$[@var{exp}]} is substituted with the value
Xof the arithmetic expression @var{exp}.  @var{exp} is treated as if it
Xwere within single quotes.  @xref{Arithmetic Evaluation}.@refill
X
X@node Brace Expansion, Filename Generation, Arithmetic Expansion, Expansion
X@section Brace Expansion
X@cindex brace expansion
X@cindex expansion, brace
X
X@noindent
XA string of the form @samp{foo@{xx,yy,zz@}bar} is expanded to the
Xindividual words @samp{fooxxbar}, @*@samp{fooyybar}, and @samp{foozzbar}.
XLeft-to-right order is preserved.  This construct may be nested.
XMalformed brace expansion expressions, including expressions without a
Xcomma, are left unchanged by the shell.@refill
X
X@noindent
XAn expression of the form @code{@{x-y@}}, where @code{x} and @code{y}
Xare single characters, is expanded to every character between @code{x}
Xand @code{y}, inclusive.@refill
X
X@node Filename Generation,  , Brace Expansion, Expansion
X@section Filename Generation
X@cindex filename generation
X
X@cindex globbing
X@pindex NO_GLOB, use of
X@pindex EXTENDED_GLOB, use of
X@pindex NULL_GLOB, use of
X@pindex NO_NOMATCH, use of
X@pindex GLOB_DOTS, use of
X@noindent
XIf a word contains an unquoted instance of one of the characters
X@code{*}, @code{|}, @code{<}, @code{[}, or @code{?}, it is regarded as a
Xpattern for filename generation, unless the @code{NO_GLOB} option is
Xset.  If the @code{EXTENDED_GLOB} option is set, the @code{^} and
X@code{#} characters also denote a pattern; otherwise (except for an
Xinitial @code{~}, @xref{Filename Expansion}) they are not
Xtreated specially by the shell.  The word is replaced with a list of
Xsorted filenames that match the pattern.  If no matching pattern is
Xfound, the shell gives an error message, unless the @code{NULL_GLOB}
Xoption is set, in which case the word is deleted; or unless the
X@code{NO_NOMATCH} option is set, in which case the word is left
Xunchanged.  In filename generation, the character @code{/} must be
Xmatched explicitly; also, a @code{.} must be matched explicitly at the
Xbeginning of a pattern or after a @code{/}, unless the @code{GLOB_DOTS}
Xoption is set.  No filename generation pattern matches the files
X@file{.} or @file{..}.  In other instances of pattern matching, the
X@code{/} and @code{.} are not treated specially.@refill
X
X@table @code
X@item *
XMatches any string, including the null string.
X
X@item ?
XMatches any character.
X
X@item [@dots{}]
XMatches any of the enclosed characters.
X
X@item [^@dots{}]
XMatches any character except the enclosed characters.  @code{!@dots{}}
Xis the same.
X
X@item <x-y>
XMatches any number in the range @code{x} to @code{y}, inclusive.  If
X@code{x} is omitted, the number must be less than or equal to @code{y}.
XIf @code{y} is omitted, the number must be greater than or equal to
X@code{x}.  A pattern of the form @code{<->} or simply @code{<>} matches
Xany number.@refill
X
X@item ^x
XMatches anything except the pattern @code{x}.
X
X@item x|y
XMatches either @code{x} or @code{y}.
X
X@item x#
XMatches zero or more occurrences of the pattern @code{x}.
X
X@item x##
XMatches one or more occurrences of the pattern @code{x}.
X@end table
X
X@noindent
XParentheses may be used for grouping.  Note that the @code{|} character
Xmust be within parentheses, so that the lexical analyzer does not think
Xit is a pipe character.  Also note that @code{/} has a higher precedence
Xthan @code{^}; that is:@refill
X
X@code{ls ^foo/bar}
X
X@noindent
Xwill search directories in @file{.} except @file{./foo} for a file named
X@file{bar}.@refill
X
X@noindent
XA pathname component of the form @code{(@var{foo}/)#} matches a path
Xconsisting of zero or more directories matching the pattern @var{foo}.
XAs a shorthand, @code{**/} is equivalent to @code{(*/)#}.  Thus:@refill
X
X@code{ls (*/)#bar}
X
X@noindent
Xor
X
X@code{ls **/bar}
X
X@noindent
Xdoes a recursive directory search for files named @file{bar}.
X
X@cindex exclusion, globbing
X@cindex globbing, excluding patterns
X@noindent
XIf used for filename generation, a pattern may contain an exclusion
Xspecifier.  Such patterns are of the form @code{@var{pat1}~@var{pat2}}.
XThis pattern will generate all files matching @var{pat1}, but which do
Xnot match @var{pat2}.  For example, @samp{*.c~lex.c} will match all
Xfiles ending in @file{.c}, except the file @file{lex.c}.  This may
Xappear inside parentheses.  Note that @code{~} has higher precedence
Xthan @code{|}, so that @samp{pat1|pat2~pat3} matches any time that
X@var{pat1} matches, or if @var{pat2} matches while @var{pat3} does not.
XNote also that any @code{/} characters are not treated specially in the
Xexclusion specifier, so that a @code{*} will match multiple path
Xsegments if they appear in the pattern to the left of the
X@code{~}.@refill 
X
X@cindex qualifiers, globbing
X@cindex globbing, qualifiers
X@noindent
XPatterns used for filename generation may also end in a list of
Xqualifiers enclosed in parentheses.  The qualifiers specify which
Xfilenames that otherwise match the given pattern will be inserted in the
Xargument list.  A qualifier may be any one of the following:
X
X@table @code
X@item /
XDirectories
X
X@item .
XPlain files
X
X@item @@
XSymbolic links
X
X@item =
XSockets
X
X@item p
XNamed pipes (FIFOs)
X
X@item *
XExecutable plain files (0100)
X
X@item %
XDevice files (character or block special)
X
X@item %b
XBlock special files
X
X@item %c
XCharacter special files
X
X@item r
XReadable files (0400)
X
X@item w
XWritable files (0200)
X
X@item x
XExecutable files (0100)
X
X@item R
XWorld-readable files (0004)
X
X@item W
XWorld-writable files (0002)
X
X@item X
XWorld-executable files (0001)
X
X@item s
XSetuid files (04000)
X
X@item S
XSetgid files (02000)
X
X@item d@var{dev}
XFiles on the device @var{dev}
X
X@item l[+-]@var{ct}
XFiles having a link count less than (@code{-}), more than (@code{+}), or
Xequal to @var{ct}.@refill
X
X@item U
XFiles owned by the effective user id.
X
X@item G
XFiles owned by the effective group id.
X
X@item u@var{id}
XFiles owned by user @var{id} if @var{id} is a number.  If not, the
Xcharacter after the @code{u} will be used as a separator and the string
Xbetween it and the next matching separator (@code{(}, @code{[},
X@code{@{}, and @code{<} match @code{)}, @code{]}, @code{@}}, and
X@code{>} respectively; any other character matches itself) will be taken
Xas a user name and translated into the corresponding user id (e.g.@:
X@code{u:foo:} or @code{u[foo]} for user @code{foo}).@refill
X
X@item g@var{id}
XLike @code{u@var{id}} but with group ids or names.
X
X@item a[+-]@var{n}
XFiles accessed within last @var{n} days (@code{-}), more than @var{n}
Xdays ago (@code{+}), or exactly @var{n} days ago.@refill
X
X@item m[+-]@var{n}
XFiles modified within last @var{n} days (@code{-}), more than @var{n}
Xdays ago (@code{+}), or exactly @var{n} days ago.@refill
X
X@item c[+-]@var{n}
XFiles whose inode changed within last @var{n} days (@code{-}), more than
X@var{n} days ago (@code{+}), or exactly @var{n} days ago.  If any of
Xthe flags @code{a}, @code{m}, or @code{c} is directly followed by a @code{M},
X@code{w}, @code{h}, or @code{m} (e.g.@: @code{mh+5}) the check is
Xperformed in units of months (of 30 days), weeks, hours, or minutes
Xrespectively.@refill
X
X@item L[+-]@var{n}
XFiles less than @var{n} bytes (@code{-}), more than @var{n} bytes
X(@code{+}), or exactly @var{n} bytes in length.@refill
X
X@item ^
XNegates all qualifiers following it.
X
X@item -
XToggles between making the qualifiers work on symbolic links (the
Xdefault), and the files they point to.
X
X@item M
X@pindex MARK_DIRS, setting in pattern
XSets the @code{MARK_DIRS} option for the current pattern.
X
X@item T
XAppends a trailing qualifier mark to the file names, analogous to the
X@code{LIST_TYPES}, for the current pattern (overrides @code{M}).@refill
X
X@item N
X@pindex NULL_GLOB, setting in pattern
XSets the @code{NULL_GLOB} option for the current pattern.
X
X@item D
X@pindex GLOB_DOTS, setting in pattern
XSets the @code{GLOB_DOTS} option for the current pattern.
X@end table
X
X@noindent
XMore than one of these lists can be combined, separated by commas; the
Xwhole list matches if at least one of the sublists matches (they are
Xor'ed, the qualifiers in the sublists are and'ed).  A @code{/} at the
Xend of a pattern is equivalent to @code{(/)}.@refill
X
X@noindent
XIf a @code{:} appears in a qualifier list, the remainder of the
Xexpression in parentheses is interpreted as a modifier
X(@xref{Modifiers}).  Note that each modifier must be introduced by a
Xseparate @code{:}.  Note also that the result after modification does
Xnot have to be an existing file.  The name of any existing file can be
Xfollowed by a modifier of the form @code{(:@dots{})} even if no filename
Xgeneration is performed.@refill
X
X@noindent
XThus:
X
X@code{ls *(-/)}
X
X@noindent
Xlists all directories and symbolic links that point to directories, and
X
X@code{ls *(%W)}
X
X@noindent
Xlists all world-writable device files in the current directory, and
X
X@code{ls *(W,X)}
X
X@noindent
Xlists all files in the current directory that are world-writable or
Xworld-executable, and
X
X@code{echo /tmp/foo*(u0^@@:t)}
X
X@noindent
Xoutputs the basename of all root-owned files beginning with the string
X@samp{foo} in @file{/tmp}, ignoring symlinks, and@refill
X
X@code{ls *.*~(lex|parse).[ch](^D^l1)}
X
X@noindent
Xlists all files having a link count of one whose names contain a dot
X(but not those starting with a dot, since @code{GLOB_DOTS} is explicitly
Xswitched off) except for @file{lex.c}, @file{lex.h}, @file{parse.c}, and
X@file{parse.h}.@refill
X
X@node Redirection, Command Execution, Expansion, Top
X@chapter Redirection
X@cindex redirection
X
X@cindex file descriptors
X@cindex descriptors, file
X@noindent
XBefore a command is executed, its input and output may be redirected.
XThe following may appear anywhere in a simple command or may precede or
Xfollow a complex command.  Substitution occurs before @var{word} is used
Xexcept as noted below.  If the result of substitution on @var{word}
Xproduces more than one filename, redirection occurs for each separate
Xfilename in turn.@refill
X
X@table @code
X@item <@var{word}
XOpen file @var{word} as standard input.
X
X@item >@var{word}
X@pindex NO_CLOBBER, use of
XOpen file @var{word} as standard output.  If the file does not exist
Xthen it is created.  If the file exists, and the @code{NO_CLOBBER}
Xoption is set, this causes an error; otherwise, it is truncated to zero
Xlength.@refill
X
X@item >!@var{word}
XSame as @code{>}, except that the file is truncated to zero length if it
Xexists, even if @code{NO_CLOBBER} is set.@refill
X
X@item >>@var{word}
XOpen file @var{word} as standard output.  If the file exists then output
Xis appended to it.  If the file does not exist, and the
X@code{NO_CLOBBER} option is set, this causes an error; otherwise, the
Xfile is created.@refill
X
X@item >>!@var{word}
XSame as @code{>>}, except that the file is created if it does not exist,
Xeven if @code{NO_CLOBBER} is set.@refill
X
X@item <<[-]@var{word}
XThe shell input is read up to a line that is the same as @var{word}, or
Xto an end-of-file.  No parameter substitution, command substitution or
Xfilename generation is performed on @var{word}.  The resulting document,
Xcalled a @dfn{here-document}, becomes the standard input.  If any
Xcharacter of @var{word} is quoted with single or double quotes or a
X@code{\}, no interpretation is placed upon the characters of the
Xdocument.  Otherwise, parameter and command substitution occurs,
X@code{\} followed by a newline is removed, and @code{\} must be used to
Xquote the characters @code{\}, @code{$}, @code{`}, and the first
Xcharacter of @var{word}.  If @code{<<-} is used, then all leading tabs
Xare stripped from @var{word} and from the document.@refill
X
X@item <<<@var{word}
XOpen a file containing @var{word}, after expansion, as standard input.
X
X@item <&@var{digit}
XThe standard input is duplicated from file descriptor @var{digit} (see
X@code{dup(2)}).  Similarly for standard output using
X@code{>&@var{digit}}.@refill
X
X@item >&@var{word}
XSame as @code{>@var{word} 2>&1}.
X
X@item >>&@var{word}
XSame as @code{>>@var{word} 2>&1}.
X
X@item <&-
XClose the standard input.
X
X@item >&-
XClose the standard output.
X
X@item <&p
XThe input from the coprocess is moved to the standard input.
X
X@item >&p
XThe output to the coprocess is moved to the standard output.
X@end table
X
X@noindent
XIf one of the above is preceded by a digit, then the file descriptor
Xreferred to is that specified by the digit (instead of the default 0 or
X1).  The order in which redirections are specified is significant.  The
Xshell evaluates each redirection in terms of the (@var{file descriptor},
X@var{file}) association at the time of evaluation.  For example:@refill
X
X@code{@dots{} 1>@var{fname} 2>&1}
X
X@noindent
Xfirst associates file descriptor 1 with file @var{fname}.  It then
Xassociates file descriptor 2 with the file associated with file
Xdescriptor 1 (that is, @var{fname}).  If the order of redirections were
Xreversed, file descriptor 2 would be associated with the terminal
X(assuming file descriptor 1 had been) and then file descriptor 1 would
Xbe associated with file @var{fname}.@refill
X
X@noindent
XIf the user tries to open a file descriptor for writing more than once,
Xthe shell opens the file descriptor as a pipe to a process that copies
Xits input to all the specified outputs, similar to @code{tee(1)}.  Thus:
X
X@code{date >foo >bar}
X
X@noindent
Xwrites the date to two files, named @file{foo} and @file{bar}.  Note
Xthat a pipe is an implicit indirection; thus@refill
X
X@code{date >foo | cat}
X
X@noindent
Xwrites the date to the file @file{foo}, and also pipes it to @code{cat}.
X
X@noindent
XIf the user tries to open a file descriptor for reading more than once,
Xthe shell opens the file descriptor as a pipe to a process that copies
Xall the specified inputs to its output in the order specified, similar
Xto @code{cat(1)}.  Thus
X
X@code{sort <foo <fubar}
X
X@noindent
Xor even
X
X@code{sort <f@{oo,ubar@}}
X
X@noindent
Xis equivalent to @samp{cat foo fubar | sort}.  Similarly, you can do
X
X@code{echo exit 0 >> *.sh}
X
XNote that a pipe is an implicit indirection; thus
X
X@code{cat bar | sort <foo}
X
X@noindent
Xis equivalent to @samp{cat bar foo | sort} (note the order of the inputs).
X
X@noindent
XIf a simple command consists of one or more redirection operators and
Xzero or more parameter assignments, but no command name, the command
X@code{cat} is assumed.  Thus
X
X@code{< file}
X
X@noindent
Xprints the contents of @code{file}.
X
X@noindent
XIf a command is followed by @code{&} and job control is not active, then
Xthe default standard input for the command is the empty file
X@file{/dev/null}.  Otherwise, the environment for the execution of a
Xcommand contains the file descriptors of the invoking shell as modified
Xby input/output specifications.@refill
X
X@node Command Execution, Functions, Redirection, Top
X@chapter Command Execution
X@cindex command execution
X@cindex execution, of commands
X
X@noindent
XIf a command name contains no slashes, the shell attempts to locate it.
XIf there exists a shell function by that name, the function is invoked
Xas described below (@pxref{Functions}).  If there exists a shell builtin
Xby that name, the builtin is invoked.
X
X@vindex path, use of
X@noindent
XOtherwise, the shell searches each element of @code{path} for a directory
Xcontaining an executable file by that name.  If the search is
Xunsuccessful, the shell prints an error message and returns a nonzero
Xexit status.
X
X@noindent
XIf execution fails because the file is not in executable format, and the
Xfile is not a directory, it is assumed to be a shell script.
X@code{/bin/sh} is spawned to execute it.  If the program is a file
Xbeginning with @code{#!}, the remainder of the first line specifies an
Xinterpreter for the program.  The shell will execute the specified
Xinterpreter on operating systems that do not handle this executable
Xformat in the kernel.@refill
X
X@node Functions, Jobs & Signals, Command Execution, Top
X@chapter Functions
X@cindex functions
X
X@findex function
X@noindent
XThe @code{function} reserved word is used to define shell functions.
XShell functions are read in and stored internally.  Alias names are
Xresolved when the function is read.  Functions are executed like
Xcommands with the arguments passed as positional parameters.@refill
X
X@noindent
XFunctions execute in the same process as the caller and share all files
Xand the present working directory with the caller.  A trap on
X@code{EXIT} set inside a function is executed after the function
Xcompletes in the environment of the caller.@refill
X
X@findex return, use of
X@noindent
XThe @code{return} builtin is used to return from function calls.
X
X@findex functions, use of
X@findex unfunction, use of
X@noindent
XFunction identifiers can be listed with the @code{functions} builtin.
XFunctions can be undefined with the @code{unfunction} builtin.@refill
X
X@noindent
XThe following functions, if defined, have special meaning to the shell:
X
X@table @code
X@findex chpwd
X@item chpwd
XExecuted whenever the current working directory is changed.
X
X@findex precmd
X@item precmd
XExecuted before each prompt.
X
X@vindex PERIOD
X@findex periodic
X@item periodic
XIf the parameter @code{PERIOD} is set, this function is executed every
X@code{PERIOD} seconds, just before a prompt.@refill
X
X@findex TRAPERR
X@findex TRAPDEBUG
X@findex TRAPEXIT
X@cindex signals, trapping
X@cindex trapping signals
X@item TRAP@var{xxx}
XIf defined and non-null, this function will be executed whenever the
Xshell catches a signal @code{SIG@var{xxx}}, where @var{xxx} is a signal
Xname as specified for the @code{kill} builtin (@pxref{Shell Builtin
XCommands}).  In addition, @code{TRAPZERR} is executed whenever a command
Xhas a non-zero exit status, @code{TRAPDEBUG} is executed after each
Xcommand, and @code{TRAPEXIT} is executed when the shell exits, or when
Xthe current function exits if defined inside a function.  If a function
Xof this form is defined and null, the shell and processes spawned by it
Xwill ignore @code{SIG@var{xxx}}.@refill
X@end table
X
X@node Jobs & Signals, History, Functions, Top
X@chapter Jobs & Signals
X@cindex jobs
X
X@findex jobs, use of
X@pindex MONITOR, use of
X@noindent
XIf the @code{MONITOR} option is set, an interactive shell associates a
X@dfn{job} with each pipeline.  It keeps a table of current jobs,
Xprinted by the @code{jobs} command, and assigns them small integer
Xnumbers.  When a job is started asynchronously with @code{&}, the shell
Xprints a line which looks like:@refill
X
X@code{[1] 1234}
X
X@noindent
Xindicating that the job which was started asynchronously was job number
X1 and had one (top-level) process, whose process id was 1234.
X
X@kindex CTRL-Z
X@cindex jobs, suspending
X@cindex suspending jobs
X@findex fg, use of
X@findex bg, use of
X@noindent
XIf you are running a job and wish to do something else you may hit the
Xkey @code{^Z} (control-Z) which sends a @code{TSTP} signal to the current
Xjob.  The shell will then normally indicate that the job has been
X@dfn{suspended}, and print another prompt.  You can then manipulate the
Xstate of this job, putting it into the background with the @code{bg}
Xcommand, or run some other commands and then eventually bring the job
Xback into the foreground with the foreground command @code{fg}.  A
X@code{^Z} takes effect immediately and is like an interrupt in that
Xpending output and unread input are discarded when it is typed.@refill
X
X@cindex jobs, background, IO
X@cindex background jobs, IO
X@noindent
XA job being run in the background will suspend if it tries to read from
Xthe terminal.  Background jobs are normally allowed to produce output,
Xbut this can be disabled by giving the command @code{stty tostop}.  If
Xyou set this tty option, then background jobs will suspend when they try
Xto produce output, just as they do when they try to read input.@refill
X
X@cindex jobs, referring to
X@cindex referring to jobs
X@noindent
XThere are several ways to refer to jobs in the shell.  A job can be
Xreferred to by the process id of any process of the job or by one of the
Xfollowing:
X
X@table @code
X@item %@var{number}
XThe job with the given number.
X
X@item %@var{string}
XAny job whose command line begins with @var{string}.
X
X@item %?@var{string}
XAny job whose command line contains @var{string}.
X
X@item %%
XCurrent job.
X
X@item %+
XEquivalent to @code{%%}.
X
X@item %-
XPrevious job.
X@end table
X
X@findex notify, use of
X@noindent
XThe shell learns immediately whenever a process changes state.  It
Xnormally informs you whenever a job becomes blocked so that no further
Xprogress is possible.  If @code{notify} is not set, it waits until just
Xbefore it prints a prompt before it informs you.@refill
X
X@noindent
XWhen the monitor mode is on, each background job that completes triggers
Xany trap set for @code{CHLD}.
X
X@findex disown, use of
X@cindex jobs, disowning
X@cindex disowning jobs
X@noindent
XWhen you try to leave the shell while jobs are running or suspended, you
Xwill be warned that @samp{You have suspended (running) jobs}.  You may
Xuse the @code{jobs} command to see what they are.  If you do this or
Ximmediately try to exit again, the shell will not warn you a second
Xtime; the suspended jobs will be terminated, and the running jobs will
Xbe sent a @code{SIGHUP} signal.  To avoid having the shell terminate the
Xrunning jobs, either use the @code{nohup(1)} command or the
X@code{disown} builtin (@pxref{Shell Builtin Commands}).@refill
X
X@cindex signals
X@noindent
XThe @code{INT} and @code{QUIT} signals for an invoked command are
Xignored if the command is followed by @code{&} and the job @code{monitor}
Xoption is not active.  Otherwise, signals have the values inherited by
Xthe shell from its parent (but @xref{Functions}, for the
X@code{TRAP@var{xxx}} special functions).@refill
X
X@node History, Arithmetic Evaluation, Jobs & Signals, Top
X@chapter History
X@cindex history
X
X@vindex HISTSIZE, use of
X@noindent
XHistory substitution allows you to use words from previous command lines
Xin the command line you are typing.  This simplifies spelling
Xcorrections and the repetition of complicated commands or arguments.
XCommand lines are saved in the history list, the size of which is
Xcontrolled by the @code{HISTSIZE} variable.  The most recent command is
Xretained in any case.  A history substitution begins with a @code{!} and
Xmay occur anywhere on the command line; history substitutions do not
Xnest.  The @code{!} can be escaped with @code{\} to suppress its special
Xmeaning.  Single or double quotes will @emph{not} work for this.@refill
X
X@noindent
XInput lines containing history substitutions are echoed on the terminal
Xafter being expanded, but before any other substitutions take place or
Xthe command gets executed.
X
X@menu
X* Event Designators::		
X* Word Designators::		
X* Modifiers::			
X@end menu
X
X@node Event Designators, Word Designators,  , History
X@section Event Designators
X@cindex history event designators
X@cindex event designators, history
X
X@noindent
XAn event designator is a reference to a command-line entry in the
Xhistory list.
X
X@table @code
X@item !
XStart a history substitution, except when followed by a blank, newline,
X@code{=}, or @code{(}.
X
X@item !!
XRefer to the previous command.  By itself, this substitution repeats the
Xprevious command.
X
X@item !n
XRefer to command line @var{n}.
X
X@item !-n
XRefer to the current command line minus @var{n}.
X
X@item !str
XRefer to the most recent command starting with @var{str}.
X
X@item !?@var{str}[?]
XRefer to the most recent command containing @var{str}.
X
X@item !#
XRefer to the current command line typed in so far.
X
X@item !@{@dots{}@}
XInsulate a history reference from adjacent characters (if necessary).
X@end table
X
X@node Word Designators, Modifiers, Event Designators, History
X@section Word Designators
X@cindex history word designators
X@cindex word designators, history
X
X@noindent
XA word designator indicates which word or words of a given command line
Xwill be included in a history reference.  A @code{:} separates the event
Xspecification from the word designator.  It can be omitted if the word
Xdesignator begins with a @code{,}, @code{$}, @code{*}, @code{-} or
X@code{%}.  Word designators include:@refill
X
X@table @code
X@item 0
XThe first input word (command).
X
X@item @var{n}
XThe @var{n}'th argument.
X
X@item ^
XThe first argument, that is, @code{1}.
X
X@item $
XThe last argument.
X
X@item %
XThe word matched by (the most recent) @code{?@var{str}} search.
X
X@item @var{x}-@var{y}
XA range of words;  @code{-@var{y}} abbreviates @code{0-@var{y}}.
X
X@item *
XAll the arguments, or a null value if there is just one word in the
Xevent.
X
X@item @var{x}*
XAbbreviates @code{@var{x}-$}.
X
X@item @var{x}
XLike @code{@var{x}*} but omitting word @code{$}.
X@end table
X
X@noindent
XNote that a @code{%} word designator will only work when used as
X@code{!%}, @code{!:%}, or @code{!?@var{str}?:%}, and only when used
Xafter a @code{?!} substitution.  Anything else will result in an error,
Xalthough the error may not be the most obvious one.@refill
X
X@node Modifiers,  , Word Designators, History
X@section Modifiers
X@cindex modifiers, history
X@cindex history modifiers
X
X@noindent
XAfter the optional word designator, you can add a sequence of one or
Xmore of the following modifiers, each preceded by a @code{:}.  These
Xmodifiers also work on the result of filename and parameter
Xexpansion.@refill
X
X@table @code
X@item h
XRemove a trailing pathname component, leaving the head.
X
X@item r
XRemove a trailing suffix of the form @code{.@var{xxx}}, leaving the
Xbasename.@refill
X
X@item e
XRemove all but the suffix.
X
X@item t
XRemove all leading pathname components, leaving the tail.
X
X@item &
XRepeat the previous substitution.
X
X@item g
XApply the change to the first occurrence of a match in each word, by
Xprefixing the above (for example, @code{g&}).
X
X@item p
XPrint the new command but do not execute it.
X
X@item q
XQuote the substituted words, escaping further substitutions.
X
X@item x
XLike @code{q}, but break into words at each blank.
X
X@item l
XConvert the words to all lowercase.
X
X@item u
XConvert the words to all uppercase.
X
X@item f
XRepeats the immediately-following (without a colon) modifier until the
Xresulting word doesn't change any more.  This modifier and the following
Xfour only work with parameter and filename expansion.
X
X@item F:@var{expr}:
XLike @code{f}, but repeats only @var{n} times if the expression
X@var{expr} evaluates to @var{n}.  Any character can be used instead of
Xthe @code{:}, with the exception that if @code{(}, @code{[}, or
X@code{@{} is used as the opening delimiter, the closing delimiter must
Xbe @code{)}, @code{]}, or @code{@}} respectively.@refill
X
X@item w
XMakes the immediately-following modifier work on each word in the
Xstring.
X
X@item W:@var{sep}:
XLike @code{w}, but words are considered to be the parts of the string
Xthat are separated by @var{sep}.  Delimiters are handled as in @code{F}
Xabove.@refill
X
X@item s/@var{l}/@var{r}[/]
XSubstitute @var{r} for @var{l}.
X
X@noindent
XUnless preceded by a @code{g}, the substitution is done only for the
Xfirst string that matches @var{l}.@refill
X
X@noindent
XThe left-hand side of substitutions are not regular expressions, but
Xcharacter strings.  Any character can be used as the delimiter in place
Xof @code{/}.  A backslash quotes the delimiter character.  The character
X@code{&}, in the right-hand side, is replaced by the text from the
Xleft-hand side.  The @code{&} can be quoted with a backslash.  A null
X@var{l} uses the previous string either from a @var{l} or from a
Xcontextual scan string @var{s} from @code{!?@var{s}}.  You can omit the
Xrightmost delimiter if a newline immediately follows @var{r}; the
Xrightmost @code{?} in a context scan can similarly be omitted.@refill
X@end table
X
X@cindex csh, history style
X@cindex history, csh style
X@noindent
XBy default, a history reference with no event specification refers to
Xthe same line as the last history reference on that command line, unless
Xit is the first history reference in a command.  In that case, a history
Xreference with no event specification always refers to the previous
Xcommand.  However, if the option @code{CSH_JUNKIE_HISTORY} is set, then
Xa history reference with no event specification will @var{always} refer
Xto the previous command.  For example, @code{!!:1} will always refer to
Xthe first word of the previous command and @code{!!$} will always refer
Xto the last word of the previous command.  If @code{CSH_JUNKIE_HISTORY}
Xis set, then @code{!:1} and @code{!$} will function in the same manner
Xas @code{!!:1} and @code{!!$}, respectively.
XHowever, if @code{CSH_JUNKIE_HISTORY} is unset, then @code{!:1} and
X@code{!$} will refer to the first and last words respectively of the
Xlast command referenced on the current command line.  However, if they
Xare the first history reference on the command line, then they refer to
Xthe previous command.@refill
X
X@noindent
XThe character sequence @samp{^foo^bar} repeats the last command,
Xreplacing the string @samp{foo} with the string @samp{bar}.@refill
X
X@cindex history, disabling
X@cindex disabling history
X@noindent
XIf the shell encounters the character sequence @code{!"} in the input,
Xthe history mechanism is temporarily disabled until the current list is
Xfully parsed.  The @code{!"} is removed from the input, and any
Xsubsequent @code{!} characters have no special significance.@refill
X
X@findex fc, use of
X@noindent
XA less convenient but more comprehensible form of command history
Xsupport is provided by the @code{fc} builtin 
X(@pxref{Shell Builtin Commands}).
X
X@node Arithmetic Evaluation, Conditional Expressions, History, Top
X@chapter Arithmetic Evaluation
X@cindex arithmetic evaluation
X@cindex evaluation, arithmetic
X
X@noindent
XAn ability to perform integer arithmetic is provided with the builtin
X@code{let}.  Evaluations are performed using @emph{long} arithmetic.
XConstants are of the form @code{[@var{base}#]@var{n}} where @var{base}
Xis a decimal number between two and thirty-six representing the
Xarithmetic base and @var{n} is a number in that base (for example,
X@code{16#ff} is 255 in hexadecimal).  If @var{base} is omitted then base
X10 is used.  For backwards compatibility the form @code{[16]ff} is also
Xaccepted.@refill
X
X@cindex arithmetic operators
X@cindex operators, arithmetic
X@noindent
XAn arithmetic expression uses nearly the same syntax, precedence, and
Xassociativity of expressions in C.  The following operators are
Xsupported (listed in decreasing order of precedence):
X
X@table @code
X@item + - ! ~ ++ --
XUnary plus/minus, logical NOT, complement, @{pre,post@}@{in,de@}crement
X
X@item &
XLogical AND
X
X@item ^
XLogical XOR
X
X@item |
XLogical OR
X
X@item * / % **
XMultiplication, division, remainder, exponentiation
X
X@item + -
XAddition, subtraction
X
X@item << >>
XLogical shift left, shift right
X
X@item < > <= >=
XComparison
X
X@item == !=
XEquality and inequality
X
X@item &&
XBoolean AND
X
X@item || ^^
XBoolean OR, XOR
X
X@item ? :
XTernary operator
X
X@item = += -= *= /= %= &= ^= |= <<= >>= &&= ||= ^^= **=
XAssignment
X
X@item ,
XComma operator
X@end table
X
X@noindent
XThe operators @code{&&}, @code{||}, @code{&&=}, and @code{||=} are
Xshort-circuiting, and only one of the latter two expressions in a
Xternary operator is evaluated.  Note the precedence of the logical AND,
XOR, and XOR operators.@refill
X
X@noindent
XAn expression of the form @code{#\x} where @code{x} is any character
Xgives the ASCII value of this character.  An expression of the form
X@code{#foo} gives the ASCII value of the first character of the value of
Xthe parameter @code{foo}.@refill
X
X@noindent
XNamed parameters can be referenced by name within an arithmetic
Xexpression without using the parameter substitution syntax, but if it is
Xan array with a subscript the leading @code{$} is needed.
X
X@cindex parameters, integer
X@cindex integer parameters
X@findex integer, use of
X@noindent
XAn internal integer representation of a named parameter can be specified
Xwith the @code{integer} builtin.  Arithmetic evaluation is performed on
Xthe value of each assignment to a named parameter declared integer in
Xthis manner.@refill
X
X@findex let, use of
X@noindent
XSince many of the arithmetic operators require quoting, an alternative
Xform of the @code{let} command is provided.  For any command which
Xbegins with a @code{((}, all the characters until a matching @code{))}
Xare treated as a quoted expression.  More precisely, @code{(( @dots{} ))} is
Xequivalent to @code{let "@dots{}"}.@refill
X
X@node Conditional Expressions, Zsh Line Editor, Arithmetic Evaluation, Top
X@chapter Conditional Expressions
X@cindex conditional expressions
X@cindex expressions, conditional
X
X@noindent
XA @dfn{conditional expression} is used with the @code{[[} compound
Xcommand to test attributes of files and to compare strings.  Each
Xexpression can be constructed from one or more of the following unary or
Xbinary expressions:@refill
X
X@table @code
X@item -a @var{file}
XTrue if @var{file} exists.
X
X@item -b @var{file}
XTrue if @var{file} exists and is a block special file.
X
X@item -c @var{file}
XTrue if @var{file} exists and is a character special file.
X
X@item -d @var{file}
XTrue if @var{file} exists and is a directory.
X
X@item -e @var{file}
XTrue if @var{file} exists.
X
X@item -f @var{file}
XTrue if @var{file} exists and is an ordinary file.
X
X@item -g @var{file}
XTrue if @var{file} exists and has its setgid bit set.
X
X@item -h @var{file}
XTrue if @var{file} exists and is a symbolic link.
X
X@item -k @var{file}
XTrue if @var{file} exists and has its sticky bit set.
X
X@item -n @var{string}
XTrue if length of @var{string} is non-zero.
X
X@item -o @var{option}
XTrue if option named @var{option} is on.
X
X@item -p @var{file}
XTrue if @var{file} exists and is a FIFO special file or a pipe.
X
X@item -r @var{file}
XTrue if @var{file} exists and is readable by the current process.
X
X@item -s @var{file}
XTrue if @var{file} exists and has size greater than zero.
X
X@item -t @var{fd}
XTrue if file descriptor number @var{fd} is open and associated with a
Xterminal device (note: @var{fd} is not optional).@refill
X
X@item -u @var{file}
XTrue if @var{file} exists and has its setuid bit set.
X
X@item -w @var{file}
XTrue if @var{file} exists and is writable by current process.
X
X@item -x @var{file}
XTrue if @var{file} exists and is executable by current process.  If
X@var{file} exists and is a directory, then the current process has
Xpermission to search in the directory.@refill
X
X@item -z @var{string}
XTrue if length of @var{string} is zero.
X
X@item -L @var{file}
XTrue if @var{file} exists and is a symbolic link.
X
X@item -O @var{file}
XTrue if @var{file} exists and is owned by the effective user id of this
Xprocess.
X
X@item -G @var{file}
XTrue if @var{file} exists and its group matches the effective group id
Xof this process.
X
X@item -S @var{file}
XTrue if @var{file} exists and is a socket.
X
X@item @var{file1} -nt @var{file2}
XTrue if @var{file1} exists and is newer than @var{file2}.
X
X@item @var{file1} -ot @var{file2}
XTrue if @var{file1} exists and is older than @var{file2}.
X
X@item @var{file1} -ef @var{file2}
XTrue if @var{file1} and @var{file2} exist and refer to the same file.
X
X@item @var{string} = @var{pattern}
XTrue if @var{string} matches @var{pattern}.
X
X@item @var{string} != @var{pattern}
XTrue if @var{string} does not match @var{pattern}.
X
X@item @var{string1} < @var{string2}
XTrue if @var{string1} comes before @var{string2} based on ASCII value of
Xtheir characters.@refill
X
X@item @var{string1} > @var{string2}
XTrue if @var{string1} comes after @var{string2} based on ASCII value of
Xtheir characters.@refill
X
X@item @var{exp1} -eq @var{exp2}
XTrue if @var{exp1} is equal to @var{exp2}.
X
X@item @var{exp1} -ne @var{exp2}
XTrue if @var{exp1} is not equal to @var{exp2}.
X
X@item @var{exp1} -lt @var{exp2}
XTrue if @var{exp1} is less than @var{exp2}.
X
X@item @var{exp1} -gt @var{exp2}
XTrue if @var{exp1} is greater than @var{exp2}.
X
X@item @var{exp1} -le @var{exp2}
XTrue if @var{exp1} is less than or equal to @var{exp2}.
X
X@item @var{exp1} -ge @var{exp2}
XTrue if @var{exp1} is greater than or equal to @var{exp2}.
X
X@item ( @var{exp} )
XTrue if @var{exp} is true.
X
X@item ! @var{exp}
XTrue if @var{exp} is false.
X
X@item @var{exp1} && @var{exp2}
XTrue if @var{exp1} and @var{exp2} are both true.
X
X@item @var{exp1} || @var{exp2}
XTrue if either @var{exp1} or @var{exp2} is true.
X@end table
X
X@noindent
XIn each of the above expressions, if @var{file} is of the form
X@samp{/dev/fd/@var{n}}, where @var{n} is an integer, then the test is
Xapplied to the open file whose descriptor number is @var{n}, even if
Xthe underlying system does not support the @file{/dev/fd}
Xdirectory.@refill
X
X@node Zsh Line Editor, Parameters, Conditional Expressions, Top
X@chapter Zsh Line Editor
X@cindex line editor
X@cindex editor, line
X
X@pindex ZLE, use of
X@noindent
XIf the @code{ZLE} option is set (it is by default) and the shell input is
Xattached to the terminal, the user is allowed to edit command lines.@refill
X
END_OF_FILE
  if test 63392 -ne `wc -c <'zsh-2.5.0/doc/zsh.texi.A'`; then
    echo shar: \"'zsh-2.5.0/doc/zsh.texi.A'\" unpacked with wrong size!
  elif test -f 'zsh-2.5.0/doc/zsh.texi.B' && test -f 'zsh-2.5.0/doc/zsh.texi.C'; then
    echo shar: Combining  \"'zsh-2.5.0/doc/zsh.texi'\" \(190781 characters\)
    cat 'zsh-2.5.0/doc/zsh.texi.A' 'zsh-2.5.0/doc/zsh.texi.B' 'zsh-2.5.0/doc/zsh.texi.C' > 'zsh-2.5.0/doc/zsh.texi'
    if test 190781 -ne `wc -c <'zsh-2.5.0/doc/zsh.texi'`; then
      echo shar: \"'zsh-2.5.0/doc/zsh.texi'\" combined with wrong size!
    else
      rm zsh-2.5.0/doc/zsh.texi.A zsh-2.5.0/doc/zsh.texi.B zsh-2.5.0/doc/zsh.texi.C
    fi
  fi
  # end of 'zsh-2.5.0/doc/zsh.texi.A'
fi
if test -f 'zsh-2.5.0/src/zle_misc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/src/zle_misc.c'\"
else
  echo shar: Extracting \"'zsh-2.5.0/src/zle_misc.c'\" \(19757 characters\)
  sed "s/^X//" >'zsh-2.5.0/src/zle_misc.c' <<'END_OF_FILE'
X/*
X *
X * zle_misc.c - miscellaneous editor routines
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made.
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk.
X *
X */
X
X#define ZLE
X#include "zsh.h"
X
Xvoid selfinsert()
X{				/**/
X    int ncs = cs + mult;
X
X    if (complexpect && isset(AUTOPARAMKEYS)) {
X	if (complexpect == 2 && c == '}') {
X	    spaceinline(1);
X	    line[cs - 1] = c;
X	    line[cs++] = ' ';
X	    return;
X	} else if (complexpect == 1 &&
X		   (c == '[' || c == ':' || c == '#' || c == '%' ||
X		    c == '-' || c == '?' || c == '+')) {
X	    line[cs - 1] = c;
X	    return;
X	}
X    }
X    if (mult < 0) {
X	mult = -mult;
X	ncs = cs;
X    }
X    if (insmode || ll == cs)
X	spaceinline(mult);
X    else if (mult + cs > ll)
X	spaceinline(ll - (mult + cs));
X    while (mult--)
X	line[cs++] = c;
X    cs = ncs;
X}
X
Xvoid selfinsertunmeta()
X{				/**/
X    c &= 0x7f;
X    if (c == '\r')
X	c = '\n';
X    selfinsert();
X}
X
Xvoid deletechar()
X{				/**/
X    if (mult < 0) {
X	mult = -mult;
X	backwarddeletechar();
X	return;
X    }
X    if (!(cs + mult > ll || line[cs] == '\n')) {
X	cs += mult;
X	backdel(mult);
X    } else
X	feep();
X}
X
Xvoid backwarddeletechar()
X{				/**/
X    if (mult < 0) {
X	mult = -mult;
X	deletechar();
X	return;
X    }
X    if (mult > cs)
X	mult = cs;
X    backdel(mult);
X}
X
Xvoid vibackwarddeletechar()
X{				/**/
X    if (mult < 0) {
X	mult = -mult;
X	videletechar();
X	return;
X    }
X    if (mult > cs)
X	mult = cs;
X    if (cs - mult < viinsbegin) {
X	feep();
X	return;
X    }
X    backkill(mult, 1);
X}
X
Xvoid vikillline()
X{				/**/
X    if (viinsbegin > cs) {
X	feep();
X	return;
X    }
X    backdel(cs - viinsbegin);
X}
X
Xvoid killwholeline()
X{				/**/
X    int i, fg;
X
X    if (mult < 0)
X	return;
X    while (mult--) {
X	if ((fg = (cs && cs == ll)))
X	    cs--;
X	while (cs && line[cs - 1] != '\n')
X	    cs--;
X	for (i = cs; i != ll && line[i] != '\n'; i++);
X	forekill(i - cs + (i != ll), fg);
X    }
X}
X
Xvoid killbuffer()
X{				/**/
X    cs = 0;
X    forekill(ll, 0);
X}
X
Xvoid backwardkillline()
X{				/**/
X    int i = 0;
X
X    if (mult < 0) {
X	mult = -mult;
X	killline();
X	return;
X    }
X    while (mult--) {
X	if (cs && line[cs - 1] == '\n')
X	    cs--, i++;
X	else
X	    while (cs && line[cs - 1] != '\n')
X		cs--, i++;
X    }
X    forekill(i, 1);
X}
X
Xvoid gosmacstransposechars()
X{				/**/
X    int cc;
X
X    if (cs < 2 || line[cs - 1] == '\n' || line[cs - 2] == '\n') {
X	if (line[cs] == '\n' || line[cs + 1] == '\n') {
X	    feep();
X	    return;
X	}
X	cs += (cs == 0 || line[cs - 1] == '\n') ? 2 : 1;
X    }
X    cc = line[cs - 2];
X    line[cs - 2] = line[cs - 1];
X    line[cs - 1] = cc;
X}
X
Xvoid transposechars()
X{				/**/
X    int cc, ct;
X    int neg = mult < 0;
X
X    if (neg)
X	mult = -mult;
X    while (mult--) {
X	if (!(ct = cs) || line[cs - 1] == '\n') {
X	    if (ll == cs || line[cs] == '\n') {
X		feep();
X		return;
X	    }
X	    if (!neg)
X		cs++;
X	    ct++;
X	}
X	if (neg) {
X	    if (cs && line[cs - 1] != '\n') {
X		cs--;
X		if (ct > 1 && line[ct - 2] != '\n')
X		    ct--;
X	    }
X	} else {
X	    if (cs != ll && line[cs] != '\n')
X		cs++;
X	}
X	if (ct == ll || line[ct] == '\n')
X	    ct--;
X	if (ct < 1 || line[ct - 1] == '\n') {
X	    feep();
X	    return;
X	}
X	cc = line[ct - 1];
X	line[ct - 1] = line[ct];
X	line[ct] = cc;
X    }
X}
X
Xvoid poundinsert()
X{				/**/
X    if (*line != '#') {
X	cs = 0;
X	spaceinline(1);
X	*line = '#';
X    } else {
X	cs = 0;
X	foredel(1);
X    }
X    done = 1;
X}
X
Xvoid acceptline()
X{				/**/
X    done = 1;
X}
X
Xvoid acceptandhold()
X{				/**/
X    pushnode(bufstack, ztrdup((char *)line));
X    stackcs = cs;
X    done = 1;
X}
X
Xvoid killline()
X{				/**/
X    int i = 0;
X
X    if (mult < 0) {
X	mult = -mult;
X	backwardkillline();
X	return;
X    }
X    while (mult--) {
X	if (line[cs] == '\n')
X	    cs++, i++;
X	else
X	    while (cs != ll && line[cs] != '\n')
X		cs++, i++;
X    }
X    backkill(i, 0);
X}
X
Xvoid killregion()
X{				/**/
X    if (mark > ll)
X	mark = ll;
X    if (mark > cs)
X	forekill(mark - cs, 0);
X    else
X	backkill(cs - mark, 1);
X}
X
Xvoid copyregionaskill()
X{				/**/
X    if (mark > ll)
X	mark = ll;
X    if (mark > cs)
X	cut(cs, mark - cs, 0);
X    else
X	cut(mark, cs - mark, 1);
X}
X
Xstatic int kct, yankb, yanke;
X
Xvoid yank()
X{				/**/
X    int cc;
X    char *buf = cutbuf;
X
X    if (!cutbuf) {
X	feep();
X	return;
X    }
X    if (mult < 0)
X	return;
X    if (vibufspec) {
X	if (!(buf = vibuf[vibufspec])) {
X	    feep();
X	    vibufspec = 0;
X	    return;
X	}
X	vibufspec = 0;
X    }
X    yankb = cs;
X    while (mult--) {
X	kct = kringnum;
X	cc = strlen(buf);
X	spaceinline(cc);
X	strncpy((char *)line + cs, buf, cc);
X	cs += cc;
X	yanke = cs;
X    }
X}
X
Xvoid viputafter()
X{				/**/
X    int cc;
X    char *buf = cutbuf;
X
X    if (!cutbuf) {
X	feep();
X	return;
X    }
X    if (mult < 0)
X	return;
X    if (vibufspec) {
X	if (!(buf = vibuf[vibufspec])) {
X	    feep();
X	    vibufspec = 0;
X	    return;
X	}
X	vibufspec = 0;
X    }
X    if (strchr(buf, '\n')) {
X	cs = findeol();
X	if (cs == ll) {
X	    spaceinline(1);
X	    line[cs] = '\n';
X	}
X    }
X    if (cs != ll)
X	cs++;
X    yankb = cs;
X    while (mult--) {
X	kct = kringnum;
X	cc = strlen(buf);
X	spaceinline(cc);
X	strncpy((char *)line + cs, buf, cc);
X	cs += cc;
X	yanke = cs;
X    }
X    cs = yankb;
X}
X
Xvoid yankpop()
X{				/**/
X    int cc;
X
X    if (!(lastcmd & ZLE_YANK) || !kring[kct]) {
X	feep();
X	return;
X    }
X    cs = yankb;
X    foredel(yanke - yankb);
X    cc = strlen(kring[kct]);
X    spaceinline(cc);
X    strncpy((char *)line + cs, kring[kct], cc);
X    cs += cc;
X    yanke = cs;
X    kct = (kct - 1) & (KRINGCT - 1);
X}
X
Xvoid overwritemode()
X{				/**/
X    insmode ^= 1;
X}
X
Xvoid undefinedkey()
X{				/**/
X    feep();
X}
X
Xvoid quotedinsert()
X{				/**/
X#ifndef HAS_TIO
X    struct sgttyb sob;
X
X    sob = shttyinfo.sgttyb;
X    sob.sg_flags = (sob.sg_flags | RAW) & ~ECHO;
X    ioctl(SHTTY, TIOCSETN, &sob);
X#endif
X    c = getkey(0);
X#ifndef HAS_TIO
X    setterm();
X#endif
X    if (c > 0)
X	selfinsert();
X    else
X	feep();
X}
X
Xvoid digitargument()
X{				/**/
X    int sign = (mult < 0 || (lastcmd & ZLE_NEGARG)) ? -1 : 1;
X
X    if ((lastcmd & (ZLE_ARG | ZLE_NEGARG)) != ZLE_ARG)
X	mult = 0;
X    mult = mult * 10 + sign * (c & 0xf);
X}
X
Xvoid negargument()
X{				/**/
X    if (lastcmd & ZLE_ARG)
X	feep();
X    mult = -1;
X}
X
Xvoid universalargument()
X{				/**/
X    if (!(lastcmd & ZLE_ARG))
X	mult = 4;
X    else
X	mult *= 4;
X}
X
Xvoid copyprevword()
X{				/**/
X    int len, t0;
X
X    for (t0 = cs - 1; t0 >= 0; t0--)
X	if (iword(line[t0]))
X	    break;
X    for (; t0 >= 0; t0--)
X	if (!iword(line[t0]))
X	    break;
X    if (t0)
X	t0++;
X    len = cs - t0;
X    spaceinline(len);
X    strncpy((char *)line + cs, (char *)line + t0, len);
X    cs += len;
X}
X
Xvoid sendbreak()
X{				/**/
X    errflag = 1;
X}
X
Xvoid undo()
X{				/**/
X    char *s;
X    struct undoent *ue;
X
X    ue = undos + undoct;
X    if (!ue->change) {
X	feep();
X	return;
X    }
X    line[ll] = '\0';
X    s = ztrdup((char *)line + ll - ue->suff);
X    sizeline((ll = ue->pref + ue->suff + ue->len) + 1);
X    strncpy((char *)line + ue->pref, ue->change, ue->len);
X    strcpy((char *)line + ue->pref + ue->len, s);
X    zsfree(s);
X    ue->change = NULL;
X    undoct = (undoct - 1) & (UNDOCT - 1);
X    cs = ue->cs;
X}
X
Xvoid quoteregion()
X{				/**/
X    char *s, *t;
X    int x, y;
X
X    if (mark > ll)
X	mark = ll;
X    if (mark < cs) {
X	x = mark;
X	mark = cs;
X	cs = x;
X    }
X    s = (char *)hcalloc((y = mark - cs) + 1);
X    strncpy(s, (char *)line + cs, y);
X    s[y] = '\0';
X    foredel(mark - cs);
X    t = makequote(s);
X    spaceinline(x = strlen(t));
X    strncpy((char *)line + cs, t, x);
X    mark = cs;
X    cs += x;
X}
X
Xvoid quoteline()
X{				/**/
X    char *s;
X
X    line[ll] = '\0';
X    s = makequote((char *)line);
X    setline(s);
X}
X
Xchar *makequote(s)		/**/
Xchar *s;
X{
X    int qtct = 0;
X    char *l, *ol;
X
X    for (l = s; *l; l++)
X	if (*l == '\'')
X	    qtct++;
X    l = ol = (char *)halloc((qtct * 3) + 3 + strlen(s));
X    *l++ = '\'';
X    for (; *s; s++)
X	if (*s == '\'') {
X	    *l++ = '\'';
X	    *l++ = '\\';
X	    *l++ = '\'';
X	    *l++ = '\'';
X	} else
X	    *l++ = *s;
X    *l++ = '\'';
X    *l = '\0';
X    return ol;
X}
X
X#define NAMLEN 70
X
Xint executenamedcommand()
X{				/**/
X    char buf[NAMLEN], *ptr;
X    int len, cmd, t0;
X
X    strcpy(buf, "execute: ");
X    ptr = buf + 9;
X    len = 0;
X    statusline = buf;
X    refresh();
X    for (;; refresh()) {
X	if ((cmd = getkeycmd()) < 0 || cmd == z_sendbreak) {
X	    statusline = NULL;
X	    return z_undefinedkey;
X	}
X	switch (cmd) {
X	case z_backwarddeletechar:
X	case z_vibackwarddeletechar:
X	    if (len) {
X		len--;
X		*--ptr = '\0';
X	    }
X	    break;
X	case z_killregion:
X	case z_backwardkillword:
X	case z_vibackwardkillword:
X	    while (len && (len--, *--ptr != '-'))
X		*ptr = '\0';
X	    break;
X	case z_killwholeline:
X	case z_vikillline:
X	case z_backwardkillline:
X	    len = 0;
X	    ptr = buf + 9;
X	    *ptr = '\0';
X	    break;
X	case z_acceptline:
X	    for (t0 = 0; t0 != ZLECMDCOUNT; t0++)
X		if (!strcmp(buf + 9, zlecmds[t0].name))
X		    break;
X	    if (t0 != ZLECMDCOUNT) {
X		lastnamed = t0;
X		statusline = NULL;
X		return t0;
X	    } else {
X		feep();
X		break;
X	    }
X	default:
X	    if (cmd == z_listchoices || cmd == z_deletecharorlist ||
X		c == ' ' || c == '\t') {
X		Lklist cmdll;
X		int ambig = 100;
X
X		heapalloc();
X		cmdll = newlist();
X		for (t0 = 0; t0 != ZLECMDCOUNT; t0++)
X		    if (strpfx(buf + 9, zlecmds[t0].name)) {
X			int xx;
X
X			addnode(cmdll, zlecmds[t0].name);
X			xx = pfxlen(peekfirst(cmdll), zlecmds[t0].name);
X			if (xx < ambig)
X			    ambig = xx;
X		    }
X		permalloc();
X		if (empty(cmdll))
X		    feep();
X		else if (cmd == z_listchoices ||
X			 cmd == z_deletecharorlist)
X		    listlist(cmdll);
X		else if (!nextnode(firstnode(cmdll))) {
X		    strcpy(buf + 9, peekfirst(cmdll));
X		    ptr = buf + (len = strlen(buf));
X		} else {
X		    strcpy(buf + 9, peekfirst(cmdll));
X		    len = ambig;
X		    ptr = buf + 9 + len;
X		    *ptr = '\0';
X		    feep();
X		    if (isset(AUTOLIST))
X			listlist(cmdll);
X		}
X	    } else {
X		if (len == NAMLEN - 10 || icntrl(c))
X		    feep();
X		else
X		    *ptr++ = c, *ptr = '\0', len++;
X	    }
X	}
X    }
X}
X
Xvoid vijoin()
X{				/**/
X    int x;
X
X    if ((x = findeol()) == ll) {
X	feep();
X	return;
X    }
X    cs = x + 1;
X    for (x = 1; cs != ll && iblank(line[cs]); cs++, x++);
X    backdel(x);
X    spaceinline(1);
X    line[cs] = ' ';
X}
X
Xvoid viswapcase()
X{				/**/
X    if (cs < ll) {
X	int ch = line[cs];
X
X	if (islower(ch))
X	    ch = tuupper(ch);
X	else if (isupper(ch))
X	    ch = tulower(ch);
X	line[cs] = ch;
X	if (cs != ll - 1)
X	    cs++;
X    }
X}
X
Xvoid vicapslockpanic()
X{				/**/
X    char ch;
X
X    statusline = "press a lowercase key to continue";
X    refresh();
X    do
X	ch = getkey(0);
X    while (!islower(ch));
X}
X
Xint owrite;
X
Xvoid visetbuffer()
X{				/**/
X    int ch;
X
X    ch = getkey(0);
X    if (!isalnum(ch)) {
X	feep();
X	return;
X    }
X    if (ch >= 'A' && ch <= 'Z')	/* needed in cut() */
X	owrite = 0;
X    else
X	owrite = 1;
X    vibufspec = tolower(ch) + (idigit(ch)) ? -'1' + 26 : -'a';
X}
X
Xstatic char *bp;
Xstatic int lensb, countp;
X
Xvoid stradd(d)			/**/
Xchar *d;
X{
X    while ((*bp++ = *d++));
X    bp--;
X}
X
Xint putstr(d)			/**/
Xint d;
X{
X    *bp++ = d;
X    if (countp)
X	lensb++;
X    return 0;
X}
X
Xvoid tstradd(X)			/**/
Xchar *X;
X{
X    int t0;
X
X    if (termok && unset(SINGLELINEZLE)) {
X#ifdef _IBMR2
X    /* AIX tgetstr() ignores second argument */
X	char *tbuf;
X
X	if (tbuf = tgetstr(X, &tbuf))
X#else
X	char tbuf[2048], *tptr = tbuf;
X
X	if (tgetstr(X, &tptr))
X#endif
X	    tputs(tbuf, 1, putstr);
X	if (*X == 's' && (X[1] == 'o' || X[1] == 'e') &&
X	    (t0 = tgetnum("sg")) > -1)
X	    lensb -= t0;
X    }
X}
X
X/* get a prompt string */
X
Xstatic char *buf, *bl0, *fm;
Xstatic int bracepos;
X
Xchar *putprompt(fmin, lenp, isspell)	/**/
Xchar *fmin;
Xint *lenp;
Xint isspell;
X{
X    static char buf0[256], buf1[256], buf2[256];
X
X    bracepos = 0;
X    lensb = 0;
X    countp = 1;
X    fm = fmin;
X    if (!fm) {
X	*lenp = 0;
X	return "";
X    }
X/* KLUDGE ALERT!  What we have here are three buffers:
X	 *  buf1 and buf2 alternate between PS1 and PS2, though which is
X	 *   which is indeterminate depending on spellchecking, "select",
X	 *   etc. -- those operations also share these two buffers.
X	 *  buf0 is used for any prompting that manages to happen while
X	 *   zleread() is in progress (signal traps, etc.), because
X	 *   zleread() re-uses the pointers returned to buf1 and buf2
X	 *   and will be confused if either of those is overwritten.
X	 */
X    buf = zleactive ? buf0 : ((buf == buf1) ? buf2 : buf1);
X    bp = bl0 = buf;
X    if (!columns)
X	columns = 80;
X    clearerr(stdin);
X
X    putpromptchar(isspell == -1 ? 0 : isspell, 1, '\0');
X
X    if (isspell != -1) {
X	*lenp = (bp - bl0) - lensb;
X	*lenp %= columns;
X	if (*lenp == columns - 1) {
X	    *lenp = 0;
X	    *bp++ = ' ';
X	}
X    } else
X	*lenp = (bp - bl0);
X    *bp = '\0';
X
X    *bp = '\0';
X    return buf;
X}
X
Xint putpromptchar(isspell, doprint, endchar)	/**/
Xint isspell;
Xint doprint;
Xint endchar;
X{
X    char buf3[MAXPATHLEN], *ss;
X    int t0, arg, test, sep;
X    struct tm *tm;
X    time_t timet;
X
X    if (isset(PROMPTSUBST)) {
X	char *sss;
X
X	fm = dupstring(fm);
X	for (ss = fm; *ss; ss++)
X	    if (*ss == '$' && ss[1] && (ss == fm || ss[-1] != '%')) {
X		*ss = String;
X		if (ss[1] == '[') {
X		    ss[1] = Inbrack;
X		    for (t0 = 0, sss = ss + 2; *sss && (t0 || *sss != ']'); sss++) {
X			if (*sss == '[')
X			    t0++;
X			if (*sss == ']')
X			    t0--;
X			if (*sss == '\\' && sss[1])
X			    sss++;
X		    }
X		    if (*sss == ']')
X			*sss = Outbrack, ss = sss;
X		} else if (ss[1] == '(') {
X		    ss[1] = Inpar;
X		    for (t0 = 0, sss = ss + 2; *sss && (t0 || *sss != ')'); sss++) {
X			if (*sss == '(')
X			    t0++;
X			if (*sss == ')')
X			    t0--;
X			if (*sss == '\\' && sss[1])
X			    sss++;
X		    }
X		    if (*sss == ')')
X			*sss = Outpar, ss = sss;
X		}
X	    }
X	lexsave();
X	singsub(&fm);
X	lexrestore();
X    }
X    for (; *fm && *fm != endchar; fm++) {
X	if (bp - buf >= 220)
X	    break;
X	arg = 0;
X	if (*fm == '%') {
X	    if (idigit(*++fm)) {
X		arg = zstrtol(fm, &fm, 10);
X	    }
X	    if (*fm == '(') {
X		int tc;
X
X		if (idigit(*++fm)) {
X		    arg = zstrtol(fm, &fm, 10);
X		}
X		test = 0;
X		ss = pwd;
X		switch (tc = *fm) {
X		case 'c':
X		case '.':
X		case '~':
X		    t0 = finddir(ss);
X		    if (t0 != -1) {
X			arg--;
X			ss += namdirs[t0].len;
X		    }
X		case '/':
X		case 'C':
X		    for (; *ss; ss++)
X			if (*ss == '/')
X			    arg--;
X		    if (arg <= 0)
X			test = 1;
X		    break;
X		case 't':
X		case 'T':
X		case 'd':
X		case 'D':
X		case 'w':
X		    timet = time(NULL);
X		    tm = localtime(&timet);
X		    switch (tc) {
X		    case 't':
X			test = (arg == tm->tm_min);
X			break;
X		    case 'T':
X			test = (arg == tm->tm_hour);
X			break;
X		    case 'd':
X			test = (arg == tm->tm_mday);
X			break;
X		    case 'D':
X			test = (arg == tm->tm_mon);
X			break;
X		    case 'w':
X			test = (arg == tm->tm_wday);
X			break;
X		    }
X		    break;
X		case '?':
X		    if (lastval == arg)
X			test = 1;
X		    break;
X		case '#':
X		    if (geteuid() == arg)
X			test = 1;
X		    break;
X		case 'g':
X		    if (getegid() == arg)
X			test = 1;
X		    break;
X		case 'L':
X		    if (shlvl >= arg)
X			test = 1;
X		    break;
X		case 'S':
X		    if (time(NULL) - shtimer.tv_sec >= arg)
X			test = 1;
X		    break;
X		case 'v':
X		    if (arrlen(psvar) >= arg)
X			test = 1;
X		    break;
X		case '_':
X		    test = (cmdsp >= arg);
X		    break;
X		default:
X		    test = -1;
X		    break;
X		}
X		if (!*fm || !(sep = *++fm))
X		    return 0;
X		fm++;
X		if (!putpromptchar(isspell, test == 1 && doprint, sep) || !*++fm ||
X		    !putpromptchar(isspell, test == 0 && doprint, ')')) {
X		    return 0;
X		}
X		continue;
X	    }
X	    if (!doprint)
X		continue;
X	    switch (*fm) {
X	    case '~':
X		t0 = finddir(pwd);
X		if (t0 != -1) {
X		    *bp++ = '~';
X		    stradd(namdirs[t0].name);
X		    stradd(pwd + namdirs[t0].len);
X		    break;
X		}
X	    case 'd':
X	    case '/':
X		stradd(pwd);
X		break;
X	    case 'c':
X	    case '.':
X		t0 = finddir(pwd);
X		if (t0 != -1) {
X		    sprintf(buf3, "~%s%s", namdirs[t0].name,
X			    pwd + namdirs[t0].len);
X		} else {
X		    strcpy(buf3, pwd);
X		}
X		if (!arg)
X		    arg++;
X		for (ss = buf3 + strlen(buf3); ss > buf3; ss--)
X		    if (*ss == '/' && !--arg) {
X			ss++;
X			break;
X		    }
X		if (*ss == '/' && ss[1] && (ss != buf3))
X		    ss++;
X		stradd(ss);
X		break;
X	    case 'C':
X		strcpy(buf3, pwd);
X		if (!arg)
X		    arg++;
X		for (ss = buf3 + strlen(buf3); ss > buf3; ss--)
X		    if (*ss == '/' && !--arg) {
X			ss++;
X			break;
X		    }
X		if (*ss == '/' && ss[1] && (ss != buf3))
X		    ss++;
X		stradd(ss);
X		break;
X	    case 'h':
X	    case '!':
X		sprintf(bp, "%d", curhist);
X		bp += strlen(bp);
X		break;
X	    case 'M':
X		stradd(hostnam);
X		break;
X	    case 'm':
X		if (!arg)
X		    arg++;
X		for (ss = hostnam; *ss; ss++)
X		    if (*ss == '.' && !--arg)
X			break;
X		t0 = *ss;
X		*ss = '\0';
X		stradd(hostnam);
X		*ss = t0;
X		break;
X	    case 'S':
X		tstradd("so");
X		break;
X	    case 's':
X		tstradd("se");
X		break;
X	    case 'B':
X		tstradd("md");
X		break;
X	    case 'b':
X		tstradd("me");
X		break;
X	    case 'U':
X		tstradd("us");
X		break;
X	    case 'u':
X		tstradd("ue");
X		break;
X	    case '{':
X		bracepos = bp - buf;
X		countp = 0;
X		break;
X	    case '}':
X		lensb += (bp - buf) - bracepos;
X		countp = 1;
X		break;
X	    case 't':
X	    case '@':
X	    case 'T':
X	    case '*':
X	    case 'w':
X	    case 'W':
X	    case 'D':
X		{
X		    char *tmfmt, *dd;
X
X		    switch (*fm) {
X		    case 'T':
X			tmfmt = "%k:%M";
X			break;
X		    case '*':
X			tmfmt = "%k:%M:%S";
X			break;
X		    case 'w':
X			tmfmt = "%a %e";
X			break;
X		    case 'W':
X			tmfmt = "%m/%d/%y";
X			break;
X		    case 'D':
X			tmfmt = "%y-%m-%d";
X			if (fm[1] == '{') {
X			    for (ss = fm + 2, dd = buf3; *ss && *ss != '}'; ++ss, ++dd)
X				*dd = *((*ss == '\\' && ss[1]) ? ++ss : ss);
X			    if (*ss == '}') {
X				*dd = '\0';
X				fm = ss;
X				tmfmt = buf3;
X			    }
X			}
X			break;
X		    default:
X			tmfmt = "%l:%M%p";
X			break;
X		    }
X		    timet = time(NULL);
X		    tm = localtime(&timet);
X		    ztrftime(bp, buf + 220 - bp, tmfmt, tm);
X		    if (*bp == ' ')
X			chuck(bp);
X		    bp += strlen(bp);
X		    break;
X		}
X	    case 'n':
X		stradd(username);
X		break;
X	    case 'l':
X		if (*ttystrname)
X		    stradd((strncmp(ttystrname, "/dev/tty", 8) ?
X			    ttystrname + 5 : ttystrname + 8));
X		else
X		    stradd("()");
X		break;
X	    case '?':
X		sprintf(bp, "%ld", (long)lastval);
X		bp += strlen(bp);
X		break;
X	    case '%':
X		*bp++ = '%';
X		break;
X	    case '#':
X		*bp++ = (geteuid())? '%' : '#';
X		break;
X	    case 'v':
X		if (!arg)
X		    arg++;
X	    /* The number 35 here comes from 256-220-1, where 256 is
X	       sizeof(buf), 220 is from the overflow test made at the
X	       top of the loop, and 1 is for the \0 byte at the end. */
X
X		if (arrlen(psvar) >= arg && (int)strlen(psvar[arg - 1]) < 35)
X		    stradd(psvar[arg - 1]);
X		else
X		    stradd("");
X		break;
X	    case 'E':
X		tstradd("ce");
X		break;
X	    case '_':
X		if (cmdsp) {
X		    if (arg <= 0)
X			arg = 1;
X		    if (arg > cmdsp)
X			arg = cmdsp;
X		    for (t0 = cmdsp - arg; arg--; t0++) {
X			stradd(cmdnames[cmdstack[t0]]);
X			if (arg)
X			    stradd(" ");
X		    }
X		}
X		break;
X	    case 'r':
X		if (isspell) {
X		    stradd(rstring);
X		    break;
X		}
X	    case 'R':
X		if (isspell) {
X		    stradd(Rstring);
X		    break;
X		}
X	    default:
X		*bp++ = '%';
X		*bp++ = *fm;
X		break;
X	    }
X	} else if (*fm == '!' && doprint) {
X	    sprintf(bp, "%d", curhist);
X	    bp += strlen(bp);
X	} else {
X	    if (fm[0] == '\\' && fm[1])
X		fm++;
X	    if (doprint && (*bp++ = *fm) == '\n')
X		bl0 = bp, lensb = 0;
X	}
X    }
X
X    return *fm;
X}
END_OF_FILE
  if test 19757 -ne `wc -c <'zsh-2.5.0/src/zle_misc.c'`; then
    echo shar: \"'zsh-2.5.0/src/zle_misc.c'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/src/zle_misc.c'
fi
echo shar: End of archive 6 \(of 18\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
