Path: news.csc.fi!news.eunet.fi!EU.net!uunet!sparky!not-for-mail
From: zsh-list@sterling.com (Bas de Bakker)
Newsgroups: comp.sources.misc
Subject: v43i101:  zsh - The Z shell, version 2.5.0, Part12/18
Followup-To: comp.sources.d
Date: 13 Jul 1994 23:06:21 -0500
Organization: Sterling Software
Lines: 4074
Sender: kent@sparky.sterling.com
Approved: kent@sparky.sterling.com
Message-ID: <302djt$t92@sparky.sterling.com>
References: <csm-v43i089=zsh.230017@sparky.sterling.com>
NNTP-Posting-Host: sparky.sterling.com
X-Md4-Signature: d3b28564d5dda585e0ce3f81c90f5704

Submitted-by: zsh-list@sterling.com (Bas de Bakker)
Posting-number: Volume 43, Issue 101
Archive-name: zsh/part12
Environment: UNIX
Supersedes: zsh: Volume 35, Issue 51-72

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  zsh-2.5.0/src/config.h.sample zsh-2.5.0/src/exec.c
#   zsh-2.5.0/src/params.c
# Wrapped by kent@sparky on Tue Jul 12 16:47:24 1994
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 12 (of 18)."'
if test -f 'zsh-2.5.0/src/config.h.sample' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/src/config.h.sample'\"
else
  echo shar: Extracting \"'zsh-2.5.0/src/config.h.sample'\" \(3327 characters\)
  sed "s/^X//" >'zsh-2.5.0/src/config.h.sample' <<'END_OF_FILE'
X/* this file is created automatically by buildzsh */
X
X/* define this if you are sysvish */
X/* #define SYSV */
X
X#define TERMIOS
X/* #define TTY_NEEDS_DRAINING */
X/* #define CLOBBERS_TYPEAHEAD */
X
X#define HAS_DIRENT
X
X#define HAS_UNISTD
X
X#define HAS_STDLIB
X
X#define HAS_STRING
X
X#define HAS_MEMORY
X
X#define HAS_LOCALE
X
X/*#define HAS_UTMPX*/
X
X#define UTMP_HOST
X
X/*#define HAS_TIME*/
X
X/*#define HAS_WAIT*/
X
X/* define this if you have WAITPID */
X#define WAITPID
X
X/* define this if you have SELECT */
X#define HAS_SELECT
X
X/* define this if you have <sys/select.h> */
X/* #define HAS_SYS_SELECT */
X
X/* we can't just test for S_IFIFO or check to see if the mknod worked,
X   because the NeXTs sold by a vendor which will remain nameless will
X   happily create the FIFO for you, and then panic when you try to do
X	something weird with them, because they aren't supported by the OS. */
X
X/* #define NO_FIFOS */
X
X/* define this if you have strftime() */
X#define HAS_STRFTIME
X
X#define HAS_TCSETPGRP
X
X#define HAS_TCCRAP
X
X#define HAS_SETPGID
X
X/* #define HAS_SIGRELSE */
X
X/* define this if you have RFS */
X/* #define HAS_RFS */
X
X/* define this if you have a working getrusage and wait3 */
X#define HAS_RUSAGE
X/* define this if you use NIS for your passwd map */
X#define HAS_NIS_PASSWD
X
X/* define this if your signal handlers return void */
X#define SIGVOID
X#ifdef sgi
X#undef SIGVOID
X#endif
X
X/* define this if signal handlers need to be reset each time */
X/* #define RESETHANDNEEDED */
X
X#ifdef SIGVOID
X#define HANDTYPE void
X#else
X#define HANDTYPE int
X#define INTHANDTYPE
X#endif
X
X/* a string corresponding to the host type */
X#define HOSTTYPE "sun4"
X
X/* the default editor for the fc builtin */
X#define DEFFCEDIT "vi"
X
X/* the path of wtmp */
X#define WTMP_FILE "/var/adm/wtmp"
X
X/* the path of utmp */
X#define UTMP_FILE "/etc/utmp"
X
X/* default prefix for temporary files */
X#define DEFTMPPREFIX "/tmp/zsh"
X
X/* define if you prefer "suspended" to "stopped" */
X#define USE_SUSPENDED
X
X/* the file to source absolutely first whenever zsh is run; if undefined,
X      don't source anything */
X#define GLOBALZSHENV "/etc/zshenv"
X
X/* the file to source whenever zsh is run; if undefined, don't source
X	anything */
X#define GLOBALZSHRC "/etc/zshrc"
X
X/* the file to source whenever zsh is run as a login shell; if
X	undefined, don't source anything */
X#define GLOBALZLOGIN "/etc/zlogin"
X
X/* the file to source whenever zsh is run as a login shell, before
X	zshrc is read; if undefined, don't source anything */
X#define GLOBALZPROFILE "/etc/zprofile"
X
X/* the default HISTSIZE */
X#define DEFAULT_HISTSIZE 30
X
X#define _BSD_SIGNALS   /* this could be an iris, you never know */
X#define _BSD           /* this could be HP-UX, you never know */
X#define _BSD_INCLUDES  /* this could be AIX, you never know */
X#define _BBN_POSIX_SUPPORT	/* this could be nX, you never know */
X
X/* if your compiler doesn't like void *, change this to char *
X	and ignore all the warnings.
X*/
X
Xtypedef void *vptr;
X
X#define JOB_CONTROL
X
X/* define this if you want to use zsh's own allocator */
X
X/* #define USE_ZSH_MALLOC */
X
X/* define this if you want the allocator to store information */
X
X/* #define MEM_DEBUG */
X
X/* define this if you want to get error messages from the allocator */
X
X/* #define MEM_WARNING */
X
X/* define this if you want free() to be really save */
X
X/* #define SECURE_FREE */
END_OF_FILE
  if test 3327 -ne `wc -c <'zsh-2.5.0/src/config.h.sample'`; then
    echo shar: \"'zsh-2.5.0/src/config.h.sample'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/src/config.h.sample'
fi
if test -f 'zsh-2.5.0/src/exec.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/src/exec.c'\"
else
  echo shar: Extracting \"'zsh-2.5.0/src/exec.c'\" \(43966 characters\)
  sed "s/^X//" >'zsh-2.5.0/src/exec.c' <<'END_OF_FILE'
X/*
X *
X * exec.c - command execution
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made.
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk.
X *
X */
X
X#include "zsh.h"
X#include <errno.h>
X
X#define execerr() { if (forked) _exit(1); \
X	closemnodes(mfds); lastval = 1; return; }
X
Xstatic Lklist args;
X
X/* parse list in a string */
X
XList parselstring(s)		/**/
Xchar *s;
X{
X    List l;
X
X    hungets(s);
X    strinbeg();
X    pushheap();
X    if (!(l = parse_list())) {
X	strinend();
X	hflush();
X	popheap();
X	return NULL;
X    }
X    strinend();
X    return l;
X}
X
X/* execute a string */
X
Xvoid execstring(s)		/**/
Xchar *s;
X{
X    List l;
X
X    if ((l = parselstring(s))) {
X	execlist(l);
X	popheap();
X    }
X}
X
X/* fork and set limits */
X
Xint phork()
X{				/**/
X    int pid;
X
X#ifdef RLIM_INFINITY
X    int t0;
X
X#endif
X
X    if (thisjob >= MAXJOB - 1) {
X	zerr("job table full", NULL, 0);
X	return -1;
X    }
X    pid = fork();
X    if (pid == -1) {
X	zerr("fork failed: %e", NULL, errno);
X	return -1;
X    }
X#ifdef RLIM_INFINITY
X    if (!pid)
X	for (t0 = 0; t0 != RLIM_NLIMITS; t0++)
X	    setrlimit(t0, limits + t0);
X#endif
X    return pid;
X}
X
X/* execute a current shell command */
X
Xint execcursh(cmd)		/**/
XCmd cmd;
X{
X    runlist(cmd->u.list);
X    cmd->u.list = NULL;
X    return lastval;
X}
X
X/* execve after handling $_ and #! */
X
X#define POUNDBANGLIMIT 64
X
Xint zexecve(pth, argv)		/**/
Xchar *pth;
Xchar **argv;
X{
X    int eno;
X    static char buf[MAXPATHLEN * 2];
X    char **eep;
X
X    for (eep = environ; *eep; eep++)
X	if (**eep == '_' && (*eep)[1] == '=')
X	    break;
X    buf[0] = '_';
X    buf[1] = '=';
X    if (*pth == '/')
X	strcpy(buf + 2, pth);
X    else
X	sprintf(buf + 2, "%s/%s", pwd, pth);
X    if (!*eep)
X	eep[1] = NULL;
X    *eep = buf;
X    execve(pth, argv, environ);
X    if ((eno = errno) == ENOEXEC) {
X	char execvebuf[POUNDBANGLIMIT + 1], *ptr, *ptr2, *argv0;
X	int fd, ct, t0;
X
X	if ((fd = open(pth, O_RDONLY)) >= 0) {
X	    argv0 = *argv;
X	    *argv = pth;
X	    ct = read(fd, execvebuf, POUNDBANGLIMIT);
X	    close(fd);
X	    if (ct > 0) {
X		if (execvebuf[0] == '#')
X		    if (execvebuf[1] == '!') {
X			for (t0 = 0; t0 != ct; t0++)
X			    if (execvebuf[t0] == '\n')
X				execvebuf[t0] = '\0';
X			execvebuf[POUNDBANGLIMIT] = '\0';
X			for (ptr = execvebuf + 2; *ptr && *ptr == ' '; ptr++);
X			for (ptr2 = ptr; *ptr && *ptr != ' '; ptr++);
X			if (*ptr) {
X			    *ptr = '\0';
X			    argv[-2] = ptr2;
X			    argv[-1] = ptr + 1;
X			    execve(ptr2, argv - 2, environ);
X			} else {
X			    argv[-1] = ptr2;
X			    execve(ptr2, argv - 1, environ);
X			}
X		    } else {
X			argv[-1] = "sh";
X			execve("/bin/sh", argv - 1, environ);
X		} else {
X		    for (t0 = 0; t0 != ct; t0++)
X			if (!execvebuf[t0])
X			    break;
X		    if (t0 == ct) {
X			argv[-1] = "sh";
X			execve("/bin/sh", argv - 1, environ);
X		    }
X		}
X	    } else
X		eno = errno;
X	    *argv = argv0;
X	} else
X	    eno = errno;
X    }
X    return eno;
X}
X
X#define MAXCMDLEN (MAXPATHLEN*4)
X
X/* execute an external command */
X
Xvoid execute(dash)		/**/
Xint dash;
X{
X    static Lklist exargs;
X    char **argv, *arg0, **pp;
X    char *z, *s, buf[MAXCMDLEN], buf2[MAXCMDLEN];
X    int ee, eno = 0;
X    Cmdnam cn;
X
X    if (empty(args)) {
X	zerr("no command", NULL, 0);
X	_exit(1);
X    }
X    if (!exargs && (s = zgetenv("STTY"))) {
X	exargs = args;
X	args = NULL;
X	zyztem("stty", s);
X	args = exargs;
X	exargs = NULL;
X    }
X    arg0 = (char *)peekfirst(args);
X    cn = (Cmdnam) gethnode(arg0, cmdnamtab);
X    if (cn && (cn->flags & DISABLED))
X	cn = NULL;
X    if ((z = zgetenv("ARGV0"))) {
X	setdata(firstnode(args), (vptr) ztrdup(z));
X	delenv(z - 6);
X    } else if (dash) {
X	sprintf(buf2, "-%s", arg0);
X	setdata(firstnode(args), (vptr) ztrdup(buf2));
X    }
X    argv = makecline(args);
X    unblockchld();
X    if ((int)strlen(arg0) > MAXPATHLEN) {
X	zerr("command too long: %s", arg0, 0);
X	_exit(1);
X    }
X    for (s = arg0; *s; s++)
X	if (*s == '/') {
X	    errno = zexecve(arg0, argv);
X	    if (arg0 == s || unset(PATHDIRS) ||
X		(arg0[0] == '.' && (arg0 + 1 == s ||
X				    (arg0[1] == '.' && arg0 + 2 == s)))) {
X		zerr("%e: %s", arg0, errno);
X		_exit(1);
X	    }
X	    break;
X	}
X    if (cn && ISEXCMD(cn->flags)) {
X	char nn[MAXPATHLEN];
X
X	if (cn->flags & BUILTIN)
X	    strcpy(nn, cn->u.cmd);
X	else {
X	    for (pp = path; pp < cn->u.name; pp++)
X		if (**pp == '.' && (*pp)[1] == '\0') {
X		    ee = zexecve(arg0, argv);
X		    if (ee != ENOENT)
X			eno = ee;
X		} else if (**pp != '/') {
X		    z = buf;
X		    strucpy(&z, *pp);
X		    *z++ = '/';
X		    strcpy(z, arg0);
X		    ee = zexecve(buf, argv);
X		    if (ee != ENOENT)
X			eno = ee;
X		}
X	    strcpy(nn, cn->u.name ? *(cn->u.name) : "");
X	    strcat(nn, "/");
X	    strcat(nn, cn->nam);
X	}
X	ee = zexecve(nn, argv);
X
X	if (ee != ENOENT)
X	    eno = ee;
X    }
X    for (pp = path; *pp; pp++)
X	if ((*pp)[0] == '.' && !(*pp)[1]) {
X	    ee = zexecve(arg0, argv);
X	    if (ee != ENOENT)
X		eno = ee;
X	} else {
X	    z = buf;
X	    strucpy(&z, *pp);
X	    *z++ = '/';
X	    strcpy(z, arg0);
X	    ee = zexecve(buf, argv);
X	    if (ee != ENOENT)
X		eno = ee;
X	}
X    if (eno)
X	zerr("%e: %s", arg0, eno);
X    else
X	zerr("command not found: %s", arg0, 0);
X    _exit(1);
X}
X
X#define try(X) { if (iscom(X)) return ztrdup(X); }
X
X/* get the full pathname of an external command */
X
Xchar *findcmd(arg0)		/**/
Xchar *arg0;
X{
X    char **pp;
X    char *z, *s, buf[MAXCMDLEN];
X    Cmdnam cn;
X
X    cn = (Cmdnam) gethnode(arg0, cmdnamtab);
X    if (!cn && isset(HASHCMDS))
X	cn = hashcmd(arg0, path);
X    if (cn && cn->flags & DISABLED)
X	cn = NULL;
X    if ((int)strlen(arg0) > MAXPATHLEN)
X	return NULL;
X    for (s = arg0; *s; s++)
X	if (*s == '/') {
X	    try(arg0);
X	    if (arg0 == s || unset(PATHDIRS)) {
X		return NULL;
X	    }
X	    break;
X	}
X    if (cn && ISEXCMD(cn->flags)) {
X	char nn[MAXPATHLEN];
X
X	if (cn->flags & BUILTIN)
X	    strcpy(nn, cn->u.cmd);
X	else {
X	    for (pp = path; pp < cn->u.name; pp++)
X		if (**pp != '/') {
X		    z = buf;
X		    strucpy(&z, *pp);
X		    *z++ = '/';
X		    strcpy(z, arg0);
X		    try(buf);
X		}
X	    strcpy(nn, cn->u.name ? *(cn->u.name) : "");
X	    strcat(nn, "/");
X	    strcat(nn, cn->nam);
X	}
X	try(nn);
X    }
X    for (pp = path; *pp; pp++) {
X	z = buf;
X	strucpy(&z, *pp);
X	*z++ = '/';
X	strcpy(z, arg0);
X	try(buf);
X    }
X    return NULL;
X}
X
Xint iscom(s)			/**/
Xchar *s;
X{
X    struct stat statbuf;
X
X    return (access(s, X_OK) == 0 && stat(s, &statbuf) >= 0 &&
X	    S_ISREG(statbuf.st_mode));
X}
X
Xint isrelative(s)		/**/
Xchar *s;
X{
X    if (*s != '/')
X	return 1;
X    for (; *s; s++)
X	if (*s == '.' && s[-1] == '/' &&
X	    (s[1] == '/' || s[1] == '\0' ||
X	     (s[1] == '.' && (s[2] == '/' || s[2] == '\0'))))
X	    return 1;
X    return 0;
X}
X
XCmdnam hashcmd(arg0, pp)	/**/
Xchar *arg0;
Xchar **pp;
X{
X    char *s, buf[MAXPATHLEN];
X    char **pq;
X    DIR *dir;
X    struct dirent *de;
X    Cmdnam cn;
X
X    for (; *pp; pp++)
X	if (**pp == '/') {
X	    s = buf;
X	    strucpy(&s, *pp);
X	    *s++ = '/';
X	    strcpy(s, arg0);
X	    if (iscom(buf))
X		break;
X	}
X    if (!*pp || isrelative(*pp))
X	return NULL;
X    cn = (Cmdnam) zcalloc(sizeof *cn);
X    cn->flags = EXCMD;
X    cn->u.name = pp;
X    addhnode(ztrdup(arg0), cn, cmdnamtab, freecmdnam);
X    if (unset(HASHDIRS))
X	return cn;
X    for (pq = pathchecked; pq <= pp; pq++) {
X	if (isrelative(*pq) || !(dir = opendir(*pq)))
X	    continue;
X	readdir(dir);
X	readdir(dir);
X	while ((de = readdir(dir)))
X	    addhcmdnode(de->d_name, pq);
X	closedir(dir);
X    }
X    pathchecked = pp + 1;
X    return cn;
X}
X
Xvoid fullhash()
X{				/**/
X    char **pq;
X    DIR *dir;
X    struct dirent *de;
X
X    for (pq = pathchecked; *pq; pq++) {
X	if (isrelative(*pq) || !(dir = opendir(*pq)))
X	    continue;
X	readdir(dir);
X	readdir(dir);
X	while ((de = readdir(dir)))
X	    addhcmdnode(de->d_name, pq);
X	closedir(dir);
X    }
X    pathchecked = pq;
X}
X
Xvoid execlist(list)		/**/
XList list;
X{
X    static int donetrap;
X
X    if (breaks)
X	return;
X    if (!list || list == &dummy_list)
X	return;
X    donetrap = 0;
X    simplifyright(list);
X    switch (list->type) {
X    case SYNC:
X    case ASYNC:
X	execlist2(list->left, list->type, !list->right);
X	if (sigtrapped[SIGDEBUG])
X	    dotrap(SIGDEBUG);
X	if (sourcelevel < 32768 && !donetrap) {
X	    if (sigtrapped[SIGZERR] && lastval) {
X		dotrap(SIGZERR);
X		donetrap = 1;
X	    }
X	    if (lastval && isset(ERREXIT)) {
X		if (sigtrapped[SIGEXIT])
X		    dotrap(SIGEXIT);
X		exit(lastval);
X	    }
X	}
X	if (list->right && !retflag) {
X	/* errflag = 0; */
X	    execlist(list->right);
X	}
X	break;
X    }
X}
X
Xvoid execlist2(list, type, last1)	/**/
XSublist list;
Xint type;
Xint last1;
X{
X    if (!list)
X	return;
X    switch (list->type) {
X    case END:
X	execpline(list, type, last1);
X	break;
X    case ORNEXT:
X	if (!execpline(list, SYNC, 0))
X	    execlist2(list->right, type, last1);
X	else
X	    while ((list = list->right))
X		if (list->type == ANDNEXT) {
X		    execlist2(list->right, type, last1);
X		    return;
X		}
X	break;
X    case ANDNEXT:
X	if (execpline(list, SYNC, 0))
X	    execlist2(list->right, type, last1);
X	else
X	    while ((list = list->right))
X		if (list->type == ORNEXT) {
X		    execlist2(list->right, type, last1);
X		    return;
X		}
X	break;
X    }
X}
X
Xstatic int in_pipe;
X
Xint execpline(l, how, last1)	/**/
XSublist l;
Xint how;
Xint last1;
X{
X    int ipipe[2], opipe[2];
X
X    if (!l)
X	return 0;
X    ipipe[0] = ipipe[1] = opipe[0] = opipe[1] = 0;
X    if (in_pipe) {
X	execpline2(l->left, how, opipe[0], ipipe[1], last1);
X	return lastval;		/* if we're in a pipe don't change lastval; it'll be */
X    }				/* done by the first instance of execpline */
X    blockchld();
X    if ((thisjob = getfreejob()) == -1)
X	return 1;
X    initjob();
X    if (how == TIMED) {
X	jobtab[thisjob].stat |= STAT_TIMED;
X	how = SYNC;
X    }
X    if (l->flags & PFLAG_COPROC) {
X	how = ASYNC;
X	if (coprocin >= 0) {
X	    close(coprocin);
X	    close(coprocout);
X	}
X	mpipe(ipipe);
X	mpipe(opipe);
X	coprocin = ipipe[0];
X	coprocout = opipe[1];
X    }
X    execpline2(l->left, how, opipe[0], ipipe[1], last1);
X    if (how == ASYNC) {
X	if (l->flags & PFLAG_COPROC)
X	    close(ipipe[1]);
X	spawnjob();
X	unblockchld();
X	return 1;
X    } else {
X	waitjobs();
X	unblockchld();
X	if (l->flags & PFLAG_NOT)
X	    lastval = !lastval;
X	return !lastval;
X    }
X}
X
Xvoid execpline2(pline, how, input, output, last1)	/**/
XPline pline;
Xint how;
Xint input;
Xint output;
Xint last1;
X{
X    int pid;
X    int pipes[2];
X    int oldlineno = lineno;
X
X    if (breaks)
X	return;
X    if (!pline)
X	return;
X    lineno = pline->left->lineno;
X    if (pline->type == END) {
X	in_pipe = 0;
X	execcmd(pline->left, input, output, how == ASYNC, last1);
X	pline->left = NULL;
X    } else {
X	int old_pipe = in_pipe;
X
X	in_pipe = 0;
X	mpipe(pipes);
X	if (pline->left->type >= CURSH && how == SYNC) {
X
X	/* if we are doing "foo | bar" where foo is a current
X				shell command, do foo in a subshell and do
X				the rest of the pipeline in the current shell. */
X
X	    int synch[2];
X
X	    pipe(synch);
X	    if (!(pid = fork())) {
X		close(pipes[0]);
X		close(synch[0]);
X		entersubsh(how == ASYNC);
X		close(synch[1]);
X		exiting = 1;
X		execcmd(pline->left, input, pipes[1], how == ASYNC, 0);
X		_exit(lastval);
X	    } else if (pid == -1) {
X		close(synch[0]);
X		close(synch[1]);
X		zerr("fork failed: %e", NULL, errno);
X	    } else {
X		char dummy, *text = getjobtext((vptr) pline->left);
X
X		addproc(pid, text);
X		close(synch[1]);
X		read(synch[0], &dummy, 1);
X		close(synch[0]);
X	    }
X	} else {
X	/* otherwise just do the pipeline normally. */
X	    execcmd(pline->left, input, pipes[1], how == ASYNC, 0);
X	}
X	in_pipe = old_pipe;
X	pline->left = NULL;
X	close(pipes[1]);
X	if (pline->right) {
X	/* if another execpline() is invoked because the command is a list it
X	   must know that we're already in a pipeline */
X	    in_pipe = 1;
X	    execpline2(pline->right, how, pipes[0], output, last1);
X	    close(pipes[0]);
X	}
X    }
X
X    lineno = oldlineno;
X}
X
X/* make the argv array */
X
Xchar **makecline(list)		/**/
Xstruct lklist *list;
X{
X    int ct = 0;
X    Lknode node;
X    char **argv, **ptr;
X
X    if (isset(XTRACE)) {
X	fprintf(stderr, "%s", (prompt4) ? prompt4 : "");
X	for (node = firstnode(list); node; incnode(node), ct++);
X	ptr = argv = 2 + (char **)ncalloc((ct + 4) * sizeof(char *));
X
X	for (node = firstnode(list); node; incnode(node))
X	    if (*(char *)getdata(node)) {
X		*ptr++ = (char *)getdata(node);
X		untokenize(getdata(node));
X		fputs(getdata(node), stderr);
X		if (nextnode(node))
X		    fputc(' ', stderr);
X	    }
X	*ptr = NULL;
X	fputc('\n', stderr);
X	fflush(stderr);
X	return (argv);
X    } else {
X	for (node = firstnode(list); node; incnode(node), ct++);
X	ptr = argv = 2 + (char **)ncalloc((ct + 4) * sizeof(char *));
X
X	for (node = firstnode(list); node; incnode(node))
X	    if (*(char *)getdata(node)) {
X		*ptr++ = (char *)getdata(node);
X		untokenize(getdata(node));
X	    }
X	*ptr = NULL;
X	return (argv);
X    }
X}
X
X/* untokenize the command line and remove null arguments */
X
Xvoid fixcline(l)		/**/
XLklist l;
X{
X    Lknode node, next;
X
X    for (node = firstnode(l); node; node = next) {
X	next = nextnode(node);
X	if (!*(char *)getdata(node))
X	    uremnode(l, node);
X	else
X	    untokenize(getdata(node));
X    }
X}
X
Xvoid untokenize(s)		/**/
Xchar *s;
X{
X    for (; *s; s++)
X	if (itok(*s))
X	    if (*s == Nularg)
X		chuck(s--);
X	    else
X		*s = ztokens[*s - Pound];
X}
X
X/* nonzero if we shouldn't clobber a file */
X
Xint dontclob(f)			/**/
Xstruct redir *f;
X{
X    struct stat buf;
X
X    if (unset(NOCLOBBER) || f->type & 1)
X	return 0;
X    if (stat(f->name, &buf) == -1)
X	return 1;
X    return S_ISREG(buf.st_mode);
X}
X
X/* close an multio (success) */
X
Xvoid closemn(mfds, fd)		/**/
Xstruct multio **mfds;
Xint fd;
X{
X    if (mfds[fd]) {
X	if (mfds[fd]->ct > 1)
X	    if (mfds[fd]->rflag == 0)
X		catproc(mfds[fd]);
X	    else
X		teeproc(mfds[fd]);
X	mfds[fd] = NULL;
X    }
X}
X
X/* close all the mnodes (failure) */
X
Xvoid closemnodes(mfds)		/**/
Xstruct multio **mfds;
X{
X    int t0, t1;
X
X    for (t0 = 0; t0 != 10; t0++)
X	if (mfds[t0]) {
X	    for (t1 = 0; t1 != mfds[t0]->ct; t1++)
X		close(mfds[t0]->fds[t1]);
X	    mfds[t0] = NULL;
X	}
X}
X
X/* add a fd to an multio */
X/* an multio is a list of fds associated with a certain fd.
X	thus if you do "foo >bar >ble", the multio for fd 1 will have
X	two fds, the result of open("bar",...), and the result of
X	open("ble",....). */
X
Xvoid addfd(forked, save, mfds, fd1, fd2, rflag)	/**/
Xint forked;
Xint *save;
Xstruct multio **mfds;
Xint fd1;
Xint fd2;
Xint rflag;
X{
X    int pipes[2];
X
X    if (!mfds[fd1]) {		/* starting a new multio */
X	mfds[fd1] = (struct multio *)alloc(sizeof(struct multio));
X
X	if (!forked && fd1 != fd2 && fd1 < 10)
X	    save[fd1] = movefd(fd1);
X	redup(fd2, fd1);
X	mfds[fd1]->ct = 1;
X	mfds[fd1]->fds[0] = fd1;
X	mfds[fd1]->rflag = rflag;
X    } else {
X	if (mfds[fd1]->rflag != rflag) {
X	    zerr("file mode mismatch on fd %d", NULL, fd1);
X	    return;
X	}
X	if (mfds[fd1]->ct == 1) {	/* split the stream */
X	    mfds[fd1]->fds[0] = movefd(fd1);
X	    mfds[fd1]->fds[1] = movefd(fd2);
X	    mpipe(pipes);
X	    mfds[fd1]->pipe = pipes[1 - rflag];
X	    redup(pipes[rflag], fd1);
X	    mfds[fd1]->ct = 2;
X	} else			/* add another fd to an already split stream */
X	    mfds[fd1]->fds[mfds[fd1]->ct++] = movefd(fd2);
X    }
X}
X
Xvoid addvars(l, export)		/**/
XLklist l;
Xint export;
X{
X    struct varasg *v;
X    Lklist vl;
X
X    while (full(l)) {
X	char **arr, **ptr;
X
X	v = (struct varasg *)ugetnode(l);
X	singsub(&v->name);
X	if (errflag)
X	    return;
X	untokenize(v->name);
X	if (v->type == PMFLAG_s) {
X	    vl = newlist();
X	    addnode(vl, v->str);
X	} else
X	    vl = v->arr;
X	prefork(vl, v->type ? 3 : 013);
X	if (errflag)
X	    return;
X	postfork(vl, v->type ? 1 : 011);
X	if (errflag)
X	    return;
X	if (v->type == PMFLAG_s && (empty(vl) || !nextnode(firstnode(vl)))) {
X	    Param pm;
X	    char *val;
X
X	    if (empty(vl))
X		val = ztrdup("");
X	    else {
X		untokenize(peekfirst(vl));
X		val = ztrdup(ugetnode(vl));
X	    }
X	    pm = setsparam(v->name, ztrdup(val));
X	    if (errflag)
X		return;
X	    if (export && !(pm->flags & PMFLAG_x))
X		addenv(v->name, val);
X	    zsfree(val);
X	    continue;
X	}
X	ptr = arr = (char **)zalloc(sizeof(char **) * (countnodes(vl) + 1));
X
X	while (full(vl)) {
X	    char *pp;
X
X	    pp = (char *)ugetnode(vl);
X	    if (*pp) {
X		*ptr = ztrdup(pp);
X		untokenize(*ptr++);
X	    }
X	}
X	*ptr = NULL;
X	setaparam(v->name, arr);
X	if (errflag)
X	    return;
X    }
X}
X
Xvoid execcmd(cmd, input, output, bkg, last1)	/**/
XCmd cmd;
Xint input;
Xint output;
Xint bkg;
Xint last1;
X{
X    int type;
X    long pid;
X    int save[10], t0;
X    struct redir *fn;
X    struct multio *mfds[10];
X    int fil, forked = 0, iscursh, nullexec = 0, assign = 0;
X    char *text, dummy;
X    Cmdnam cn1 = NULL;
X
X    args = cmd->args;
X    for (t0 = 0; t0 != 10; t0++) {
X	save[t0] = -1;
X	mfds[t0] = NULL;
X    }
X    if ((type = cmd->type) == SIMPLE && empty(args))
X	if (full(cmd->redir))
X	    if (cmd->flags & CFLAG_EXEC) {
X		nullexec = 1;
X	    } else if (!*nullcmd) {
X		zerr("redirection with no command", NULL, 0);
X		errflag = lastval = 1;
X		return;
X	    } else if (*readnullcmd &&
X		       ((Redir) peekfirst(cmd->redir))->type == READ &&
X		       !nextnode(firstnode(cmd->redir))) {
X		addnode(args, dupstring(readnullcmd));
X	    } else
X		addnode(args, dupstring(nullcmd));
X	else {
X	    addvars(cmd->vars, 0);
X	    if (errflag)
X		lastval = 1;
X	    return;
X	}
X    if (full(args) && *(char *)peekfirst(args) == '%') {
X	insnode(args, (Lknode) args, dupstring((bkg) ? "bg" : "fg"));
X	bkg = 0;
X    }
X    if (isset(AUTORESUME) && !bkg && empty(cmd->redir) && full(args) &&
X	!input && type == SIMPLE && !nextnode(firstnode(args))) {
X	if (unset(NOTIFY))
X	    scanjobs();
X	if (findjobnam(peekfirst(args)) != -1)
X	    pushnode(args, dupstring("fg"));
X    }
X    if (jobbing) {		/* get the text associated with this command */
X	text = getjobtext((vptr) cmd);
X    } else
X	text = NULL;
X    if (full(args) && !(cmd->flags & CFLAG_COMMAND) && type == SIMPLE) {
X	char *cmdarg = (char *)peekfirst(args);
X	Cmdnam cn2 = NULL;
X	int builtin = 0;
X
X	if (!strcmp(cmdarg, "builtin") && args->first->next &&
X	    (cn2 = (Cmdnam) gethnode(cmdarg, cmdnamtab)) &&
X	    (cn2->flags & BUILTIN) &&
X	    !(cn2->flags & EXCMD)) {
X	    builtin = 1;
X	    cmdarg = (char *)args->first->next->dat;
X	}
X	cn1 = (Cmdnam) gethnode(cmdarg, cmdnamtab);
X	if (cn1 && (cn1->flags & BUILTIN) && !(cn1->flags & EXCMD))
X	    assign = istypeset(cn1, NULL);
X	else if (builtin)
X	    assign = istypeset(NULL, cmdarg);
X	if (builtin)
X	    cn1 = cn2;
X    }
X /* do prefork substitutions */
X    prefork(args, (((type == CCASE) ? 010 : 0)
X		   | (assign ? 02 : isset(MAGICEQUALSUBST))));
X
X /* warn about "rm *" */
X    if (unset(RMSTARSILENT) && interact && isset(SHINSTDIN) &&
X	type == SIMPLE && full(args) && nextnode(firstnode(args)) &&
X	!strcmp(peekfirst(args), "rm") &&
X	!(cmd->flags & CFLAG_NOGLOB)) {
X	Lknode node, next;
X
X	for (node = nextnode(firstnode(args)); node && !errflag; node = next) {
X	    char *s = (char *)getdata(node);
X	    int l = strlen(s);
X
X	    next = nextnode(node);
X	    if (s[0] == Star && !s[1]) {
X		if (!checkrmall(pwd))
X		    uremnode(args, node);
X	    } else if (l > 2 && s[l - 2] == '/' && s[l - 1] == Star) {
X		char t = s[l - 2];
X
X		s[l - 2] = 0;
X		if (!checkrmall(s))
X		    uremnode(args, node);
X		s[l - 2] = t;
X	    }
X	}
X	if (!nextnode(firstnode(args)))
X	    errflag = 1;
X    }
X    if (errflag) {
X	lastval = 1;
X	return;
X    }
X    if (!cn1) {
X	char *s, *t;
X
X	if (full(args) && ((char *)peekfirst(args))[0] == Inbrack &&
X	    ((char *)peekfirst(args))[1] == '\0')
X	    ((char *)peekfirst(args))[0] = '[';
X	if (type == SIMPLE && full(args) && !(cmd->flags & CFLAG_COMMAND)) {
X	    cn1 = (Cmdnam) gethnode(t = s = (char *)peekfirst(args), cmdnamtab);
X	    if (!cn1 && isset(HASHCMDS) && strcmp(t, "..")) {
X		while (*t && *t != '/')
X		    t++;
X		if (!*t)
X		    cn1 = hashcmd(s, pathchecked);
X	    }
X	}
X	if (type == SIMPLE && !cn1 && isset(AUTOCD) && isset(SHINSTDIN) &&
X	    full(args) && empty(cmd->redir) &&
X	    !nextnode(firstnode(args)) && (s = cancd(peekfirst(args)))) {
X	    peekfirst(args) = (vptr) s;
X	    pushnode(args, dupstring("cd"));
X	    cn1 = (Cmdnam) gethnode("cd", cmdnamtab);
X	}
X    }
X/* this is nonzero if cmd is a current shell procedure */
X
X    iscursh = (type >= CURSH) || (type == SIMPLE && cn1 &&
X				  (cn1->flags & (BUILTIN | SHFUNC)) &&
X				  !(cn1->flags & EXCMD));
X
X/* if this command is backgrounded or (this is an external
X		command and we are not exec'ing it) or this is a builtin
X		with output piped somewhere, then fork.  If this is the
X		last stage in a subshell pipeline, don't fork, but make
X		the rest of the function think we forked. */
X
X    if (bkg || !(iscursh || (cmd->flags & CFLAG_EXEC)) ||
X	(cn1 && (cn1->flags & (BUILTIN | SHFUNC)) &&
X	 !(cn1->flags & EXCMD) && output)) {
X	int synch[2];
X
X	blockchld();
X	pipe(synch);
X	pid = (last1 && execok())? 0 : phork();
X	if (pid == -1) {
X	    close(synch[0]);
X	    close(synch[1]);
X	    return;
X	}
X	if (pid) {
X	    close(synch[1]);
X	    read(synch[0], &dummy, 1);
X	    close(synch[0]);
X	    if (pid == -1)
X		zerr("%e", NULL, errno);
X	    else {
X		if (bkg)
X		    lastpid = pid;
X		else if (!jobtab[thisjob].stty_in_env && full(cmd->vars))
X		    while (full(cmd->vars))	/* search for STTY=... */
X			if (!strcmp(((Varasg) ugetnode(cmd->vars))->name,
X				    "STTY")) {
X			    jobtab[thisjob].stty_in_env = 1;
X			    break;
X			}
X		addproc(pid, text);
X	    }
X	    return;
X	}
X	close(synch[0]);
X	entersubsh(bkg);
X	close(synch[1]);
X	forked = 1;
X
X	if (sigtrapped[SIGINT] == 2)
X	    holdintr();
X    } else if ((cmd->flags & CFLAG_EXEC) && !nullexec)
X	entersubsh(bkg);
X
X    if (bkg && isset(BGNICE))
X	nice(5);
X
X/* perform postfork substitutions */
X    postfork(args, !(cmd->flags & CFLAG_NOGLOB));
X    if (errflag) {
X	lastval = 1;
X	goto err;
X    } else {
X	char *s;
X
X	while (full(args) && (s = (char *)peekfirst(args)) && !*s)
X	    ugetnode(args);
X    }
X
X    if (input)			/* add pipeline input/output to mnodes */
X	addfd(forked, save, mfds, 0, input, 0);
X    if (output)
X	addfd(forked, save, mfds, 1, output, 1);
X    spawnpipes(cmd->redir);	/* do process substitutions */
X    while (full(cmd->redir))
X	if ((fn = (struct redir *)ugetnode(cmd->redir))->type == INPIPE) {
X	    if (fn->fd2 == -1) {
X		fixfds(save);
X		execerr();
X	    }
X	    addfd(forked, save, mfds, fn->fd1, fn->fd2, 0);
X	} else if (fn->type == OUTPIPE) {
X	    if (fn->fd2 == -1) {
X		fixfds(save);
X		execerr();
X	    }
X	    addfd(forked, save, mfds, fn->fd1, fn->fd2, 1);
X	} else {
X	    if (!(fn->type == HERESTR || fn->type == CLOSE || fn->type ==
X		  MERGE || fn->type == MERGEOUT))
X		if (xpandredir(fn, cmd->redir))
X		    continue;
X	    if (errflag) {
X		fixfds(save);
X		execerr();
X	    }
X	    if (fn->type == HERESTR) {
X		fil = getherestr(fn);
X		if (fil == -1) {
X		    fixfds(save);
X		    if (errno != EINTR)
X			zerr("%e", NULL, errno);
X		    execerr();
X		}
X		addfd(forked, save, mfds, fn->fd1, fil, 0);
X	    } else if (fn->type == READ) {
X		fil = open(fn->name, O_RDONLY);
X		if (fil == -1) {
X		    fixfds(save);
X		    if (errno != EINTR)
X			zerr("%e: %s", fn->name, errno);
X		    execerr();
X		}
X		addfd(forked, save, mfds, fn->fd1, fil, 0);
X	    } else if (fn->type == CLOSE) {
X		if (!forked && fn->fd1 < 10)
X		    save[fn->fd1] = movefd(fn->fd1);
X		closemn(mfds, fn->fd1);
X		close(fn->fd1);
X	    } else if (fn->type == MERGE || fn->type == MERGEOUT) {
X		if (fn->fd2 == FD_COPROC)
X		    fn->fd2 = (fn->type == MERGEOUT) ? coprocout : coprocin;
X		closemn(mfds, fn->fd1);
X		fil = dup(fn->fd2);
X		if (fil == -1) {
X		    char fdstr[4];
X
X		    fixfds(save);
X		    sprintf(fdstr, "%d", fn->fd2);
X		    zerr("%s: %e", fdstr, errno);
X		    execerr();
X		}
X		addfd(forked, save, mfds, fn->fd1, fil, fn->type == MERGEOUT);
X	    } else {
X		if (fn->type >= APP)
X		    fil = open(fn->name,
X			       (isset(NOCLOBBER) && !(fn->type & 1)) ?
X			       O_WRONLY | O_APPEND : O_WRONLY | O_APPEND | O_CREAT, 0666);
X		else
X		    fil = open(fn->name, dontclob(fn) ?
X			       O_WRONLY | O_CREAT | O_EXCL : O_WRONLY | O_CREAT | O_TRUNC, 0666);
X		if (fil == -1) {
X		    fixfds(save);
X		    if (errno != EINTR)
X			zerr("%e: %s", fn->name, errno);
X		    execerr();
X		}
X		addfd(forked, save, mfds, fn->fd1, fil, 1);
X	    }
X	}
X
X/* we are done with redirection.  close the mnodes, spawning
X		tee/cat processes as necessary. */
X    for (t0 = 0; t0 != 10; t0++)
X	closemn(mfds, t0);
X
X    if (nullexec) {
X	for (t0 = 0; t0 != 10; t0++)
X	    if (save[t0] != -1)
X		close(save[t0]);
X	return;
X    }
X    if (unset(NOEXEC))
X	if (type >= CURSH) {
X	    static int (*func[]) DCLPROTO((Cmd)) =
X	    {
X		execcursh, exectime, execfuncdef, execfor, execwhile,
X		execrepeat, execif, execcase, execselect, execcond};
X
X	    fixcline(args);
X	    lastval = (func[type - CURSH]) (cmd);
X	} else if (iscursh) {	/* builtin or shell function */
X	    if (!cn1) {
X		lastval = 1;
X		return;
X	    }
X	    if (cmd->vars) {
X		addvars(cmd->vars, 0);
X		if (errflag) {
X		    lastval = 1;
X		    return;
X		}
X	    }
X	    fixcline(args);
X	    if (cn1->flags & SHFUNC)
X		execshfunc(cmd, cn1);
X	    else {
X		if (forked)
X		    closem();
X		lastval = execbin(args, cn1);
X		if (isset(PRINTEXITVALUE) && isset(SHINSTDIN) &&
X		    lastval && !subsh) {
X		    fprintf(stderr, "zsh: exit %ld\n", (long)lastval);
X		}
X		fflush(stdout);
X		if (save[1] == -1) {
X		    if (ferror(stdout)) {
X			zerr("write error: %e", NULL, errno);
X			clearerr(stdout);
X			errflag = 0;
X		    }
X		} else
X		    clearerr(stdout);
X	    }
X	} else {
X	    if (cmd->flags & CFLAG_EXEC)
X		setiparam("SHLVL", --shlvl);
X	    if (cmd->vars) {
X		addvars(cmd->vars, 1);
X		if (errflag) {
X		    lastval = 1;
X		    return;
X		}
X	    }
X	    if (type == SIMPLE) {
X		closem();
X		execute(cmd->flags & CFLAG_DASH);
X	    } else		/* ( ... ) */
X		execlist(cmd->u.list);
X	}
X  err:
X    if (forked)
X	_exit(lastval);
X    fixfds(save);
X}
X
X/* restore fds after redirecting a builtin */
X
Xvoid fixfds(save)		/**/
Xint *save;
X{
X    int old_errno = errno;
X    int t0;
X
X    for (t0 = 0; t0 != 10; t0++)
X	if (save[t0] != -1)
X	    redup(save[t0], t0);
X    errno = old_errno;
X}
X
Xvoid entersubsh(bkg)		/**/
Xint bkg;
X{
X    if (!jobbing) {
X	if (bkg) {
X	    sigtrapped[SIGINT] = 2;
X	    sig_ignore(SIGINT);
X	    sigtrapped[SIGQUIT] = 2;
X	    sig_ignore(SIGQUIT);
X	    if (isatty(0)) {
X		close(0);
X		if (open("/dev/null", O_RDWR)) {
X		    zerr("can't open /dev/null: %e", NULL, errno);
X		    _exit(1);
X		}
X	    }
X	}
X    } else if (thisjob != -1) {
X	if (!jobtab[thisjob].gleader) {
X	    jobtab[thisjob].gleader = getpid();
X	    setpgrp(0L, jobtab[thisjob].gleader);
X	    if (!bkg)
X		attachtty(jobtab[thisjob].gleader);
X	} else
X	    setpgrp(0L, jobtab[thisjob].gleader);
X    }
X    subsh = 1;
X    if (SHTTY != -1) {
X	close(SHTTY);
X	SHTTY = -1;
X    }
X    if (jobbing) {
X	sig_default(SIGTTOU);
X	sig_default(SIGTTIN);
X	sig_default(SIGTSTP);
X	sig_default(SIGPIPE);
X    }
X    if (interact) {
X	sig_default(SIGTERM);
X	if (sigtrapped[SIGINT] != 2)
X	    sig_default(SIGINT);
X    }
X    if (sigtrapped[SIGQUIT] != 2)
X	sig_default(SIGQUIT);
X    opts[MONITOR] = OPT_UNSET;
X    opts[USEZLE] = OPT_UNSET;
X    clearjobtab();
X}
X
X/* close all internal shell fds */
X
Xvoid closem()
X{				/**/
X    int t0;
X
X    for (t0 = 10; t0 != NOFILE; t0++)
X	close(t0);
X}
X
X/* convert here document into a here string */
X
Xchar *gethere(str, typ)		/**/
Xchar *str;
Xint typ;
X{
X    char pbuf[256];
X    int qt = 0, siz = 0, l, strip = 0;
X    char *s, *t, *bptr;
X
X    for (s = str; *s; s++)
X	if (INULL(*s)) {
X	    *s = Nularg;
X	    qt = 1;
X	}
X    untokenize(str);
X    if (typ == HEREDOCDASH) {
X	strip = 1;
X	while (*str == '\t')
X	    str++;
X    }
X    t = ztrdup("");
X    for (;;) {
X	char *u, *v;
X
X	if (!hgets(pbuf, sizeof(pbuf)))
X	    break;
X	bptr = pbuf;
X	if (strip)
X	    while (*bptr == '\t')
X		bptr++;
X	for (u = bptr, v = str; *u != '\n' && *v; u++, v++)
X	    if (*u != *v)
X		break;
X	if (!(*u == '\n' && !*v)) {
X	    l = strlen(bptr);
X	    if (!qt && l > 1 && bptr[l - 1] == '\n' && bptr[l - 2] == '\\')
X		bptr[l -= 2] = '\0';
X	    t = realloc(t, siz + l + 1);
X	    strncpy(t + siz, bptr, l);
X	    siz += l;
X	} else
X	    break;
X    }
X    t[siz] = '\0';
X    if (siz && t[siz - 1] == '\n')
X	t[siz - 1] = '\0';
X    if (!qt)
X	for (s = t; *s; s++)
X	    if (*s == '$') {
X		*s = Qstring;
X	    } else if (*s == '`') {
X		*s = Qtick;
X	    } else if (*s == '(') {
X		*s = Inpar;
X	    } else if (*s == ')') {
X		*s = Outpar;
X	    } else if (*s == '\\' &&
X		       (s[1] == '$' || s[1] == '`'))
X		chuck(s);
X    s = dupstring(t);
X    zsfree(t);
X    return s;
X}
X
X/* open here string fd */
X
Xint getherestr(fn)		/**/
Xstruct redir *fn;
X{
X    Lklist fake;
X    char *s = gettemp(), *t;
X    int fd;
X
X    fake = newlist();
X    addnode(fake, fn->name);
X    prefork(fake, 010);
X    if (!errflag)
X	postfork(fake, 011);
X    if (errflag)
X	return -1;
X    if ((fd = open(s, O_CREAT | O_WRONLY, 0600)) == -1)
X	return -1;
X    while ((t = (char *)ugetnode(fake))) {
X	untokenize(t);
X	write(fd, t, strlen(t));
X	if (full(fake))
X	    write(fd, " ", 1);
X    }
X    write(fd, "\n", 1);
X    close(fd);
X    fd = open(s, O_RDONLY);
X    unlink(s);
X    return fd;
X}
X
Xvoid catproc(mn)		/**/
Xstruct multio *mn;
X{
X    int len, t0;
X    char *buf;
X
X    if (phork()) {
X	for (t0 = 0; t0 != mn->ct; t0++)
X	    close(mn->fds[t0]);
X	close(mn->pipe);
X	return;
X    }
X    closeallelse(mn);
X    buf = (char *)zalloc(4092);
X    for (t0 = 0; t0 != mn->ct; t0++)
X	while ((len = read(mn->fds[t0], buf, 4092)))
X	    write(mn->pipe, buf, len);
X    _exit(0);
X}
X
Xvoid teeproc(mn)		/**/
Xstruct multio *mn;
X{
X    int len, t0;
X    char *buf;
X
X    if (phork()) {
X	for (t0 = 0; t0 != mn->ct; t0++)
X	    close(mn->fds[t0]);
X	close(mn->pipe);
X	return;
X    }
X    buf = (char *)zalloc(4092);
X    closeallelse(mn);
X    while ((len = read(mn->pipe, buf, 4092)) > 0)
X	for (t0 = 0; t0 != mn->ct; t0++)
X	    write(mn->fds[t0], buf, len);
X    _exit(0);
X}
X
Xvoid closeallelse(mn)		/**/
Xstruct multio *mn;
X{
X    int t0, t1;
X
X    for (t0 = 0; t0 != NOFILE; t0++)
X	if (mn->pipe != t0) {
X	    for (t1 = 0; t1 != mn->ct; t1++)
X		if (mn->fds[t1] == t0)
X		    break;
X	    if (t1 == mn->ct)
X		close(t0);
X	}
X}
X
Xlong int zstrtol(s, t, base)	/**/
Xchar *s;
Xchar **t;
Xint base;
X{
X    int ret = 0;
X
X    if (base <= 10)
X	for (; *s >= '0' && *s < ('0' + base); s++)
X	    ret = ret * base + *s - '0';
X    else
X	for (; idigit(*s) || (*s >= 'a' && *s < ('a' + base - 10))
X	     || (*s >= 'A' && *s < ('A' + base - 10)); s++)
X	    ret = ret * base + (idigit(*s) ? (*s - '0') : (*s & 0x1f) + 9);
X    if (t)
X	*t = (char *)s;
X    return ret;
X}
X
X/* $(...) */
X
XLklist getoutput(cmd, qt)	/**/
Xchar *cmd;
Xint qt;
X{
X    List list;
X    int pipes[2];
X    int pid;
X
X    if (*cmd == '<') {
X	int stream;
X	char *fi, *s, x;
X
X	for (cmd++; *cmd == ' '; cmd++);
X	for (s = cmd; *s && *s != ' '; s++)
X	    if (*s == '\\')
X		s++;
X	    else if (*s == '$')
X		*s = String;
X	x = *s;
X	*s = '\0';
X	fi = dupstring(cmd);
X	*s = x;
X	if (*fi == '~')
X	    *fi = Tilde;
X	else if (*fi == '=')
X	    *fi = Equals;
X	singsub(&fi);
X	if (errflag)
X	    return NULL;
X	stream = open(fi, O_RDONLY);
X	if (stream == -1) {
X	    zerr("%e: %s", fi, errno);
X	    return NULL;
X	}
X	return readoutput(stream, qt);
X    }
X    if (!(list = parselstring(cmd)))
X	return NULL;
X    mpipe(pipes);
X    blockchld();
X    if ((cmdoutpid = pid = phork()) > 0) {
X	Lklist retval;
X
X	popheap();
X	close(pipes[1]);
X	retval = readoutput(pipes[0], qt);
X	chldsuspend(0);		/* unblocks */
X	lastval = cmdoutval;
X	cmdoutval = 0;
X	return retval;
X    } else if (pid == -1) {
X	popheap();
X	close(pipes[0]);
X	close(pipes[1]);
X	errflag = 1;
X	cmdoutpid = 0;
X	unblockchld();
X	return NULL;
X    }
X    unblockchld();
X    subsh = 1;
X    close(pipes[0]);
X    redup(pipes[1], 1);
X    entersubsh(0);
X    sig_ignore(SIGTSTP);
X    exiting = 1;
X    execlist(list);
X    close(1);
X    _exit(lastval);
X    zerr("exit returned in child!!", NULL, 0);
X    kill(getpid(), SIGKILL);
X    return NULL;		/* redundant but shuts up Convex cc */
X}
X
X/* read output of command substitution */
X
XLklist readoutput(in, qt)	/**/
Xint in;
Xint qt;
X{
X    Lklist ret;
X    char *buf, *ptr;
X    int bsiz, c, cnt = 0;
X    FILE *fin;
X
X    fin = fdopen(in, "r");
X    ret = newlist();
X    ptr = buf = (char *)ncalloc(bsiz = 64);
X    if (qt) {
X	*ptr++ = Nularg;
X	cnt++;
X    }
X    while ((c = fgetc(fin)) != EOF)
X	if (!qt && isep(c)) {
X	    if (cnt) {
X		*ptr = '\0';
X		if (isset(GLOBSUBST))
X		    tokenize(buf);
X		addnode(ret, buf);
X		ptr = buf = (char *)ncalloc(bsiz = 64);
X		cnt = 0;
X	    }
X	} else {
X	    *ptr++ = c;
X	    if (++cnt == bsiz) {
X		char *pp = (char *)ncalloc(bsiz *= 2);
X
X		memcpy(pp, buf, cnt);
X		ptr = (buf = pp) + cnt;
X	    }
X	}
X    if (ptr != buf && ptr[-1] == '\n')
X	ptr[-1] = '\0';
X    else
X	*ptr = '\0';
X    if (!qt && isset(GLOBSUBST))
X	tokenize(buf);
X    if (cnt)
X	addnode(ret, buf);
X    fclose(fin);
X    return ret;
X}
X
X/* =(...) */
X
Xchar *getoutputfile(cmd)	/**/
Xchar *cmd;
X{
X    int pid;
X    char *nam = gettemp(), *str;
X    List list;
X
X    if (thisjob == -1)
X	return NULL;
X    for (str = cmd; *str && *str != Outpar; str++);
X    if (!*str)
X	zerr("oops.", NULL, 0);
X    *str = '\0';
X    if (!(list = parselstring(cmd)))
X	return NULL;
X    permalloc();
X    if (!jobtab[thisjob].filelist)
X	jobtab[thisjob].filelist = newlist();
X    addnode(jobtab[thisjob].filelist, ztrdup(nam));
X    heapalloc();
X    blockchld();
X    if ((pid = cmdoutpid = phork())) {
X	popheap();
X	if (pid < 0)
X	    unblockchld();
X	else {
X	    int os = jobtab[thisjob].stat;
X
X	    waitforpid(pid);
X	    cmdoutval = 0;
X	    jobtab[thisjob].stat = os;
X	}
X	return nam;
X    }
X    subsh = 1;
X    close(1);
X    entersubsh(0);
X    (void)creat(nam, 0666);
X    exiting = 1;
X    execlist(list);
X    close(1);
X    _exit(lastval);
X    zerr("exit returned in child!!", NULL, 0);
X    kill(getpid(), SIGKILL);
X    return NULL;		/* redundant but shuts up Convex cc */
X}
X
X/* get a temporary named pipe */
X
Xchar *namedpipe()
X{				/**/
X#ifdef HAS_FIFOS
X    char *tnam = gettemp();
X
X    if (mknod(tnam, 0010666, 0) < 0)
X	return NULL;
X    return tnam;
X#else
X         return NULL;
X#endif
X}
X
X/* <(...) */
X
Xchar *getoutproc(cmd)		/**/
Xchar *cmd;
X{
X#ifndef HAS_FIFOS
X    zerr("doesn't look like your system supports FIFOs.", NULL, 0);
X    return NULL;
X#else
X    List list;
X    int fd;
X    char *pnam, *str;
X
X    if (thisjob == -1)
X	return NULL;
X    for (str = cmd; *str && *str != Outpar; str++);
X    if (!*str)
X	zerr("oops.", NULL, 0);
X    *str = '\0';
X    pnam = namedpipe();
X    if (!pnam)
X	return NULL;
X    permalloc();
X    if (!jobtab[thisjob].filelist)
X	jobtab[thisjob].filelist = newlist();
X    addnode(jobtab[thisjob].filelist, ztrdup(pnam));
X    heapalloc();
X    if (!(list = parselstring(cmd)))
X	return NULL;
X    if (phork()) {
X	popheap();
X	return pnam;
X    }
X    entersubsh(1);
X    closem();
X    fd = open(pnam, O_WRONLY);
X    if (fd == -1) {
X	zerr("can't open %s: %e", pnam, errno);
X	_exit(1);
X    }
X    redup(fd, 1);
X    fd = open("/dev/null", O_RDONLY);
X    redup(fd, 0);
X    exiting = 1;
X    execlist(list);
X    close(1);
X    _exit(lastval);
X    return NULL;
X#endif
X}
X
X/* >(...) */
X
Xchar *getinproc(cmd)		/**/
Xchar *cmd;
X{
X#ifndef HAS_FIFOS
X    zerr("doesn't look like your system supports FIFOs.", NULL, 0);
X    return NULL;
X#else
X    List list;
X    int pid, fd;
X    char *pnam, *str;
X
X    if (thisjob == -1)
X	return NULL;
X    for (str = cmd; *str && *str != Outpar; str++);
X    if (!*str)
X	zerr("oops.", NULL, 0);
X    *str = '\0';
X    pnam = namedpipe();
X    if (!pnam)
X	return NULL;
X    permalloc();
X    if (!jobtab[thisjob].filelist)
X	jobtab[thisjob].filelist = newlist();
X    addnode(jobtab[thisjob].filelist, ztrdup(pnam));
X    heapalloc();
X    if (!(list = parselstring(cmd)))
X	return NULL;
X    if ((pid = phork())) {
X	popheap();
X	return pnam;
X    }
X    entersubsh(1);
X    closem();
X    fd = open(pnam, O_RDONLY);
X    redup(fd, 0);
X    exiting = 1;
X    execlist(list);
X    _exit(lastval);
X    return NULL;
X#endif
X}
X
X/* > >(...) (does not use named pipes) */
X
Xint getinpipe(cmd)		/**/
Xchar *cmd;
X{
X    List list;
X    int pipes[2];
X    char *str;
X
X    for (str = cmd; *str && *str != Outpar; str++);
X    if (!*str)
X	zerr("oops.", NULL, 0);
X    *str = '\0';
X    if (!(list = parselstring(cmd + 2)))
X	return -1;
X    mpipe(pipes);
X    if (phork()) {
X	popheap();
X	close(pipes[1]);
X	return pipes[0];
X    }
X    close(pipes[0]);
X    closem();
X    entersubsh(1);
X    redup(pipes[1], 1);
X    exiting = 1;
X    execlist(list);
X    _exit(lastval);
X    return 0;
X}
X
X/* < <(...) */
X
Xint getoutpipe(cmd)		/**/
Xchar *cmd;
X{
X    List list;
X    int pipes[2];
X    char *str;
X
X    for (str = cmd; *str && *str != Outpar; str++);
X    if (!*str)
X	zerr("oops.", NULL, 0);
X    *str = '\0';
X    if (!(list = parselstring(cmd + 2)))
X	return -1;
X    strinend();
X    mpipe(pipes);
X    if (phork()) {
X	popheap();
X	close(pipes[0]);
X	return pipes[1];
X    }
X    close(pipes[1]);
X    entersubsh(1);
X    redup(pipes[0], 0);
X    closem();
X    exiting = 1;
X    execlist(list);
X    _exit(lastval);
X    return 0;
X}
X
X/* run a list, saving the current job num */
X
Xvoid runlist(l)			/**/
XList l;
X{
X    int cj = thisjob;
X
X    execlist(l);
X    thisjob = cj;
X}
X
Xchar *gettemp()
X{				/**/
X    return mktemp(dyncat((tmpprefix ? tmpprefix : DEFTMPPREFIX), "XXXXXX"));
X}
X
X/* my getwd */
X
Xchar *zgetwd()
X{				/**/
X    static char buf0[MAXPATHLEN];
X    char buf3[MAXPATHLEN];
X
X#ifdef apollo
X    char *buf2 = buf0 + 2;	/* changed +1 to +2  RBC 17.11.91 */
X
X#else
X    char *buf2 = buf0 + 1;
X
X#endif
X    struct stat sbuf;
X    struct dirent *de;
X    DIR *dir;
X    ino_t ino, rootino = (ino_t) ~ 0;
X    dev_t dev, rootdev = (dev_t) ~ 0;
X
X    holdintr();
X    buf2[0] = '\0';
X    buf0[0] = '/';
X#ifdef apollo
X    buf0[1] = '/';		/* added RBC 17.11.91 */
X#endif
X    if (stat(buf0, &sbuf) >= 0) {
X	rootino = sbuf.st_ino;
X	rootdev = sbuf.st_dev;
X    }
X    for (;;) {
X	if (stat(".", &sbuf) < 0) {
X	    chdir(buf0);
X	    noholdintr();
X	    return ztrdup(".");
X	}
X	ino = sbuf.st_ino;
X	dev = sbuf.st_dev;
X	if (stat("..", &sbuf) < 0) {
X	    chdir(buf0);
X	    noholdintr();
X	    return ztrdup(".");
X	}
X	if ((sbuf.st_ino == ino && sbuf.st_dev == dev) ||
X	    (ino == rootino && dev == rootdev)) {
X	    chdir(buf0);
X	    noholdintr();
X	    return ztrdup(buf0);
X	}
X	dir = opendir("..");
X	if (!dir) {
X	    chdir(buf0);
X	    noholdintr();
X	    return ztrdup(".");
X	}
X	chdir("..");
X	readdir(dir);
X	readdir(dir);
X	while ((de = readdir(dir)))
X	    if (de->d_ino == ino) {
X		lstat(de->d_name, &sbuf);
X		if (sbuf.st_dev == dev)
X		    goto match;
X	    }
X	closedir(dir);
X	dir = opendir(".");
X	readdir(dir);
X	readdir(dir);
X	while ((de = readdir(dir))) {
X	    lstat(de->d_name, &sbuf);
X	    if (sbuf.st_dev == dev)
X		goto match;
X	}
X	noholdintr();
X	closedir(dir);
X	return ztrdup(".");
X      match:
X	strcpy(buf3, de->d_name);
X	if (*buf2)
X	    strcat(buf3, "/");
X	strcat(buf3, buf2);
X	strcpy(buf2, buf3);
X	closedir(dir);
X    }
X}
X
X/* open pipes with fds >= 10 */
X
Xvoid mpipe(pp)			/**/
Xint *pp;
X{
X    pipe(pp);
X    pp[0] = movefd(pp[0]);
X    pp[1] = movefd(pp[1]);
X}
X
X/* do process substitution with redirection */
X
Xvoid spawnpipes(l)		/**/
XLklist l;
X{
X    Lknode n = firstnode(l);
X    Redir f;
X
X    for (; n; incnode(n)) {
X	f = (Redir) getdata(n);
X	if (f->type == OUTPIPE) {
X	    char *str = f->name;
X
X	    f->fd2 = getoutpipe(str);
X	}
X	if (f->type == INPIPE) {
X	    char *str = f->name;
X
X	    f->fd2 = getinpipe(str);
X	}
X    }
X}
X
X/* perform time ... command */
X
Xint exectime(cmd)		/**/
XCmd cmd;
X{
X    int jb = thisjob;
X
X    if (!cmd->u.pline) {
X	shelltime();
X	return 0;
X    }
X    execpline(cmd->u.pline, TIMED, 0);
X    thisjob = jb;
X    return lastval;
X}
X
X/* define a function */
X
Xint execfuncdef(cmd)		/**/
XCmd cmd;
X{
X    Cmdnam cc;
X    char *s;
X
X    permalloc();
X    while ((s = (char *)ugetnode(cmd->args))) {
X	cc = (Cmdnam) zalloc(sizeof *cc);
X	cc->flags = SHFUNC;
X	if (!cmd->u.list)
X	    cc->u.list = NULL;
X	else
X	    cc->u.list = (List) dupstruct(cmd->u.list);
X	addhnode(ztrdup(s), cc, cmdnamtab, freecmdnam);
X	if (!strncmp(s, "TRAP", 4)) {
X	    int t0 = getsignum(s + 4);
X
X	    if (t0 != -1) {
X		settrap(t0, cmd->u.list);
X		permalloc();
X	    }
X	}
X    }
X    heapalloc();
X    return 0;
X}
X
X/* evaluate a [[ ... ]] */
X
Xint execcond(cmd)		/**/
XCmd cmd;
X{
X    return !evalcond(cmd->u.cond);
X}
X
Xvoid execshfunc(cmd, cn)	/**/
XCmd cmd;
XCmdnam cn;
X{
X    List l;
X
X    if (errflag)
X	return;
X    if (!cn->u.list) {
X	char *nam;
X
X	if (!(cn->flags & PMFLAG_u))
X	    return;
X	if (!(l = getfpfunc(nam = (char *)peekfirst(cmd->args)))) {
X	    zerr("function not found: %s", nam, 0);
X	    lastval = 1;
X	    return;
X	}
X	cn->flags &= ~PMFLAG_u;
X	permalloc();
X	cn->u.list = (List) dupstruct(l);
X	heapalloc();
X	popheap();
X    }
X    doshfunc(cn->u.list, cmd->args, cn->flags);
X}
X
Xvoid doshfuncnoval(list, doshargs, flags)	/**/
XList list;
XLklist doshargs;
Xint flags;
X{
X    int val = lastval;
X
X    doshfunc(list, doshargs, flags);
X    lastval = val;
X}
X
Xvoid doshfunc(list, doshargs, flags)	/**/
XList list;
XLklist doshargs;
Xint flags;
X{
X    char **tab, **x, *oargv0;
X    int oxtr = opts[XTRACE], opev = opts[PRINTEXITVALUE], xexittr;
X    int oldzoptind;
X    Lklist olist;
X    char *s;
X    List xexitfn;
X
X    pushheap();
X    xexittr = sigtrapped[SIGEXIT];
X    xexitfn = sigfuncs[SIGEXIT];
X    tab = pparams;
X    oargv0 = argzero;
X    oldzoptind = zoptind;
X    zoptind = 1;
X    if (flags & PMFLAG_t)
X	opts[XTRACE] = OPT_SET;
X    opts[PRINTEXITVALUE] = OPT_UNSET;
X    if (doshargs) {
X	pparams = x =
X	    (char **)zcalloc(((sizeof *x) * (1 + countnodes(doshargs))));
X	argzero = ztrdup(ugetnode(doshargs));
X	while ((*x = (char *)ugetnode(doshargs)))
X	    *x = ztrdup(*x), x++;
X    } else {
X	pparams = (char **)zcalloc(sizeof *pparams);
X	argzero = ztrdup(argzero);
X    }
X    permalloc();
X    olist = locallist;
X    locallist = newlist();
X    locallevel++;
X    heapalloc();
X    runlist(dupstruct(list));
X    locallevel--;
X    while ((s = (char *)getnode(locallist))) {
X	Param pm = (Param) gethnode(s, paramtab);
X
X	if (pm && pm->level > locallevel)
X	    unsetparam(s);
X	zsfree(s);
X    }
X    zfree(locallist, sizeof(struct lklist));
X
X    locallist = olist;
X    breaks = retflag = 0;
X    freearray(pparams);
X    zsfree(argzero);
X    zoptind = oldzoptind;
X    argzero = oargv0;
X    pparams = tab;
X    if (sigfuncs[SIGEXIT] && sigfuncs[SIGEXIT] != xexitfn) {
X	dotrap(SIGEXIT);
X	freestruct(sigfuncs[SIGEXIT]);
X    }
X    sigtrapped[SIGEXIT] = xexittr;
X    sigfuncs[SIGEXIT] = xexitfn;
X    opts[XTRACE] = oxtr;
X    opts[PRINTEXITVALUE] = opev;
X    popheap();
X}
X
X/* search fpath for an undefined function */
X
XList getfpfunc(s)		/**/
Xchar *s;
X{
X    char **pp = fpath, buf[MAXPATHLEN];
X    int fd;
X
X    for (; *pp; pp++) {
X	sprintf(buf, "%s/%s", *pp, s);
X	if (!access(buf, R_OK) && (fd = open(buf, O_RDONLY)) != -1) {
X	    int len = lseek(fd, 0, 2);
X
X	    if (len == -1)
X		close(fd);
X	    else {
X		char *d;
X		List r;
X
X		lseek(fd, 0, 0);
X		d = (char *)zcalloc(len + 1);
X		if (read(fd, d, len) != len) {
X		    zfree(d, len + 1);
X		    close(fd);
X		} else {
X		    close(fd);
X		    r = parselstring(d);
X		    zfree(d, len + 1);
X
X		    return r;
X		}
X	    }
X	}
X    }
X    return NULL;
X}
X
X/* check to see if AUTOCD applies here */
X
Xextern int doprintdir;
X
Xchar *cancd(s)			/**/
Xchar *s;
X{
X    int nocdpath = s[0] == '.' &&
X    (s[1] == '/' || !s[1] || (s[1] == '.' && (s[2] == '/' || !s[1])));
X    char *t;
X
X    if (*s != '/') {
X	char sbuf[MAXPATHLEN], **cp;
X
X	if (cancd2(s))
X	    return s;
X	if (access(s, X_OK) == 0)
X	    return NULL;
X	if (!nocdpath)
X	    for (cp = cdpath; *cp; cp++) {
X		sprintf(sbuf, "%s/%s", *cp, s);
X		if (cancd2(sbuf)) {
X		    doprintdir = -1;
X		    return dupstring(sbuf);
X		}
X	    }
X	if ((t = cd_able_vars(s))) {
X	    if (cancd2(t)) {
X		doprintdir = -1;
X		return t;
X	    }
X	}
X	return NULL;
X    }
X    return cancd2(s) ? s : NULL;
X}
X
Xint cancd2(s)			/**/
Xchar *s;
X{
X    struct stat buf;
X
X    return !(access(s, X_OK) || stat(s, &buf) || !S_ISDIR(buf.st_mode));
X}
END_OF_FILE
  if test 43966 -ne `wc -c <'zsh-2.5.0/src/exec.c'`; then
    echo shar: \"'zsh-2.5.0/src/exec.c'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/src/exec.c'
fi
if test -f 'zsh-2.5.0/src/params.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zsh-2.5.0/src/params.c'\"
else
  echo shar: Extracting \"'zsh-2.5.0/src/params.c'\" \(33893 characters\)
  sed "s/^X//" >'zsh-2.5.0/src/params.c' <<'END_OF_FILE'
X/*
X *
X * params.c - parameters
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made.
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk.
X *
X */
X
X#include "zsh.h"
X#include "version.h"
X#include <pwd.h>
X
Xstatic Param argvparam;
X
Xstruct iparam {
X    struct hashnode *next;
X    char *nam;			/* hash data */
X    vptr value;
X    int (*func1) ();		/* set func */
X    int (*func2) ();		/* get func */
X    int ct;			/* output base or field width */
X    int flags;
X    vptr data;			/* used by getfns */
X    char *env;			/* location in environment, if exported */
X    char *ename;		/* name of corresponding environment var */
X    Param old;			/* old struct for use with local */
X    int level;			/* if (old != NULL), level of localness */
X};
X
X#define IFN(X) ((int (*)())(X))
X
X/* put predefined params in hash table */
X
Xvoid setupparams()
X{				/**/
X    static struct iparam pinit[] =
X    {
X#define IPDEF1(A,B,C,D) {NULL,A,NULL,IFN(C),IFN(B),10,\
X		PMFLAG_i|PMFLAG_SPECIAL|D,NULL,NULL,NULL,NULL,0}
X	IPDEF1("#", poundgetfn, IFN(nullsetfn), PMFLAG_r),
X	IPDEF1("ARGC", poundgetfn, IFN(nullsetfn), PMFLAG_r),
X	IPDEF1("ERRNO", errnogetfn, IFN(nullsetfn), PMFLAG_r),
X	IPDEF1("GID", gidgetfn, IFN(nullsetfn), PMFLAG_r),
X	IPDEF1("EGID", egidgetfn, IFN(nullsetfn), PMFLAG_r),
X	IPDEF1("HISTSIZE", histsizegetfn, histsizesetfn, 0),
X	IPDEF1("LITHISTSIZE", lithistsizegetfn, lithistsizesetfn, 0),
X	IPDEF1("RANDOM", randomgetfn, randomsetfn, 0),
X	IPDEF1("SECONDS", secondsgetfn, secondssetfn, 0),
X	IPDEF1("UID", uidgetfn, IFN(nullsetfn), PMFLAG_r),
X	IPDEF1("EUID", euidgetfn, IFN(nullsetfn), PMFLAG_r),
X
X#define IPDEF2(A,B,C,D) {NULL,A,NULL,IFN(C),IFN(B),0,\
X		PMFLAG_SPECIAL|D,NULL,NULL,NULL,NULL,0}
X	IPDEF2("-", dashgetfn, IFN(nullsetfn), PMFLAG_r),
X	IPDEF2("HISTCHARS", histcharsgetfn, histcharssetfn, 0),
X	IPDEF2("HOME", homegetfn, homesetfn, 0),
X	IPDEF2("TERM", termgetfn, termsetfn, 0),
X	IPDEF2("WORDCHARS", wordcharsgetfn, wordcharssetfn, 0),
X	IPDEF2("IFS", ifsgetfn, ifssetfn, 0),
X	IPDEF2("_", underscoregetfn, IFN(nullsetfn), PMFLAG_r),
X
X#define IPDEF3(A) {NULL,A,NULL,IFN(nullsetfn),IFN(strconstgetfn),0,PMFLAG_r|\
X		PMFLAG_SPECIAL,NULL,NULL,NULL,NULL,0}
X	IPDEF3("HOSTTYPE"),
X	IPDEF3("VERSION"),
X
X#define IPDEF4(A,B) {NULL,A,NULL,IFN(nullsetfn),IFN(intvargetfn),10,\
X		PMFLAG_r|PMFLAG_i|PMFLAG_SPECIAL,(vptr)B,NULL,NULL,NULL,0}
X	IPDEF4("!", &lastpid),
X	IPDEF4("$", &mypid),
X	IPDEF4("?", &lastval),
X	IPDEF4("status", &lastval),
X	IPDEF4("LINENO", &lineno),
X	IPDEF4("PPID", &ppid),
X
X#define IPDEF5(A,B) {NULL,A,NULL,IFN(intvarsetfn),IFN(intvargetfn),10,\
X		PMFLAG_i|PMFLAG_SPECIAL,(vptr)B,NULL,NULL,NULL,0}
X	IPDEF5("BAUD", &baud),
X	IPDEF5("COLUMNS", &columns),
X	IPDEF5("DIRSTACKSIZE", &dirstacksize),
X	IPDEF5("KEYTIMEOUT", &keytimeout),
X	IPDEF5("LINES", &lines),
X	IPDEF5("LISTMAX", &listmax),
X	IPDEF5("LOGCHECK", &logcheck),
X	IPDEF5("MAILCHECK", &mailcheck),
X	IPDEF5("OPTIND", &zoptind),
X	IPDEF5("PERIOD", &period),
X	IPDEF5("REPORTTIME", &reporttime),
X	IPDEF5("SAVEHIST", &savehist),
X	IPDEF5("SHLVL", &shlvl),
X	IPDEF5("TMOUT", &tmout),
X
X#define IPDEF6(A,B) {NULL,A,NULL,IFN(nullsetfn),IFN(strvargetfn),0,\
X		PMFLAG_r|PMFLAG_SPECIAL,(vptr)B,NULL,NULL,NULL,0}
X	IPDEF6("LOGNAME", &zlogname),
X	IPDEF6("PWD", &pwd),
X	IPDEF6("TTY", &ttystrname),
X	IPDEF6("USERNAME", &username),
X
X#define IPDEF7(A,B) {NULL,A,NULL,IFN(strvarsetfn),IFN(strvargetfn),0,\
X		PMFLAG_SPECIAL,(vptr)B,NULL,NULL,NULL,0}
X	IPDEF7("FCEDIT", &fceditparam),
X	IPDEF7("HOST", &hostnam),
X	IPDEF7("OLDPWD", &oldpwd),
X	IPDEF7("OPTARG", &zoptarg),
X	IPDEF7("MAIL", &mailfile),
X	IPDEF7("NULLCMD", &nullcmd),
X	IPDEF7("POSTEDIT", &postedit),
X	IPDEF7("prompt", &prompt),
X	IPDEF7("PROMPT", &prompt),
X	IPDEF7("PROMPT2", &prompt2),
X	IPDEF7("PROMPT3", &prompt3),
X	IPDEF7("PROMPT4", &prompt4),
X	IPDEF7("READNULLCMD", &readnullcmd),
X	IPDEF7("RPROMPT", &rprompt),
X	IPDEF7("PS1", &prompt),
X	IPDEF7("PS2", &prompt2),
X	IPDEF7("PS3", &prompt3),
X	IPDEF7("PS4", &prompt4),
X	IPDEF7("RPS1", &rprompt),
X	IPDEF7("SPROMPT", &sprompt),
X	IPDEF7("TIMEFMT", &timefmt),
X	IPDEF7("TMPPREFIX", &tmpprefix),
X	IPDEF7("WATCHFMT", &watchfmt),
X	IPDEF7("0", &argzero),
X
X#define IPDEF8(A,B,C) {NULL,A,NULL,IFN(colonarrsetfn),IFN(colonarrgetfn),0,\
X		PMFLAG_SPECIAL,(vptr)C,NULL,B,NULL,0}
X	IPDEF8("CDPATH", "cdpath", &cdpath),
X	IPDEF8("FIGNORE", "fignore", &fignore),
X	IPDEF8("FPATH", "fpath", &fpath),
X	IPDEF8("MAILPATH", "mailpath", &mailpath),
X	IPDEF8("MANPATH", "manpath", &manpath),
X	IPDEF8("WATCH", "watch", &watch),
X	IPDEF8("PSVAR", "psvar", &psvar),
X	{NULL, "PATH", NULL, IFN(colonpathsetfn), IFN(colonpathgetfn), 0,
X	 PMFLAG_SPECIAL, (vptr) NULL, NULL, "path", NULL, 0},
X
X#define IPDEF9(A,B,C,D) {NULL,A,NULL,IFN(arrvarsetfn),IFN(arrvargetfn),0,\
X		PMFLAG_A|PMFLAG_SPECIAL|C,(vptr)B,NULL,D,NULL,0}
X	IPDEF9("cdpath", &cdpath, 0, "CDPATH"),
X	IPDEF9("fignore", &fignore, 0, "FIGNORE"),
X	IPDEF9("fpath", &fpath, 0, "FPATH"),
X	IPDEF9("mailpath", &mailpath, 0, "MAILPATH"),
X	IPDEF9("manpath", &manpath, 0, "MANPATH"),
X	IPDEF9("watch", &watch, 0, "WATCH"),
X	IPDEF9("psvar", &psvar, 0, "PSVAR"),
X	IPDEF9("signals", &sigptr, PMFLAG_r, NULL),
X	IPDEF9("argv", &pparams, 0, NULL),
X	IPDEF9("*", &pparams, 0, NULL),
X	IPDEF9("@", &pparams, 0, NULL),
X
X	{NULL, "path", NULL, IFN(pathsetfn), IFN(pathgetfn), 0,
X	 PMFLAG_A | PMFLAG_SPECIAL, NULL, NULL, "PATH", NULL, 0},
X
X	{NULL,}
X    };
X    struct iparam *ip;
X
X    for (ip = pinit; ip->nam; ip++)
X	addhnode(ztrdup(ip->nam), ip, paramtab, (FFunc) 0);
X    argvparam = (Param) gethnode("argv", paramtab);
X
X    ((struct iparam *)gethnode("HOSTTYPE", paramtab))->data = (vptr) ztrdup(HOSTTYPE);
X    ((struct iparam *)gethnode("VERSION", paramtab))->data = (vptr) ztrdup(VERSIONSTR);
X}
X
Xstruct param *createparam(name, flags)	/**/
Xchar *name;
Xint flags;
X{
X    struct param *pm, *oldpm = (Param) gethnode(name, paramtab);
X    int spec;
X
X    spec = oldpm && (oldpm->flags & PMFLAG_SPECIAL);
X    if ((oldpm && oldpm->level == locallevel) || spec) {
X	pm = oldpm;
X	pm->ct = 0;
X	oldpm = pm->old;
X	pm->flags = (flags & (PMFLAG_x | PMFLAG_L | PMFLAG_R | PMFLAG_Z |
X			      PMFLAG_l | PMFLAG_u | PMFLAG_r | PMFLAG_t)) |
X	    (pm->flags & (PMFLAG_s | PMFLAG_i | PMFLAG_A | PMFLAG_SPECIAL));
X	if (pm->ename) {
X	    Param altpm = (Param) gethnode(pm->ename, paramtab);
X
X	    if (altpm)
X		altpm->flags &= ~(PMFLAG_UNSET | PMFLAG_x | PMFLAG_L |
X				  PMFLAG_R | PMFLAG_Z | PMFLAG_l |
X				  PMFLAG_u | PMFLAG_r | PMFLAG_t);
X	}
X    } else {
X	pm = (struct param *)zcalloc(sizeof *pm);
X	if ((pm->old = oldpm))
X	    remhnode(name, paramtab);	/* needed to avoid freeing oldpm */
X	addhnode(ztrdup(name), pm, paramtab, freepm);
X    }
X    if (isset(ALLEXPORT) && !oldpm)
X	pm->flags |= PMFLAG_x;
X    if (!spec) {
X	pm->flags = flags;
X	if ((flags & PMTYPE) == PMFLAG_s) {
X	    pm->sets.cfn = strsetfn;
X	    pm->gets.cfn = strgetfn;
X	} else if ((flags & PMTYPE) == PMFLAG_A) {
X	    pm->sets.afn = arrsetfn;
X	    pm->gets.afn = arrgetfn;
X	} else {
X	    pm->sets.ifn = intsetfn;
X	    pm->gets.ifn = intgetfn;
X	}
X    }
X    return pm;
X}
X
Xint isident(s)			/**/
Xchar *s;
X{
X    char *ss;
X    int ne = noeval;
X
X    if (!*s)
X	return 0;
X
X    for (ss = s; *ss; ss++)
X	if (!iident(*ss))
X	    break;
X    if (!*ss || (*ss == '[' && ss[1] == '('))
X	return 1;
X    if (*ss != '[')
X	return 0;
X    noeval = 1;
X    (void)mathevalarg(++ss, &ss);
X    if (*ss == ',' || *ss == Comma)
X	(void)mathevalarg(++ss, &ss);
X    noeval = ne;
X    if (*ss != ']' || ss[1])
X	return 0;
X    return 1;
X}
X
Xchar **garr;
X
Xlong getarg(str, inv, v, a2, w)	/**/
Xchar **str;
Xint *inv;
XValue v;
Xint a2;
Xlong *w;
X{
X    int num = 1, word = 0, rev = 0, ind = 0, down = 0, exp = 0, l, i;
X    char *s = *str, *sep = NULL, *t, sav, *d, **ta, **p, *tt;
X    long r = 0, rr, rrr;
X    Comp c;
X
X    if (*s == '(' || *s == Inpar) {
X	for (s++; *s != ')' && *s != Outpar && s != *str; s++) {
X	    switch (*s) {
X	    case 'r':
X		rev = 1;
X		down = ind = 0;
X		break;
X	    case 'R':
X		rev = down = 1;
X		ind = 0;
X		break;
X	    case 'i':
X		rev = ind = 1;
X		down = 0;
X		break;
X	    case 'I':
X		rev = ind = down = 1;
X		break;
X	    case 'w':
X		word = 1;
X		break;
X	    case 'e':
X		exp = 1;
X		break;
X	    case 'n':
X		t = get_strarg(++s);
X		if (!*t)
X		    goto flagerr;
X		sav = *t;
X		*t = '\0';
X		num = mathevalarg(s + 1, &d);
X		if (!num)
X		    num = 1;
X		*t = sav;
X		s = t;
X		break;
X	    case 's':
X		t = get_strarg(++s);
X		if (!*t)
X		    goto flagerr;
X		sav = *t;
X		*t = '\0';
X		sep = dupstring(s + 1);
X		*t = sav;
X		s = t;
X		break;
X	    default:
X	      flagerr:
X		num = 1;
X		word = rev = ind = down = exp = 0;
X		sep = NULL;
X		s = *str - 1;
X	    }
X	}
X	if (s != *str)
X	    s++;
X    }
X    if (num < 0) {
X	down = !down;
X	num = -num;
X    }
X    *inv = ind;
X
X    for (t = s, i = 0; *t && (*t != ']' || i) &&
X	 (*t != Outbrack || i) && *t != ','; t++)
X	if (*t == '[' || *t == Inbrack)
X	    i++;
X	else if (*t == ']' || *t == Outbrack)
X	    i--;
X
X    if (!*t)
X	return 0;
X    sav = *t;
X    *t = '\0';
X    s = dupstring(s);
X    *t = sav;
X    *str = tt = t;
X
X    if (exp) {
X	tokenize(s);
X	lexsave();
X	strinbeg();
X	singsub(&s);
X	strinend();
X	lexrestore();
X	untokenize(s);
X    }
X    if (!rev) {
X	if (!(r = mathevalarg(s, &s)))
X	    r = 1;
X	if (word && !v->isarr) {
X	    s = t = getstrvalue(v);
X	    i = wordcount(s, sep, 0);
X	    if (r < 0)
X		r += i + 1;
X	    if (r < 1)
X		r = 1;
X	    if (r > i)
X		r = i;
X	    if (!s || !*s)
X		return 0;
X	    rrr = r;
X	    while ((d = findword(&s, sep)) && --r);
X	    if (!d)
X		return 0;
X
X	    if (a2) {
X		if ((d = findword(&s, sep))) {
X		    r = (long)(d - t) - (sep ? strlen(sep) + (rrr == i ? 0 : 1) : 1);
X		} else
X		    r = -1;
X	    } else {
X		rr = (long)(d - t);
X		if (rrr > 1)
X		    rr++;
X		r = rr;
X	    }
X
X	    if (!a2 && *tt != ',' && *tt != Comma)
X		*w = (long)(s - t) - 1;
X	}
X    } else {
X	if (!v->isarr && !word) {
X	    l = strlen(s);
X	    if (a2) {
X		if (!l || *s != '*') {
X		    d = (char *)ncalloc(l + 2);
X		    *d = '*';
X		    strcpy(d + 1, s);
X		    s = d;
X		}
X	    } else {
X		if (!l || s[l - 1] != '*') {
X		    d = (char *)ncalloc(l + 2);
X		    strcpy(d, s);
X		    strcat(d, "*");
X		    s = d;
X		}
X	    }
X	}
X	tokenize(s);
X
X	if ((c = parsereg(s))) {
X	    if (v->isarr) {
X		ta = getarrvalue(v);
X		if (!ta || !*ta)
X		    return 0;
X		if (down)
X		    for (r = -1, p = ta + arrlen(ta) - 1; p >= ta; r--, p--) {
X			if (domatch(*p, c, 0) && !--num)
X			    return r;
X		} else
X		    for (r = 1, p = ta; *p; r++, p++)
X			if (domatch(*p, c, 0) && !--num)
X			    return r;
X	    } else if (word) {
X		ta = sepsplit(d = s = getstrvalue(v), sep);
X		if (down) {
X		    for (p = ta + (r = arrlen(ta)) - 1; p >= ta; p--, r--)
X			if (domatch(*p, c, 0) && !--num)
X			    break;
X		    if (p < ta)
X			return 0;
X		} else {
X		    for (r = 1, p = ta; *p; r++, p++)
X			if (domatch(*p, c, 0) && !--num)
X			    break;
X		    if (!*p)
X			return 0;
X		}
X		if (a2)
X		    r++;
X		for (i = 0, t = findword(&d, sep); t && *t;
X		     i++, t = findword(&d, sep))
X		    if (!--r) {
X			r = (long)(t - s + (a2 ? -1 : 1));
X			if (!a2 && *tt != ',' && *tt != Comma)
X			    *w = r + strlen(ta[i]) - 2;
X			return r;
X		    }
X		return a2 ? -1 : 0;
X	    } else {
X		d = getstrvalue(v);
X		if (!d || !*d)
X		    return 0;
X		if (a2) {
X		    if (down)
X			for (r = -2, t = d + strlen(d) - 1; t >= d; r--, t--) {
X			    sav = *t;
X			    *t = '\0';
X			    if (domatch(d, c, 0) && !--num) {
X				*t = sav;
X				return r;
X			    }
X			    *t = sav;
X		    } else
X			for (r = 0, t = d; *t; r++, t++) {
X			    sav = *t;
X			    *t = '\0';
X			    if (domatch(d, c, 0) && !--num) {
X				*t = sav;
X				return r;
X			    }
X			    *t = sav;
X			}
X		} else {
X		    if (down)
X			for (r = -1, t = d + strlen(d) - 1; t >= d; r--, t--) {
X			    if (domatch(t, c, 0) && !--num)
X				return r;
X		    } else
X			for (r = 1, t = d; *t; r++, t++)
X			    if (domatch(t, c, 0) && !--num)
X				return r;
X		}
X	    }
X	}
X    }
X    return r;
X}
X
XValue getvalue(pptr, bracks)	/**/
Xchar **pptr;
Xint bracks;
X{
X    char *s = *pptr, *t = *pptr;
X    char sav;
X    Value v;
X    int inv = 0;
X
X    garr = NULL;
X
X    if (idigit(*s))
X	while (idigit(*s))
X	    s++;
X    else if (iident(*s))
X	while (iident(*s))
X	    s++;
X    else if (*s == Quest)
X	*s++ = '?';
X    else if (*s == Pound)
X	*s++ = '#';
X    else if (*s == String)
X	*s++ = '$';
X    else if (*s == Qstring)
X	*s++ = '$';
X    else if (*s == Star)
X	*s++ = '*';
X    else if (*s == '#' || *s == '-' || *s == '?' || *s == '$' ||
X	     *s == '_' || *s == '!' || *s == '@' || *s == '*')
X	s++;
X    else
X	return NULL;
X    if ((sav = *s))
X	*s = '\0';
X    if (idigit(*t) && *t != '0') {
X	v = (Value) hcalloc(sizeof *v);
X	v->pm = argvparam;
X	v->inv = 0;
X	v->a = v->b = atoi(t) - 1;
X	if (sav)
X	    *s = sav;
X    } else {
X	struct param *pm;
X	int isvarat = !strcmp(t, "@");
X
X	pm = (struct param *)gethnode(t, paramtab);
X	if (sav)
X	    *s = sav;
X	*pptr = s;
X	if (!pm || (pm->flags & PMFLAG_UNSET))
X	    return NULL;
X	v = (Value) hcalloc(sizeof *v);
X	if (pmtype(pm) == PMFLAG_A)
X	    v->isarr = isvarat ? -1 : 1;
X	v->pm = pm;
X	v->inv = 0;
X	v->a = 0;
X	v->b = -1;
X	if (bracks && (*s == '[' || *s == Inbrack)) {
X	    int a, b;
X	    char *olds = s, *tbrack;
X
X	    *s++ = '[';
X	    for (tbrack = s; *tbrack && *tbrack != ']' && *tbrack != Outbrack; tbrack++)
X		if (itok(*tbrack))
X		    *tbrack = ztokens[*tbrack - Pound];
X	    if (*tbrack == Outbrack)
X		*tbrack = ']';
X	    if ((s[0] == '*' || s[0] == '@') && s[1] == ']') {
X		if (v->isarr)
X		    v->isarr = (s[0] == '*') ? 1 : -1;
X		v->a = 0;
X		v->b = -1;
X		s += 2;
X	    } else {
X		long we = 0, dummy;
X
X		a = getarg(&s, &inv, v, 0, &we);
X		if (a > 0 && !inv)
X		    a--;
X
X		if (inv) {
X		    v->inv = 1;
X		    if (*s == ']' || *s == Outbrack)
X			s++;
X		    v->isarr = 0;
X		    v->a = v->b = a;
X		    if (*s == ',' || *s == Comma) {
X			zerr("invalid subscript", NULL, 0);
X			while (*s != ']' && *s != Outbrack)
X			    s++;
X			*pptr = s;
X			return v;
X		    }
X		} else {
X		    if (*s == ',' || *s == Comma) {
X			s++;
X			b = getarg(&s, &inv, v, 1, &dummy);
X			if (b > 0)
X			    b--;
X		    } else {
X			b = we ? we : a;
X		    }
X		    if (*s == ']' || *s == Outbrack) {
X			s++;
X			if (v->isarr && a == b)
X			    v->isarr = 0;
X			v->a = a;
X			v->b = b;
X		    } else
X			s = olds;
X		}
X	    }
X	}
X    }
X    if (!bracks && *s)
X	return NULL;
X    *pptr = s;
X    return v;
X}
X
Xchar *getstrvalue(v)		/**/
XValue v;
X{
X    char *s, **ss;
X    static char buf[20];
X
X    if (!v)
X	return "";
X    if (v->inv) {
X	sprintf(buf, "%d", v->a);
X	return dupstring(buf);
X    }
X    if (pmtype(v->pm) != PMFLAG_A) {
X	if ((pmtype(v->pm) == PMFLAG_i))
X	    convbase(s = buf, v->pm->gets.ifn(v->pm), v->pm->ct);
X	else
X	    s = v->pm->gets.cfn(v->pm);
X	if (v->a == 0 && v->b == -1)
X	    return s;
X	if (v->a < 0)
X	    v->a += strlen(s);
X	if (v->b < 0)
X	    v->b += strlen(s);
X	s = (v->a > (int)strlen(s)) ? dupstring("") : dupstring(s + v->a);
X	if (v->b < v->a)
X	    s[0] = '\0';
X	else if (v->b - v->a < (int)strlen(s))
X	    s[v->b - v->a + 1] = '\0';
X	return s;
X    }
X    if (v->isarr)
X	return spacejoin(v->pm->gets.afn(v->pm));
X
X    ss = v->pm->gets.afn(v->pm);
X    if (v->a < 0)
X	v->a += arrlen(ss);
X    s = (v->a >= arrlen(ss) || v->a < 0) ? "" : ss[v->a];
X    return s;
X}
X
Xstatic char *nular[] =
X{"", NULL};
X
Xchar **getarrvalue(v)		/**/
XValue v;
X{
X    char **s;
X
X    if (!v)
X	return arrdup(nular);
X    if (v->inv) {
X	char buf[20];
X
X	s = arrdup(nular);
X	sprintf(buf, "%d", v->a);
X	s[0] = dupstring(buf);
X	return s;
X    }
X    s = v->pm->gets.afn(v->pm);
X    if (v->a == 0 && v->b == -1)
X	return s;
X    if (v->a < 0)
X	v->a += arrlen(s);
X    if (v->b < 0)
X	v->b += arrlen(s);
X    if (v->a > arrlen(s) || v->a < 0)
X	s = arrdup(nular);
X    else
X	s = arrdup(s) + v->a;
X    if (v->b < v->a)
X	s[0] = NULL;
X    else if (v->b - v->a < arrlen(s))
X	s[v->b - v->a + 1] = NULL;
X    return s;
X}
X
Xlong getintvalue(v)		/**/
XValue v;
X{
X    char **ss;
X
X    if (!v || v->isarr)
X	return 0;
X    if (v->inv)
X	return v->a;
X    if (pmtype(v->pm) != PMFLAG_A) {
X	if (pmtype(v->pm) == PMFLAG_i)
X	    return v->pm->gets.ifn(v->pm);
X	return atol(v->pm->gets.cfn(v->pm));
X    }
X    ss = v->pm->gets.afn(v->pm);
X    if (v->a < 0)
X	v->a += arrlen(ss);
X    if (v->a < 0 || v->a >= arrlen(ss))
X	return 0;
X    return atol(ss[v->a]);
X}
X
Xvoid setstrvalue(v, val)	/**/
XValue v;
Xchar *val;
X{
X    char buf[20];
X
X    if (v->pm->flags & PMFLAG_r) {
X	zsfree(val);
X	return;
X    }
X    switch (pmtype(v->pm)) {
X    case PMFLAG_s:
X	if (v->a == 0 && v->b == -1) {
X	    (v->pm->sets.cfn) (v->pm, val);
X	    if (v->pm->flags & (PMFLAG_L | PMFLAG_R | PMFLAG_Z) && !v->pm->ct)
X		v->pm->ct = strlen(val);
X	} else {
X	    char *z, *y, *x;
X	    int zlen;
X
X	    z = dupstring((v->pm->gets.cfn) (v->pm));
X	    zlen = strlen(z);
X	    if (v->inv)
X		v->a--, v->b--;
X	    if (v->a < 0) {
X		v->a += zlen;
X		if (v->a < 0)
X		    v->a = 0;
X	    }
X	    if (v->a > zlen)
X		v->a = zlen;
X	    if (v->b < 0)
X		v->b += zlen;
X	    if (v->b < v->a)
X		v->b = v->a;
X	    if (v->b > zlen - 1)
X		v->b = zlen - 1;
X	    z[v->a] = '\0';
X	    y = z + v->b + 1;
X	    x = (char *)zalloc(strlen(z) + strlen(y) + strlen(val) + 1);
X	    strcpy(x, z);
X	    strcat(x, val);
X	    strcat(x, y);
X	    (v->pm->sets.cfn) (v->pm, x);
X	    zsfree(val);
X	}
X	break;
X    case PMFLAG_i:
X	(v->pm->sets.ifn) (v->pm, matheval(val));
X	if (!v->pm->ct && lastbase != 1)
X	    v->pm->ct = lastbase;
X	zsfree(val);
X	break;
X    case PMFLAG_A:
X	if (v->a != v->b) {
X	    char **ss = (char **)zalloc(2 * sizeof(char *));
X
X	    ss[0] = val;
X	    ss[1] = NULL;
X	} else {
X	    char **ss = (v->pm->gets.afn) (v->pm);
X	    int ac, ad, t0;
X
X	    if (v->inv)
X		v->a--, v->b--;
X	    ac = arrlen(ss);
X	    if (v->a < 0) {
X		v->a += ac;
X		if (v->a < 0)
X		    v->a = 0;
X	    }
X	    if (v->a >= ac) {
X		char **st = ss;
X
X		ad = v->a + 1;
X		ss = (char **)zalloc((ad + 1) * sizeof *ss);
X		for (t0 = 0; t0 != ac; t0++)
X		    ss[t0] = ztrdup(st[t0]);
X		while (ac < ad)
X		    ss[ac++] = ztrdup("");
X		ss[ac] = NULL;
X	    }
X	    zsfree(ss[v->a]);
X	    ss[v->a] = val;
X	    (v->pm->sets.afn) (v->pm, ss);
X	}
X	break;
X    }
X    if ((!v->pm->env && !(v->pm->flags & PMFLAG_x) &&
X	 !(isset(ALLEXPORT) && !v->pm->old)) ||
X	(v->pm->flags & PMFLAG_A) || v->pm->ename)
X	return;
X    if (pmtype(v->pm) == PMFLAG_i)
X	convbase(val = buf, v->pm->gets.ifn(v->pm), v->pm->ct);
X    else
X	val = v->pm->gets.cfn(v->pm);
X    if (v->pm->env)
X	v->pm->env = replenv(v->pm->env, val);
X    else {
X	v->pm->flags |= PMFLAG_x;
X	v->pm->env = addenv(v->pm->nam, val);
X    }
X}
X
Xvoid setintvalue(v, val)	/**/
XValue v;
Xlong val;
X{
X    char buf[20];
X
X    if (v->pm->flags & PMFLAG_r)
X	return;
X    sprintf(buf, "%ld", val);
X    if (v->pm->env) {
X	v->pm->env = replenv(v->pm->env, buf);
X    } else if ((v->pm->flags & PMFLAG_x) ||
X	       (isset(ALLEXPORT) && !v->pm->old)) {
X	v->pm->flags |= PMFLAG_x;
X	v->pm->env = addenv(v->pm->nam, buf);
X    }
X    switch (pmtype(v->pm)) {
X    case PMFLAG_s:
X	(v->pm->sets.cfn) (v->pm, ztrdup(buf));
X	break;
X    case PMFLAG_i:
X	(v->pm->sets.ifn) (v->pm, val);
X	if (!v->pm->ct && lastbase != -1)
X	    v->pm->ct = lastbase;
X	break;
X    case PMFLAG_A:
X	zerr("attempt to assign integer to array", NULL, 0);
X	break;
X    }
X}
X
Xvoid setintenv(s, val)		/**/
Xchar *s;
Xlong val;
X{
X    Param pm;
X    char buf[20];
X
X    if ((pm = (Param) gethnode(s, paramtab)) && pm->env) {
X	sprintf(buf, "%ld", val);
X	pm->env = replenv(pm->env, buf);
X    }
X}
X
Xvoid setarrvalue(v, val)	/**/
XValue v;
Xchar **val;
X{
X    if (v->pm->flags & PMFLAG_r) {
X	freearray(val);
X	return;
X    }
X    if (pmtype(v->pm) != PMFLAG_A) {
X	freearray(val);
X	zerr("attempt to assign array value to non-array", NULL, 0);
X	return;
X    }
X    if (v->a == 0 && v->b == -1)
X	(v->pm->sets.afn) (v->pm, val);
X    else {
X	char **old, **new, **p, **q, **r;
X	int n, nn, l, ll, i;
X
X	if (v->inv)
X	    v->a--, v->b--;
X	q = old = v->pm->gets.afn(v->pm);
X	n = arrlen(old);
X	if (v->a < 0)
X	    v->a += n;
X	if (v->b < 0)
X	    v->b += n;
X	if (v->a < 0)
X	    v->a = 0;
X	if (v->b < 0)
X	    v->b = 0;
X	if (v->a >= n)
X	    v->a = n;
X	if (v->b >= n)
X	    v->b = n;
X
X	if (v->a > v->b)
X	    (v->pm->sets.afn) (v->pm, arrdup(nular));
X	else {
X	    l = v->b - v->a + 1;
X
X	    nn = arrlen(val);
X
X	    ll = n - l + nn;
X
X	    p = new = (char **)zcalloc(sizeof(char *) * (ll + 1));
X
X	    for (i = 0; i < v->a; i++)
X		*p++ = ztrdup(*q++);
X	    for (r = val; *r;)
X		*p++ = ztrdup(*r++);
X	    if (*q)
X		for (q += l; *q;)
X		    *p++ = ztrdup(*q++);
X
X	    (v->pm->sets.afn) (v->pm, new);
X	}
X	freearray(val);
X	freearray(old);
X    }
X}
X
Xlong getiparam(s)		/**/
Xchar *s;
X{
X    Value v;
X
X    if (!(v = getvalue(&s, 0)))
X	return 0;
X    return getintvalue(v);
X}
X
Xchar *getsparam(s)		/**/
Xchar *s;
X{
X    Value v;
X
X    if (!(v = getvalue(&s, 0)))
X	return NULL;
X    return getstrvalue(v);
X}
X
Xchar **getaparam(s)		/**/
Xchar *s;
X{
X    Value v;
X
X    if (!((v = getvalue(&s, 0)) && v->isarr))
X	return NULL;
X    return getarrvalue(v);
X}
X
XParam setsparam(s, val)		/**/
Xchar *s;
Xchar *val;
X{
X    Value v;
X    char *t = s;
X    char *ss;
X
X    if (!isident(s)) {
X	zerr("not an identifier: %s", s, 0);
X	zsfree(val);
X	errflag = 1;
X	return NULL;
X    }
X    if ((ss = strchr(s, '['))) {
X	*ss = '\0';
X	if (!(v = getvalue(&s, 1)))
X	    createparam(t, PMFLAG_A);
X	*ss = '[';
X	v = NULL;
X    } else {
X	if (!(v = getvalue(&s, 1)))
X	    createparam(t, PMFLAG_s);
X	else if ((v->pm->flags & PMTYPE) == PMFLAG_A &&
X		 !(v->pm->flags & PMFLAG_SPECIAL)) {
X	    unsetparam(t);
X	    createparam(t, PMFLAG_s);
X	    v = NULL;
X	}
X    }
X    if (!v)
X	v = getvalue(&t, 1);
X    setstrvalue(v, val);
X    return v->pm;
X}
X
XParam setaparam(s, val)		/**/
Xchar *s;
Xchar **val;
X{
X    Value v;
X    char *t = s;
X    char *ss;
X
X    if (!isident(s)) {
X	zerr("not an identifier: %s", s, 0);
X	freearray(val);
X	errflag = 1;
X	return NULL;
X    }
X    if ((ss = strchr(s, '['))) {
X	*ss = '\0';
X	if (!(v = getvalue(&s, 1)))
X	    createparam(t, PMFLAG_A);
X	*ss = '[';
X	v = NULL;
X    } else {
X	if (!(v = getvalue(&s, 1)))
X	    createparam(t, PMFLAG_A);
X	else if ((v->pm->flags & PMTYPE) != PMFLAG_A &&
X		 !(v->pm->flags & PMFLAG_SPECIAL)) {
X	    unsetparam(t);
X	    createparam(t, PMFLAG_A);
X	    v = NULL;
X	}
X    }
X    if (!v)
X	v = getvalue(&t, 1);
X    setarrvalue(v, val);
X    return v->pm;
X}
X
XParam setiparam(s, val)		/**/
Xchar *s;
Xlong val;
X{
X    Value v;
X    char *t = s;
X    Param pm;
X
X    if (!isident(s)) {
X	zerr("not an identifier: %s", s, 0);
X	errflag = 1;
X	return NULL;
X    }
X    if (!(v = getvalue(&s, 0))) {
X	pm = createparam(t, PMFLAG_i);
X	pm->u.val = val;
X	return pm;
X    }
X    setintvalue(v, val);
X    return v->pm;
X}
X
Xvoid unsetparam(s)		/**/
Xchar *s;
X{
X    Param pm, oldpm;
X    int spec;
X    static int altflag = 0;
X
X    if (!(pm = (Param) gethnode(s, paramtab)))
X	return;
X    if ((pm->flags & PMFLAG_r) && pm->level <= locallevel)
X	return;
X    spec = (pm->flags & PMFLAG_SPECIAL) && !pm->level;
X    switch (pmtype(pm)) {
X    case 0:
X	(pm->sets.cfn) (pm, NULL);
X	break;
X    case PMFLAG_i:
X	(pm->sets.ifn) (pm, 0);
X	break;
X    case PMFLAG_A:
X	(pm->sets.afn) (pm, NULL);
X	break;
X    }
X    if ((pm->flags & PMFLAG_x) && pm->env) {
X	delenv(pm->env);
X	zsfree(pm->env);
X	pm->env = NULL;
X    }
X    if (pm->ename && !altflag) {
X	altflag = 1;
X	unsetparam(pm->ename);
X	altflag = 0;
X    }
X    if ((locallevel && locallevel == pm->level) || spec) {
X	pm->flags |= PMFLAG_UNSET;
X    } else {
X	oldpm = pm->old;
X	freepm(remhnode(s, paramtab));
X	if (oldpm) {
X	    addhnode(ztrdup(s), oldpm, paramtab, freepm);
X	    if (!(oldpm->flags & PMTYPE) && oldpm->sets.cfn == strsetfn)
X		adduserdir(oldpm->nam, oldpm->u.str, 0, 1);
X	}
X    }
X}
X
Xvoid intsetfn(pm, x)		/**/
XParam pm;
Xlong x;
X{
X    pm->u.val = x;
X}
X
Xlong intgetfn(pm)		/**/
XParam pm;
X{
X    return pm->u.val;
X}
X
Xvoid strsetfn(pm, x)		/**/
XParam pm;
Xchar *x;
X{
X    zsfree(pm->u.str);
X    pm->u.str = x;
X    adduserdir(pm->nam, x, 0, 2);
X}
X
Xchar *strgetfn(pm)		/**/
XParam pm;
X{
X    return pm->u.str ? pm->u.str : "";
X}
X
Xvoid nullsetfn(pm, x)		/**/
XParam pm;
Xchar *x;
X{
X    zsfree(x);
X}
X
Xvoid arrsetfn(pm, x)		/**/
XParam pm;
Xchar **x;
X{
X    if (pm->u.arr && pm->u.arr != x)
X	freearray(pm->u.arr);
X    pm->u.arr = x;
X}
X
Xchar **arrgetfn(pm)		/**/
XParam pm;
X{
X    char *nullarray = NULL;
X
X    return pm->u.arr ? pm->u.arr : &nullarray;
X}
X
Xvoid intvarsetfn(pm, x)		/**/
XParam pm;
Xlong x;
X{
X    *((long *)pm->data) = x;
X}
X
Xlong intvargetfn(pm)		/**/
XParam pm;
X{
X    return *((long *)pm->data);
X}
X
Xvoid strvarsetfn(pm, x)		/**/
XParam pm;
Xchar *x;
X{
X    char **q = ((char **)pm->data);
X
X    zsfree(*q);
X    *q = x;
X}
X
Xchar *strvargetfn(pm)		/**/
XParam pm;
X{
X    char *s = *((char **)pm->data);
X
X    if (!s)
X	return "";
X    return s;
X}
X
Xchar *strconstgetfn(pm)		/**/
XParam pm;
X{
X    return (char *)pm->data;
X}
X
Xchar **colonfix(x, ename)	/**/
Xchar *x;
Xchar *ename;
X{
X    char **s, **t;
X
X    s = colonsplit(x);
X    if (ename)
X	arrfixenv(ename, s);
X    zsfree(x);
X    for (t = s; *t; t++)
X	if (!**t) {
X	    free(*t);
X	    *t = ztrdup(".");
X	}
X    return s;
X}
X
Xvoid colonarrsetfn(pm, x)	/**/
XParam pm;
Xchar *x;
X{
X    char ***dptr = (char ***)pm->data;
X
X    freearray(*dptr);
X    if (pm->data == (vptr) & mailpath && x && !*x) {
X	zsfree(x);
X	*dptr = mkarray(NULL);
X    } else
X	*dptr = x ? colonfix(x, pm->ename ? pm->nam : NULL) : mkarray(NULL);
X}
X
Xvoid colonpathsetfn(pm, x)	/**/
XParam pm;
Xchar *x;
X{
X    freearray(path);
X    path = x ? colonfix(x, pm->nam) : mkarray(NULL);
X    newcmdnamtab();
X}
X
Xchar *colonarrgetfn(pm)		/**/
XParam pm;
X{
X    return join(*(char ***)pm->data, ':');
X}
X
Xchar *colonpathgetfn(pm)	/**/
XParam pm;
X{
X    return join(path, ':');
X}
X
Xchar **arrvargetfn(pm)		/**/
XParam pm;
X{
X    return *((char ***)pm->data);
X}
X
Xvoid arrvarsetfn(pm, x)		/**/
XParam pm;
Xchar **x;
X{
X    char ***dptr = (char ***)pm->data;
X
X    if (*dptr != x)
X	freearray(*dptr);
X    *dptr = x ? x : mkarray(NULL);
X    if (pm->ename && x)
X	arrfixenv(pm->ename, x);
X}
X
Xchar **pathgetfn(pm)		/**/
XParam pm;
X{
X    return path;
X}
X
Xvoid pathsetfn(pm, x)		/**/
XParam pm;
Xchar **x;
X{
X    if (path != x)
X	freearray(path);
X    path = x ? x : mkarray(NULL);
X    newcmdnamtab();
X    if (x)
X	arrfixenv("PATH", x);
X}
X
Xlong poundgetfn(pm)		/**/
XParam pm;
X{
X    return arrlen(pparams);
X}
X
Xlong randomgetfn(pm)		/**/
XParam pm;
X{
X    return rand() & 0x7fff;
X}
X
Xvoid randomsetfn(pm, v)		/**/
XParam pm;
Xlong v;
X{
X    srand((unsigned int)v);
X}
X
Xlong secondsgetfn(pm)		/**/
XParam pm;
X{
X    return time(NULL) - shtimer.tv_sec;
X}
X
Xvoid secondssetfn(pm, x)	/**/
XParam pm;
Xlong x;
X{
X    shtimer.tv_sec = time(NULL) - x;
X    shtimer.tv_usec = 0;
X}
X
Xlong uidgetfn(pm)		/**/
XParam pm;
X{
X    return getuid();
X}
X
Xlong euidgetfn(pm)		/**/
XParam pm;
X{
X    return geteuid();
X}
X
Xlong gidgetfn(pm)		/**/
XParam pm;
X{
X    return getgid();
X}
X
Xlong egidgetfn(pm)		/**/
XParam pm;
X{
X    return getegid();
X}
X
Xchar *ifsgetfn(pm)		/**/
XParam pm;
X{
X    return ifs;
X}
X
Xvoid ifssetfn(pm, x)		/**/
XParam pm;
Xchar *x;
X{
X    if (x) {
X	zsfree(ifs);
X	ifs = x;
X    }
X    inittyptab();
X}
X
Xvoid histsizesetfn(pm, v)	/**/
XParam pm;
Xlong v;
X{
X    if ((histsiz = v) <= 2)
X	histsiz = 2;
X    resizehistents();
X}
X
Xlong histsizegetfn(pm)		/**/
XParam pm;
X{
X    return histsiz;
X}
X
Xvoid lithistsizesetfn(pm, v)	/**/
XParam pm;
Xlong v;
X{
X    if ((lithistsiz = v) <= 2)
X	lithistsiz = 2;
X    resizehistents();
X}
X
Xlong lithistsizegetfn(pm)	/**/
XParam pm;
X{
X    return lithistsiz;
X}
X
Xlong errnogetfn(pm)		/**/
XParam pm;
X{
X    return errno;
X}
X
Xchar *dashgetfn(pm)		/**/
XParam pm;
X{
X    static char buf[100];
X    char *val;
X    int t0;
X
X    for (val = buf, t0 = ' '; t0 <= 'z'; t0++)
X	if (isset(t0))
X	    *val++ = t0;
X    *val = '\0';
X    return buf;
X}
X
Xvoid histcharssetfn(pm, x)	/**/
XParam pm;
Xchar *x;
X{
X    if (x) {
X	bangchar = x[0];
X	hatchar = (bangchar) ? x[1] : '\0';
X	hashchar = (hatchar) ? x[2] : '\0';
X	zsfree(x);
X    }
X}
X
Xchar *histcharsgetfn(pm)	/**/
XParam pm;
X{
X    static char buf[4];
X
X    buf[0] = bangchar;
X    buf[1] = hatchar;
X    buf[2] = hashchar;
X    buf[3] = '\0';
X    return buf;
X}
X
Xchar *homegetfn(pm)		/**/
XParam pm;
X{
X    return home;
X}
X
Xvoid homesetfn(pm, x)		/**/
XParam pm;
Xchar *x;
X{
X    zsfree(home);
X    if (x && isset(CHASELINKS) && (home = xsymlink(x)))
X	zsfree(x);
X    else
X	home = x ? x : ztrdup("");
X    adduserdir("", home, 0, 1);
X}
X
Xchar *wordcharsgetfn(pm)	/**/
XParam pm;
X{
X    return wordchars;
X}
X
Xvoid wordcharssetfn(pm, x)	/**/
XParam pm;
Xchar *x;
X{
X    zsfree(wordchars);
X    if (x)
X	wordchars = x;
X    else
X	wordchars = ztrdup(DEFWORDCHARS);
X    inittyptab();
X}
X
Xchar *underscoregetfn(pm)	/**/
XParam pm;
X{
X    char *s, *t;
X
X    if (!(s = qgetevent(curhist - 1)))
X	return "";
X    for (t = s + strlen(s); t > s; t--)
X	if (*t == HISTSPACE)
X	    break;
X    if (t != s)
X	t++;
X    return t;
X}
X
Xchar *termgetfn(pm)		/**/
XParam pm;
X{
X    return term;
X}
X
Xextern hasam;
X
Xvoid termsetfn(pm, x)		/**/
XParam pm;
Xchar *x;
X{
X    zsfree(term);
X    term = x ? x : ztrdup("");
X    if (!interact || unset(USEZLE))
X	return;
X    if (!*term) {
X	termok = 0;
X    } else if (tgetent(termbuf, term) != 1) {
X	zerr("can't find termcap info for %s", term, 0);
X	errflag = 0;
X	termok = 0;
X    } else {
X	char tbuf[1024], *pp;
X	int t0;
X
X	termok = 1;
X	for (t0 = 0; t0 != TC_COUNT; t0++) {
X	    pp = tbuf;
X	    zsfree(tcstr[t0]);
X	/* AIX tgetstr() ignores second argument */
X	    if (!(pp = tgetstr(tccapnams[t0], &pp)))
X		tcstr[t0] = NULL, tclen[t0] = 0;
X	    else {
X		tcstr[t0] = (char *)zalloc(tclen[t0] = strlen(pp) + 1);
X		memcpy(tcstr[t0], pp, tclen[t0]);
X	    }
X	}
X
X    /* if there's no termcap entry for cursor up, forget it.
X	Use single line mode. */
X
X	if (!tccan(TCUP)) {
X	    termok = 0;
X	    return;
X	}
X	hasam = tgetflag("am");
X    /* if there's no termcap entry for cursor left, use \b. */
X
X	if (!tccan(TCLEFT)) {
X	    tcstr[TCLEFT] = ztrdup("\b");
X	    tclen[TCLEFT] = 1;
X	}
X    /* if there's no termcap entry for clear, use ^L. */
X
X	if (!tccan(TCCLEARSCREEN)) {
X	    tcstr[TCCLEARSCREEN] = ztrdup("\14");
X	    tclen[TCCLEARSCREEN] = 1;
X	}
X    /* if the termcap entry for down is \n, don't use it. */
X
X	if (tccan(TCDOWN) && tcstr[TCDOWN][0] == '\n') {
X	    tclen[TCDOWN] = 0;
X	    zsfree(tcstr[TCDOWN]);
X	    tcstr[TCDOWN] = NULL;
X	}
X    }
X}
X
Xvoid setparams()
X{				/**/
X    char **envp, **envp2, **envp3, *str;
X    char buf[50];
X    struct param *pm;
X    int ct;
X
X    noerrs = 1;
X    for (envp = environ, ct = 2; *envp; envp++, ct++);
X    envp = environ;
X    envp2 = envp3 = (char **)zalloc(sizeof(char *) * ct);
X
X    for (; *envp; envp++)
X	*envp2++ = ztrdup(*envp);
X    *envp2 = NULL;
X    envp = environ;
X    environ = envp2 = envp3;
X    for (; *envp; envp++, envp2++) {
X	for (str = *envp; *str && *str != '='; str++);
X	if (*str == '=') {
X	    char *iname = NULL;
X
X	    *str = '\0';
X	    pm = (!idigit(**envp) && isident(*envp) && !strchr(*envp, '[')) ?
X		setsparam(iname = *envp, ztrdup(str + 1)) : NULL;
X	    if (pm) {
X		pm->flags |= PMFLAG_x;
X		pm->env = *envp2;
X		if (pm->flags & PMFLAG_SPECIAL)
X		    pm->env = replenv(pm->env, getsparam(iname));
X	    }
X	    *str = '=';
X	}
X    }
X    pm = (struct param *)gethnode("HOME", paramtab);
X    if (!(pm->flags & PMFLAG_x)) {
X	pm->flags |= PMFLAG_x;
X	pm->env = addenv("HOME", home);
X    }
X    pm = (struct param *)gethnode("PWD", paramtab);
X    if (!(pm->flags & PMFLAG_x)) {
X	pm->flags |= PMFLAG_x;
X	pm->env = addenv("PWD", pwd);
X    }
X    pm = (struct param *)gethnode("LOGNAME", paramtab);
X    if (!(pm->flags & PMFLAG_x)) {
X	pm->flags |= PMFLAG_x;
X	pm->env = addenv("LOGNAME", zlogname);
X    }
X    pm = (struct param *)gethnode("SHLVL", paramtab);
X    if (!(pm->flags & PMFLAG_x))
X	pm->flags |= PMFLAG_x;
X    sprintf(buf, "%d", (int)++shlvl);
X    pm->env = addenv("SHLVL", buf);
X    noerrs = 0;
X}
X
Xchar *mkenvstr(x, y)		/**/
Xchar *x;
Xchar *y;
X{
X    char *z;
X    int xl = strlen(x), yl = strlen(y);
X
X    z = (char *)zalloc(xl + yl + 2);
X    strcpy(z, x);
X    z[xl] = '=';
X    strcpy(z + xl + 1, y);
X    z[xl + yl + 1] = '\0';
X    return z;
X}
X
Xvoid arrfixenv(s, t)		/**/
Xchar *s;
Xchar **t;
X{
X    char **ep, *u = join(t, ':');
X    int sl = strlen(s);
X    Param pm = (Param) gethnode(s, paramtab);
X
X    for (ep = environ; *ep; ep++)
X	if (!strncmp(*ep, s, sl) && (*ep)[sl] == '=') {
X	    pm->env = replenv(*ep, u);
X	    return;
X	}
X    if (isset(ALLEXPORT))
X	pm->flags |= PMFLAG_x;
X    if (pm->flags & PMFLAG_x)
X	pm->env = addenv(s, u);
X}
X
Xchar *replenv(e, value)		/**/
Xchar *e;
Xchar *value;
X{
X    char **ep;
X
X    for (ep = environ; *ep; ep++)
X	if (*ep == e) {
X	    char *s = e;
X
X	    while (*s++ != '=');
X	    *s = '\0';
X	    *ep = (char *)zalloc(strlen(e) + strlen(value) + 2);
X	    strcpy(*ep, e);
X	    strcat(*ep, value);
X	    zsfree(e);
X	    return *ep;
X	}
X    return NULL;
X}
X
Xchar *addenv(name, value)	/**/
Xchar *name;
Xchar *value;
X{
X    char **ep, **ep2, **ep3;
X    int envct;
X
X    for (ep = environ; *ep; ep++) {
X	char *s = *ep, *t = name;
X
X	while (*s && *s == *t)
X	    s++, t++;
X	if (*s == '=' && !*t) {
X	    zsfree(*ep);
X	    return *ep = mkenvstr(name, value);
X	}
X    }
X    envct = arrlen(environ);
X    ep = ep2 = (char **)zalloc((sizeof(char *)) * (envct + 3));
X
X    for (ep3 = environ; (*ep2 = *ep3); ep3++, ep2++);
X    *ep2 = mkenvstr(name, value);
X    ep2[1] = NULL;
X    free(environ);
X    environ = ep;
X    return *ep2;
X}
X
Xvoid delenv(x)			/**/
Xchar *x;
X{
X    char **ep;
X
X    ep = environ;
X    for (; *ep; ep++)
X	if (*ep == x)
X	    break;
X    if (*ep)
X	for (; (ep[0] = ep[1]); ep++);
X}
X
Xvoid convbase(s, v, base)	/**/
Xchar *s;
Xlong v;
Xint base;
X{
X    int digs = 0;
X    long x;
X
X    if (base <= 1)
X	base = 10;
X    x = v;
X    if (x < 0) {
X	x = -x;
X	digs++;
X    }
X    for (; x; digs++)
X	x /= base;
X    if (!digs)
X	digs = 1;
X    s[digs--] = '\0';
X    x = (v < 0) ? -v : v;
X    while (digs >= 0) {
X	int dig = x % base;
X
X	s[digs--] = (dig < 10) ? '0' + dig : dig - 10 + 'A';
X	x /= base;
X    }
X    if (v < 0)
X	s[0] = '-';
X}
END_OF_FILE
  if test 33893 -ne `wc -c <'zsh-2.5.0/src/params.c'`; then
    echo shar: \"'zsh-2.5.0/src/params.c'\" unpacked with wrong size!
  fi
  # end of 'zsh-2.5.0/src/params.c'
fi
echo shar: End of archive 12 \(of 18\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
